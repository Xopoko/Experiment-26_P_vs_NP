## 15. Proof complexity: резолюция и PHP

В proof complexity изучают **длины доказательств**.
Сильные нижние оценки возможны в слабых системах, но перенос на сильные
связан с $\mathrm{NP}$ vs $\mathrm{coNP}$.

**Определение (proof system, Cook–Reckhow; грубо).** Для языка $L\subseteq\Sigma^\*$ это полиномиальный верификатор $V(x,\pi)$, где:
- *(звук)* $V(x,\pi)=1 \Rightarrow x\in L$;
- *(полнота)* $x\in L \Rightarrow \exists \pi,\ |\pi|\le \mathrm{poly}(|x|):\ V(x,\pi)=1$.

**Лемма 15.1 (Cook–Reckhow, 1979).** $\mathrm{NP}=\mathrm{coNP}$ тогда
и только тогда, когда существует полиномиально ограниченная proof system
для $\mathrm{TAUT}$.

*Доказательство.* Если $\mathrm{TAUT}$ имеет p‑bounded proof system,
то $\mathrm{TAUT}\in\mathrm{NP}$ и $\mathrm{coNP}\subseteq\mathrm{NP}$,
значит $\mathrm{NP}=\mathrm{coNP}$.
Обратно, если $\mathrm{NP}=\mathrm{coNP}$, то $\mathrm{TAUT}\in\mathrm{NP}$ и есть p‑bounded proof system. $\square$

**Следствие (переформулировка).** Существование p‑bounded proof system
для $\mathrm{TAUT}$ $\Rightarrow$ $\mathrm{NP}=\mathrm{coNP}$ (по Лемме 15.1).

**Резолюция (Resolution).** Работаем с CNF. Правило: из $(A\lor x)$
и $(B\lor\neg x)$ выводим $(A\lor B)$.
*Рефутация* $F$ — вывод пустой клаузы из клауз $F$.

**CNF‑формулировка принципа Дирихле (PHP):** Пусть переменная $x_{i,j}$
означает «голубь $i$ сидит в норке $j$». CNF $\mathrm{PHP}^{n}_{m}$ состоит из:
- *(птица где‑то сидит)* $\forall i$: $x_{i,1}\lor\cdots\lor x_{i,n}$;
- *(не вместе)* $\forall j,\ i\ne i'$: $(\neg x_{i,j}\lor\neg x_{i',j})$; при $m=n+1$ формула невыполнима.

**Теорема 15.2 (Haken, 1985).** Существует константа $c>1$ такая, что любая
резолюционная рефутация $\mathrm{PHP}^{n}_{n+1}$ имеет размер $\ge c^n$
(то есть $2^{\Omega(n)}$).

*Комментарий.* Полное доказательство по схеме «критические присваивания → положительная версия → ограничения» (TSS).
См. `../resources/downloads/tss_proof_complexity_notes.pdf`, Thm 2 (Hak85), Sec. 3.

Современная «упаковка» таких результатов: связь размера с *шириной*
(Ben‑Sasson–Wigderson, 2001). Она особенно полезна для 3‑CNF
(где начальная ширина константна).

**Определение (ширина резолюции).** Ширина вывода — максимум числа литералов в клаузе, встретившейся в резолюционном выводе.

**Теорема 15.3 (Ben‑Sasson–Wigderson, 2001).** Пусть $F$ — CNF на $N$ переменных,
$w_0$ — максимальная ширина исходных клауз, $W$ — минимальная ширина
резолюционной рефутации.
Тогда размер любой рефутации $\ge 2^{\Omega((W-w_0)^2/N)}$.

**Замечание.** Size–width требует малой $w_0$ и контроля числа переменных; см. Ben‑Sasson–Wigderson, Sec. 4, и TSS/de Wolf.

### 15.4. Критические присваивания и «положительная версия» (полное доказательство)

Дальше полезно фиксировать подмножество присваиваний, на которых отрицания можно заменить «положительными» дизъюнкциями.

**Определение (критическое присваивание).** Для $\mathrm{PHP}^{n}_{n+1}$
присваивание $\alpha$ *критическое*, если существует индекс
$i_0\in\{1,\dots,n+1\}$ такой, что:
- для каждого $j\in\{1,\dots,n\}$ существует **ровно один** $i\ne i_0$ с $x_{i,j}(\alpha)=1$ (каждая норка занята ровно одним голубем);
- для каждого $i\ne i_0$ существует **ровно один** $j$ с $x_{i,j}(\alpha)=1$ (каждый из остальных голубей сидит ровно в одной норке);
- для $i=i_0$ верно $x_{i_0,j}(\alpha)=0$ для всех $j$ (один «лишний» голубь не сидит нигде).

**Определение (положительная замена отрицания).** Определим
$$X_{i,j}:=\bigvee_{i'\ne i} x_{i',j}.$$
Для клаузы $C$ над $x_{i,j},\neg x_{i,j}$ определим $C^+$ как замену
каждого $\neg x_{i,j}$ на $X_{i,j}$ с раскрытием; $C^+$ — положительная клауза.

**Лемма 15.4.** Для любого критического $\alpha$ и любой клаузы $C$ верно $C(\alpha)=C^+(\alpha)$.

*Доказательство.* На критическом $\alpha$ в каждом столбце $j$ стоит ровно одна единица. Поэтому для любых $i,j$:

- если $x_{i,j}(\alpha)=1$, то все $x_{i',j}(\alpha)=0$ при $i'\ne i$, значит $X_{i,j}(\alpha)=0$ и также $(\neg x_{i,j})(\alpha)=0$;
- если $x_{i,j}(\alpha)=0$, то единица в столбце $j$ стоит
  в некоторой строке $i'\ne i$, значит $X_{i,j}(\alpha)=1$
  и также $(\neg x_{i,j})(\alpha)=1$.

Итак, на критических присваиваниях $\neg x_{i,j}$ эквивалентно $X_{i,j}$,
а значит и любая клауза сохраняет значение при такой замене. $\square$

(Код‑проверка Леммы 15.4 на малых $n$ — в следующей ячейке.)

### 15.5. «Широкая клауза» в положительной версии (полное доказательство)

Зафиксируем $\mathrm{PHP}^{n}_{n+1}$ и критические присваивания из раздел 15.4.

**Определение.** $\mathrm{Pigeon}(C)$ — индексы $i$, для которых существует
$i$‑критическое $\alpha$ с $C(\alpha)=0$; $\mu(C):=|\mathrm{Pigeon}(C)|$.

**Лемма 15.5 (wide clause).** Для любой резолюционной рефутации $\mathrm{PHP}^{n}_{n+1}$ существует клауза $C$ из вывода такая, что
$$\mathrm{width}(C^+)\ \ge\ \frac{2(n+1)^2}{9}\ =\ \Omega(n^2).$$

*Доказательство.*

1) Для каждого $i$ клауза $P_i:=(x_{i,1}\lor\cdots\lor x_{i,n})$ имеет $\mu(P_i)=1$: она ложна ровно на $i$‑критических.

2) Для пустой клаузы $\emptyset$ имеем $\mu(\emptyset)=n+1$, так как $\emptyset(\alpha)=0$ на любом присваивании.

3) Если $C$ — резольвента $A,B$, то $\mu(C)\le\mu(A)+\mu(B)$:
на критическом $\alpha$ с $C(\alpha)=0$ ложна $A$ или $B$,
значит индекс учтён в $\mathrm{Pigeon}(A)$ или $\mathrm{Pigeon}(B)$.

Возьмём первую в выводе клаузу $C$ с $\mu(C)>(n+1)/3$.
Она существует, так как $\mu(P_i)=1$ и $\mu(\emptyset)=n+1$.
По (3) такая $C$ удовлетворяет $\mu(C)\le 2(n+1)/3$.

Положим $s:=\mu(C)$, так что $(n+1)/3 < s\le 2(n+1)/3$.

Теперь покажем, что $\mathrm{width}(C^+)\ge s((n+1)-s)$. Возьмём $i\in\mathrm{Pigeon}(C)$ и $i$‑критическое $\alpha$ с $C(\alpha)=0$.
Для любого $j\notin\mathrm{Pigeon}(C)$ строим $j$‑критическое $\alpha'$ перестановкой строк $i$ и $j$ (голубь $i$ садится в норку $j$).

Так как $j\notin\mathrm{Pigeon}(C)$, имеем $C(\alpha')=1$. По Лемме 15.4 получаем $C^+(\alpha)=0$ и $C^+(\alpha')=1$.

Клауза $C^+$ положительна. Переход $\alpha\to\alpha'$ меняет единственный $x_{i,k}$ (норка $j$), значит $x_{i,k}$ входит в $C^+$.

Для фиксированного $i$ разные $j$ дают разные $k$, значит из строки $i$ получаем $\ge(n+1)-s$ литералов в $C^+$.
Суммируя по всем $i\in\mathrm{Pigeon}(C)$, имеем $\mathrm{width}(C^+)\ge s((n+1)-s)$.

Так как функция $s((n+1)-s)$ на интервале $(n+1)/3 < s\le 2(n+1)/3$ минимальна на концах, имеем $s((n+1)-s)\ge 2(n+1)^2/9$. $\square$

### 15.6. Ограничения $\Rightarrow$ экспонента (полное доказательство)

Пусть $R$ — резолюционная рефутация $\mathrm{PHP}^{n}_{n+1}$.
Положим $m:=n+1$ (число голубей) и $N:=n(n+1)=m(m-1)$
(число переменных $x_{i,j}$).

Зафиксируем $\varepsilon\in(0,1)$ и назовём клаузу $C\in R$
*$\varepsilon$‑широкой*, если $\mathrm{width}(C^+)\ge \varepsilon N$.
Пусть $S$ — число таких клауз.

**Лемма 15.6.1.** Существует переменная $x_{i,j}$, которая входит
хотя бы в $\varepsilon S$ $\varepsilon$‑широких клауз
(в их положительных версиях).

*Доказательство.* Каждая $\varepsilon$‑широкая клауза содержит
$\ge \varepsilon N$ литералов, значит всего $\ge \varepsilon N\cdot S$ вхождений.
По Дирихле найдётся переменная, входящая хотя бы в
$(\varepsilon N\cdot S)/N=\varepsilon S$ таких клауз. $\square$
По Дирихле найдётся переменная, входящая хотя бы в $(\varepsilon N\cdot S)/N=\varepsilon S$ таких клауз. $\square$

Выберем такую переменную $x_{i,j}$ и рассмотрим ограничение $\rho$,
которое «сажает» голубя $i$ в норку $j$:
$$x_{i,j}=1,\quad x_{i',j}=0\ (i'\ne i),\quad x_{i,j'}=0\ (j'\ne j).$$
После этого ограничения исходная CNF естественно превращается
в $\mathrm{PHP}^{n-1}_{n}$ (убираем строку $i$ и столбец $j$).

**Лемма 15.6.2.** Если применить $\rho$ ко всем клаузам вывода $R$
(удаляя истинные клаузы и ложные литералы), получится рефутация
$\mathrm{PHP}^{n-1}_{n}$.

*Доказательство.* Ограничение — это подстановка и упрощение.
Резолюция замкнута: если $C$ — резольвента $A,B$, то
$C\upharpoonright\rho$ — резольвента $A\upharpoonright\rho,B\upharpoonright\rho$
или следует тривиально.
Пустая клауза сохраняется, значит образ — корректный вывод. $\square$

**Лемма 15.6.3.** После применения $\rho$ число $\varepsilon$‑широких клауз в $R$ уменьшается как минимум в $(1-\varepsilon)$ раз.

*Доказательство.* Все $\varepsilon S$ широких клауз с $x_{i,j}$
становятся истинными и исчезают. Остальные лишь теряют литералы,
новые $\varepsilon$‑широкие не появляются. $\square$

После одного шага: рефутация $\mathrm{PHP}^{n-1}_{n}$, число широких клауз
$\le (1-\varepsilon)S$.
После $k$ шагов: рефутация $\mathrm{PHP}^{n-k}_{n+1-k}$,
число широких клауз $\le S(1-\varepsilon)^k$.

Выберем $k:=\left\lceil\frac{\ln S}{\varepsilon}\right\rceil+1$.
Так как $1-\varepsilon\le e^{-\varepsilon}$,
$$S(1-\varepsilon)^k\le S e^{-\varepsilon k}<1.$$ 
Значит после $k$ шагов нет $\varepsilon$‑широких клауз: для любой $D$
получаем $\mathrm{width}(D^+)<\varepsilon N\le \varepsilon m^2$.

С другой стороны, применим Лемму 15.5 к $\mathrm{PHP}^{n-k}_{n+1-k}$: существует клауза $D$, такая что
$$\mathrm{width}(D^+)\ge \frac{2(n+1-k)^2}{9} = \frac{2(m-k)^2}{9}.$$ 
Значит обязательно
$$\frac{2(m-k)^2}{9}<\varepsilon m^2,$$
то есть $m-k<\frac{3}{\sqrt2}\sqrt\varepsilon\,m$ и
$$k>\Bigl(1-\tfrac{3}{\sqrt2}\sqrt\varepsilon\Bigr)m.$$ 

Но по определению $k\le \frac{\ln S}{\varepsilon}+2$, поэтому
$$\ln S\ \ge\ \varepsilon\Bigl(1-\tfrac{3}{\sqrt2}\sqrt\varepsilon\Bigr)m\ -\ 2\varepsilon.$$
Берём $\varepsilon=1/100$, тогда $\ln S=\Omega(m)=\Omega(n)$,
то есть $S\ge 2^{\Omega(n)}$. Так как $S\le |R|$, это экспоненциальная
нижняя оценка. Теорема 15.2 доказана. $\square$

### 15.7. За пределами резолюции: что известно и что открыто

Резолюция — слабая система. Эти нижние оценки не приближают $\mathrm{NP}$ vs $\mathrm{coNP}$.
Нужны оценки для **существенно более сильных** proof systems (Cook–Reckhow).

**Определение (p-bounded).** Proof system $P$ — p-bounded, если для любой
тавтологии $\varphi$ существует $P$-доказательство размера
$\mathrm{poly}(|\varphi|)$.

**Определение (p-симуляция).** $P$ p-симулирует $Q$, если полиномиальная
функция переводит $Q$‑доказательство $\pi$ в $P$‑доказательство той же
тавтологии.
Размер — $\mathrm{poly}(|\pi|)$.

**Определение (p-оптимальная система).** $P$ p-оптимальна, если
p-симулирует все системы. Вопрос о существовании открыт.

Карта систем и обзор нижних оценок: Urquhart 1996
(`../resources/downloads/urquhart_1996_complexity_of_propositional_proofs.pdf`).

**Следствие (ориентир).** Если p-оптимальная система существует и для неё
доказаны суперполиномиальные нижние оценки, то $\mathrm{NP}\ne\mathrm{coNP}$
(а значит $\mathrm{P}\ne\mathrm{NP}$).

**Контраст на примере PHP.**
- *(Frege легко)* Полиномиальные доказательства $\mathrm{PHP}$: Buss (1987), `../resources/downloads/buss_1987_php_frege.pdf`.
- *(bounded‑depth Frege трудно)* Экспоненциальные нижние оценки для $\mathrm{PHP}$:
  Beame et al. (1992), `../resources/downloads/beame_et_al_1992_php_bounded_depth_frege.pdf`.
- *(Cutting Planes легко)* Полиномиальные опровержения $\neg\mathrm{PHP}$:
  Buss–Clote (2002), `../resources/downloads/buss_cutting_planes_notes.pdf`.

**Открытая цель линии proof complexity.** Суперполиномиальные нижние оценки для сильных систем на явных тавтологиях.
Если для p‑оптимальной (если есть) или для всех, то $\mathrm{NP}\ne\mathrm{coNP}$
(и $\mathrm{P}\ne\mathrm{NP}$), но одной EF недостаточно.
Условная связка: Pich–Santhanam (2023) дают $\mathrm{P}\ne\mathrm{NP}$
из EF‑нижних оценок при допущениях: $\mathrm{S}^1_2$‑формализуемые редукции
и средняя сложность.
Thm 1, 7–9: `../resources/downloads/pich_santhanam_2023_ef_lower_bounds.pdf`.

**Определение (Pich–Santhanam, введение).** Для $k\ge 1$ и p‑time функции $f$
вводится формула‑шаблон
$$w_{n,k}(f) := [\mathrm{SAT}_n(x,y)\to \mathrm{SAT}_n(x,C(x))]\ \lor
[\mathrm{SAT}_n(f_1(C),f_2(C))\wedge \neg\mathrm{SAT}_n(f_1(C),C(f_1(C)))].$$
Здесь $C$ — код схемы размера $n^k$; $\mathrm{SAT}_n(x,y)$: $y$ удовлетворяет
формулу $x$ размера $n$; $f(C)=\langle f_1(C),f_2(C)\rangle$.
Интуиция: $w_{n,k}(f)$ — тавтология $\iff$ $f$ **свидетельствует ошибку**
любой схемы $C$, не решающей search‑SAT на длине $n$.
**Определение (Pich–Santhanam, введение/Sec. 2.2).** $W_{n,k}(f)$:
«естественная» $\forall\Pi^b_1$‑формулировка $\exists n_0\,\forall n>n_0$
формулы $w_{n,k}(f)$ — тавтологии.

**Определение (S$^1_2$).** $\mathrm{S}^1_2$ — теория Бусса ограниченной
арифметики в $L_{BA}$; ограниченные кванторы и $\Sigma^b_1$‑индукция по $|x|$.
Используется для формализации p‑time рассуждений (Buss 1995; Krajíček 1995; Cook–Nguyen 2010).

**Напоминание (ограниченные кванторы).** В $L_{BA}$: $\forall x\le t$, $\exists x\le t$
(аббревиатуры $\forall x(x\le t\to\varphi)$, $\exists x(x\le t\wedge\varphi)$).
$|x|$ — длина двоичной записи.
(Buss 1995; Krajíček 1995; Cook–Nguyen 2010).

**Напоминание ($\Sigma^b_1$‑формулы).** Ведущий блок ограниченных существований
(напр., $\exists y\le t(x)\,\psi$), матрица $\psi$ — bounded ($\Delta^b_0$).
(Buss 1995; Krajíček 1995; Cook–Nguyen 2010).

**Лемма-мост (S$^1_2$ → EF; цитируется).** Если $\Pi^b_1$‑формула $\varphi$
доказуема в $\mathrm{S}^1_2$, то переводы $\lVert\varphi\rVert_n$ имеют
полиномиальные EF‑доказательства.
(Pich–Santhanam, Sec. 2.2; Buss 1995; Krajíček 1995; Cook–Nguyen 2010.)

**Теорема (Pich–Santhanam, Theorem 1; цитируется).** Существует универсальная константа $\varepsilon>0$ такая, что для любого $k\ge 1$:
- если $w_{n,k}(f)$ — тавтологии для всех больших $n$ и система
  $\mathrm{EF}+w_k(f)$ не полиномиально ограничена, то
  $\mathrm{SAT}\notin\mathrm{SIZE}(n^{\varepsilon k})$ бесконечно часто;
- если $\mathrm{S}^1_2\vdash W_{n,k}(f)$ и EF не полиномиально ограничена, то то же заключение.

**Ориентир (Pich–Santhanam, Abstract).** При двух предпосылках
о доказуемости в $\mathrm{S}^1_2$ (hardness в $\mathrm{E}$
и «learning from $\neg\exists$OWF»)
и при явном семействе функций, для которого EF *не* имеет полиномиальных
доказательств корректных схем‑нижних оценок, следует $\mathrm{P}\ne\mathrm{NP}$.
В формулировке аннотации (кратко):
Пусть далее $t(n):=1/2-1/2^{n/4}$.
1) (I) $\mathrm{S}^1_2$ доказывает для явной $h_0\in\mathrm{E}$:
   $tt(h_{0,n},2^{n/4},t(n))$ — тавтологии при больших $n$
   (hardness аппроксимации; Thm 8/9).
   *(Формализация $h_0\in\mathrm{E}$):* $h_0$ вычислима за $2^{O(n)}$ (bounded‑проверка машины в $\mathrm{S}^1_2$).
2) (II) $\mathrm{S}^1_2\vdash \forall n\,\forall C\,\exists y\le\mathrm{poly}(n)$
   $\mathrm{RedCorr}(n,C,y)$ для редукции «$\neg\exists$OWF → learning» (Thm 9).
   $\mathrm{RedCorr}(n,C,y)$: «$y$ — корректный выход на $(n,C)$ и ошибка $< t(n)$» (bounded‑формулировка).
3) (IIa) «$\neg\exists$OWF»: для любого p-time $f$ существует p-time инвертор
   $A$ и полином $p$ с $\Pr[A(f(x))=x]\ge 1/p(n)$ бесконечно часто.
Кодируется в $\mathrm{S}^1_2$ через bounded‑кванторы (Cook–Nguyen 2010, гл. 11).

Чек‑лист — в «Открытые шаги» ниже.
См. также (альтернативная ветка): алгебраические proof systems (IPS)
и связь с PIT/VP vs VNP (Grochow–Pitassi 2014;
`../resources/downloads/grochow_pitassi_2014_pit.pdf`).
Краткая карта VP/VNP+IPS: раздел 8, пункт 4 (IPS — алгебраический и не эквивалентен EF).
Суперполиномиальные нижние оценки IPS ⇒ VP≠VNP; обзор/техники:
Forbes–Shpilka–Tzameret–Wigderson 2021
(`../resources/downloads/forbes_shpilka_tzameret_wigderson_2021_ips.pdf`).

**Санити‑чек (слишком сильная канонизация ⇒ коллапс).** Зафиксируем поле $\mathbb F_p$.
Для литерала положим $\llbracket x_i\rrbracket:=x_i$, $\llbracket\neg x_i\rrbracket:=1-x_i$.
Для клаузы $C=(\ell_1\lor\cdots\lor\ell_k)$ положим $S_C(x):=1-\prod_{t=1}^k(1-\llbracket\ell_t\rrbracket)$, а для CNF $\varphi=\bigwedge_j C_j$ — $P_\varphi(x):=\prod_j S_{C_j}(x)$.
Обозначим $\mathrm{ML}(P)$ редукцию $P\bmod(x_1^2-x_1,\dots,x_n^2-x_n)$ (единственный multilinear‑полином, совпадающий с $P$ на $\{0,1\}^n$).
Тогда $\varphi$ невыполнима $\iff \mathrm{ML}(P_\varphi)\equiv 0$ (на кубе $P_\varphi$ — индикатор, а для multilinear ноль на $\{0,1\}^n$ означает ноль как полином).
Следовательно, если существует p‑time алгоритм $\mathcal A$, который по $\varphi$ строит ROABP полиномиального размера для $\mathrm{ML}(P_\varphi)$, то $\mathrm{UNSAT}\in\mathrm{P}$ через детерминированный PIT для ROABP, а значит $\mathrm{P}=\mathrm{NP}$.
Ссылка на PIT: Raz–Shpilka (2005), `../resources/downloads/raz_shpilka_2005_pit_noncommutative.pdf` (детерминированный PIT для ABP в noncommutative модели; ROABP — частный случай).

**Определение (IPS, грубо).** IPS (Ideal Proof System) опровергает невыполнимую CNF как алгебраический сертификат.
После перевода клауз в многочлены $f_i$ над полем даётся схема,
вычисляющая $g_i$ с $\sum_i g_i f_i = 1$; это и есть опровержение
(Grochow–Pitassi 2014).
Полнота IPS следует из Nullstellensatz (`../resources/downloads/allcock_nullstellensatz_2005.pdf`).
Контраст: EF‑нижние оценки ⇒ $\mathrm{NP}\ne\mathrm{coNP}$, IPS‑нижние оценки ⇒ $\mathrm{VP}\ne\mathrm{VNP}$.
Статус (IPS): общие суперполиномиальные нижние оценки остаются открыты;
известны результаты лишь для ограниченных подсистем
(ссылки: Grochow–Pitassi 2014; FSTW 2021, Sec. 1.3).

**Определение (PIT-аксиомы; Grochow–Pitassi 2014, Def. 1.7).** Фиксируем стандартное кодирование constant-free алгебраических схем. Пусть $K=\{K_{m,n}\}$ — семейство булевых схем, решающих PIT для схем размера $m$ над $n$ переменными полиномиальной степени. PIT-аксиомы для $K$ (для всех кодов $[C],[G]$) таковы:
1) $K([C(x)])\to K([C(p)])$ (нулевой полином равен нулю на всех булевых входах).
2) $K([C(x)])\to \neg K([1-C(x)])$ (если $C\equiv 0$, то $1-C\not\equiv 0$).
3) $K([G(x)])\wedge K([C(x,0)])\to K([C(x,G(x))])$ (подстановка нулевого полинома).
4) $K([C(x)])\to K([C(\pi(x))])$ (перестановка переменных).

**Лемма 15.7.3 (PIT-аксиомы ⇒ EF p-симулирует IPS).** Если существует семейство $K$ полиномиального размера, вычисляющее PIT для constant-free схем полиномиальной степени, и EF имеет полиномиальные доказательства PIT-аксиом для $K$, то EF p-симулирует (и фактически p-эквивалентна) VP-IPS (Grochow–Pitassi 2014, Thm. 4.1). Здесь класс PIT-схем включает IPS-сертификаты (полиномиальный размер и степень).

*Доказательство (эскиз).* IPS-опровержение задано схемой $C(x,y)$ с тождествами
$C(x,0)\equiv 0$ и $C(x,f(x))\equiv 1$ (то есть $1-C(x,f(x))\equiv 0$). PIT-аксиомы
дают EF возможность доказывать эти тождества и их следствия на булевом кубе:
из $K([C(x,0)])$ по (1) получаем $C(a,0)=0$ для любого булевого $a$, а из
$K([1-C(x,f(x))])$ по (1) получаем $C(a,f(a))=1$. Если $a$ удовлетворяет всем
клаузам, то $f(a)=0$ и по (3) $C(a,f(a))=C(a,0)=0$, противоречие. Формализуя
SoundnessIPS, EF получает p-симуляцию IPS. $\square$

**Лемма 15.7.3a (SoundnessIPS; Grochow–Pitassi 2014, Sec. 4.1).** Пусть $\varphi=\kappa_1\wedge\cdots\wedge\kappa_m$ — 3-CNF над $p_1,\dots,p_n$, а $Q_i^\varphi(x)$ — клаузные полиномы степени $\le 3$ (и добавлены уравнения $x_i^2-x_i=0$). IPS-опровержение — схема $C(x,y)$ с $C(x,0)\equiv 0$ и $C(x,Q^\varphi(x))\equiv 1$. Определим
$$\mathrm{ProofIPS}([C],[\varphi])\ :=\ K([C(x,0)])\ \wedge\ K([1-C(x,Q^\varphi(x))]),$$
а
$$\mathrm{SoundnessIPS}_{m,n}([C],[\varphi],p)\ :=\ \mathrm{ProofIPS}([C],[\varphi])\ \to\ \neg\mathrm{Truthbool}([\varphi],p).$$
Если EF имеет полиномиальные доказательства PIT-аксиом для $K$, то EF имеет полиномиальные доказательства $\mathrm{SoundnessIPS}$ (Lemma 4.4).

*Доказательство (эскиз).* Из $\mathrm{Truthbool}([\varphi],p)$ выводим $K([Q_i^\varphi(p)])$ для всех $i$ (клаузный полином обнуляется на истинной клаузе). Далее аксиомами (1),(3),(4) переносим подстановки $p$ и $Q_i^\varphi$ внутрь $C$, получая $K([C(p,Q^\varphi(p))])$, а из $K([C(x,0)])$ — $K([C(p,0)])$. Тогда $K([1-C(x,Q^\varphi(x))])$ по (1) даёт $K([1-C(p,Q^\varphi(p))])$, и аксиома (2) даёт противоречие. Схема $C$ имеет полиномиальный размер и степень (VP-IPS), а подстановка $Q_i^\varphi$ сохраняет полиномиальную степень, поэтому $K$ применим. $\square$

**Лемма 15.7.3b (константы и степень; Grochow–Pitassi 2014, Sec. 1.2.1).** PIT-аксиомы формулируются для constant-free алгебраических схем. Это несущественно:
в фиксированном конечном поле $\mathbb F_q$ constant-free эквивалентно общему случаю (констант конечное число); над $\mathbb Z$ или $\overline{\mathbb F_p}$ константы полиномиального бит-размера строятся constant-free схемой через двоичное разложение. Поэтому VP с полиномиальным total bit-size констант совпадает с constant-free вариантом. В IPS используется VP-IPS: полиномиальный размер и полиномиальная степень. Для 3-CNF полиномы $Q_i^\varphi$ имеют степень $\le 3$, а подстановка $Q^\varphi$ в $C$ сохраняет полиномиальную степень, значит PIT-схема $K$ должна работать на схемах полиномиальной степени.

**Лемма 15.7.3c (3-CNF без потери общности).** Стандартная редукция переводит CNF в эквисатисфакционную 3-CNF с линейным ростом: клаузы длины $\le 3$ оставляем, а клаузу длины $k>3$ заменяем цепочкой 3-клауз с новыми переменными $(\ell_1\lor\ell_2\lor y_1)\wedge(\neg y_1\lor\ell_3\lor y_2)\wedge\cdots\wedge(\neg y_{k-3}\lor\ell_{k-1}\lor\ell_k)$. Для клаузы длины $k>3$ получаем $k-2$ новых клауз и $k-3$ новых переменных; если $\varphi$ имеет $L$ литералов, то $r(\varphi)$ имеет $\le L$ клауз и $\le 3L$ литералов (см. §16.78). Тогда $\varphi$ удовлетворима $\iff r(\varphi)$ удовлетворима, и EF доказывает $\neg r(\varphi)\to \neg\varphi$ через явный выбор новых переменных (см. Лемму 15.7.3d). Поэтому SoundnessIPS, сформулированная для 3-CNF, достаточно сильна для общего случая: можно предварительно заменить $\varphi$ на $r(\varphi)$ в определении $\mathrm{ProofIPS}$.

**Лемма 15.7.3d (equisatisfiable достаточно; явный выбор $g$).** В редукции CNF→3-CNF формулы $\varphi$ и $r(\varphi)$ лишь equisatisfiable (не логически эквивалентны по одним и тем же переменным), но для SoundnessIPS достаточно эквисатисфакции: из неразрешимости $r(\varphi)$ следует неразрешимость $\varphi$. Более того, существует явная полиномиальная функция $g$ (по значениям исходных переменных), задающая значения новых $y_i$ так, что EF доказывает
$$\mathrm{Truthbool}([\varphi],p)\ \to\ \mathrm{Truthbool}([r(\varphi)],p,g(p)).$$
Для цепочки, полученной из $(\ell_1\lor\cdots\lor\ell_k)$, можно взять
$$y_i\ :=\ \neg(\ell_1\lor\cdots\lor\ell_{i+1})\quad (i=1,\dots,k-3),$$
что удовлетворяет всем новым клаузам при любом истинном значении исходной клаузы. Отсюда
$$\neg\mathrm{Truthbool}([r(\varphi)],p,g(p))\to\neg\mathrm{Truthbool}([\varphi],p),$$
и потому в SoundnessIPS достаточно equisatisfiable редукции.

**Барьер-чек (для 15.7.3–15.7.3d).**
- Relativization: шаг опирается на корректность детерминированного PIT; но есть оракулы с $\mathrm{BPP}^A\ne\mathrm{P}^A$, поэтому такой вывод не может быть чисто релятивизирующим.
- Natural proofs: вывод PIT через схемные нижние оценки ожидаемо попадает под барьер Разборова–Рудича при наличии PRF.
- Algebrization: стандартная hard\-vs\-randomness дерэндомизация PIT считается неалгебраизирующей; алгебраизирующих доказательств не известно.

**Лемма 15.7.4 (слабый ROABP-барьер для CNF-класса).** Пусть $P_\varphi$ - полином из санити-чека выше, вычисляемый depth-3 формулой размера $\mathrm{poly}(|\varphi|)$ (произведение клаузных полиномов $S_C$). Если существует p-time алгоритм $\mathcal A$, который по CNF $\varphi$ строит ROABP размера $\mathrm{poly}(|\varphi|)$ для $\mathrm{ML}(P_\varphi)$, то $\mathrm{UNSAT}\in\mathrm{P}$, а значит $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Вычислим $R:=\mathcal A(\varphi)$ и применим детерминированный PIT для ROABP. По санити-чеку $\varphi$ невыполнима $\iff \mathrm{ML}(P_\varphi)\equiv 0$, поэтому PIT решает UNSAT за полиномиальное время. $\square$

**Замечание.** Класс $P_\varphi$ - это стандартное алгебраическое кодирование CNF (клаузные полиномы), используемое в IPS/EF; барьер действует уже на таком минимальном входе.

**Лемма 15.7.4a (достаточность 3-CNF).** Если существует p-time алгоритм $\mathcal A$, который для любой 3-CNF $\varphi$ строит ROABP размера $\mathrm{poly}(|\varphi|)$ для $\mathrm{ML}(P_\varphi)$, то $\mathrm{3\text{-}UNSAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Для 3-CNF $\varphi$ вычислим $R:=\mathcal A(\varphi)$ и применим детерминированный PIT для ROABP. По санити-чеку $\varphi$ невыполнима $\iff \mathrm{ML}(P_\varphi)\equiv 0$, значит $\mathrm{3\text{-}UNSAT}\in\mathrm{P}$. Так как $\mathrm{3\text{-}UNSAT}$ coNP-полна и $\mathrm{P}$ замкнут по дополнению, получаем $\mathrm{P}=\mathrm{NP}$. $\square$

**Лемма 15.7.4b (NP-полные подклассы CNF).** Пусть $\mathcal C$ — подкласс CNF, для которого существует p-time редукция $r$ из 3-CNF в $\mathcal C$, сохраняющая (не)выполнимость и удовлетворяющая $|r(\varphi)|\le\mathrm{poly}(|\varphi|)$. Если существует p-time алгоритм $\mathcal A$, который по $\psi\in\mathcal C$ строит ROABP размера $\mathrm{poly}(|\psi|)$ для $\mathrm{ML}(P_\psi)$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Для произвольной 3-CNF $\varphi$ построим $\psi=r(\varphi)$ и применим $\mathcal A$ к $\psi$, затем PIT для ROABP. По санити-чеку $\psi$ невыполнима $\iff \mathrm{ML}(P_\psi)\equiv 0$, а по корректности $r$ это эквивалентно невыполнимости $\varphi$. Значит $\mathrm{3\text{-}UNSAT}\in\mathrm{P}$, то есть $\mathrm{P}=\mathrm{NP}$. Полиномиальный рост $|r(\varphi)|$ не меняет требования $\mathrm{poly}(|\psi|)=\mathrm{poly}(|\varphi|)$. $\square$

**Лемма 15.7.4c (учёт blow-up).** Пусть редукция $r$ удовлетворяет $|r(\varphi)|\le |\varphi|^c$ и алгоритм $\mathcal A$ строит ROABP размера $\le |\psi|^d$ для входа $\psi$. Тогда композиция даёт ROABP размера $\le |\varphi|^{cd}$ для исходной 3-CNF. Следовательно, любой полиномиальный blow-up редукции лишь меняет константу в степени и не влияет на вывод $\mathrm{P}=\mathrm{NP}$ в Лемме 15.7.4b.

**Лемма 15.7.4d (конкретные NP-полные подклассы).** Планарный 3-SAT NP-полон (Lichtenstein 1982, `../resources/downloads/lichtenstein_1982_planar_formulae.pdf`); в его редукции размер растёт не более квадратично: $|r(\varphi)|=O(|\varphi|^2)$ (см. §16.83). Более того, Planar‑3‑SAT(≤4‑occ) NP‑полон (композиция Лихтенштейна и §16.84). Кроме того, 3-SAT с ограничением «каждая переменная встречается не более 4 раз» NP-полон: NP‑трудность следует из явной линейной редукции 3‑SAT → 3‑SAT(≤4‑occ) в §16.81–16.82, а принадлежность NP тривиальна. Поэтому для этих подклассов $\mathcal C$ выполняется предпосылка Леммы 15.7.4b (p-time редукция из 3-CNF с полиномиальным blow-up).

**Контрпример (монотонные CNF).** Ограничение на монотонные клаузы слишком сильное: любая монотонная CNF без пустой клаузы удовлетворима (присваивание всех переменных 1), поэтому даже идеальная канонизация на этом классе не даёт NP-трудности.

**Барьер-чек (для 15.7.4–15.7.4d).**
- Relativization: если $\mathcal A$ релятивизируется, то для любого оракула $A$ получаем $\mathrm{P}^A=\mathrm{NP}^A$, что противоречит BGS.
- Natural proofs: построение такой $\mathcal A$ через конструктивные/крупные свойства попадает под барьер Разборова-Рудича при наличии PRF.
- Algebrization: коллапс $\mathrm{P}=\mathrm{NP}$ не алгебраизует, значит доказательство существования $\mathcal A$ не может быть чисто алгебраизирующим.

**Скелет доказательства (для шага 2).** См. также скелет L2/RedCorr выше.
Параметры: фиксируем константы $a,t$ (из Theorem 9), рассматриваем $n$ достаточно большие.
Формализация в $\mathrm{S}^1_2$: определения $\mathrm{Enc}$, $\mathrm{Len}$
и редукции $R$ должны быть bounded (лемма-мост EF$\leftrightarrow\mathrm{S}^1_2$).
Указание: формула для $\mathrm{Enc}$ квантифицирует индексы строк $i\le |\pi|$ и проверяет локальные правила вывода и аксиомы.
Аналогично, $\mathrm{Len}$ задаётся через предикат длины кода, а редукция $R$
задаётся p-time вычислимой функцией (Sec. 2.2 в Pich–Santhanam).
Итог: L2/L3 остаются открытыми; именно они требуют нетривиальной EF-нижней оценки.
Кандидаты: PHP, Tseitin (XOR‑паритеты на рёбрах), Clique-Coloring.
Ссылки: Beame–Sabharwal 2000, `../resources/downloads/beame_sabharwal_2000_proof_complexity.pdf`.
Buss 1997, `../resources/downloads/buss_1997_proof_complexity_intro.pdf`.
Hrubeš 2013, `../resources/downloads/hrubes_2013_interpolation_technique.pdf`.
Feasible interpolation: короткие доказательства clique-coloring ⇒ малые
монотонные схемы (Tabatabai 2025, `../resources/downloads/tabatabai_2025_feasible_interpolation.pdf`).
Монотонные нижние оценки для CLIQUE: Razborov 1985, `../resources/downloads/razborov_1985_monotone.pdf`.
Схема: малые доказательства + (монотонная) интерполяция ⇒ малые монотонные схемы;
контрапозиция + Razborov ⇒ нижние оценки на доказательства.
Другие кандидаты: случайные $k$‑CNF; CNF «NP не имеет малых схем» (Razborov 2023).
Для Tseitin на экспандерах известны экспоненциальные нижние оценки в резолюции через ширину/экспансию; Itsykson–Oparin 2013.
Формально: при $\deg(G)\le k$ имеем $W\ge e(G)-1$ и $S\ge 2^{(e(G)-k-1)^2/|E|}$, значит на bounded‑degree экспандерах $S=2^{\Omega(|V|)}$; см. §16.85–16.86.
С явной expander‑семьёй это даёт явное bounded‑occ семейство 3‑CNF (см. §16.87).
Для Tseitin(Grid$_{n,n}$) (где число переменных $N=\Theta(n^2)$) в bounded‑depth Frege известны лишь разнесённые границы для polynomial‑size:
depth $=\Omega(\log_2 N/\log_2\log_2 N)$ (Håstad’20, Cor. 6.6) и depth $=O(\log_2 N)$ (upper из GIRS’19; см. §16.92+§16.115+§16.116+§16.120).
**Q39 (frontier как неориентированный срез).**
В `formal/WIP/Work.lean` введён `frontier` как объединение ориентированных границ.
Для симметрических графов доказана инвариантность `frontier` при замене $S$ на $\\neg S$.
Это позволяет рассматривать фронтиры в двухполосном шаге без ориентационной двусмысленности.
Лемма: `Q39_frontier_compl` (см. `formal/WIP/Work.lean`).
**Q39 (frontier → adjacency).**
Для симметрических графов доказано, что любое `frontier`-ребро действительно
является ребром графа (в неориентированном смысле).
Это снимает техническую разницу между ориентацией в `boundary` и ребром разреза
при переходе к ранговым/интервальным оценкам.
Лемма: `Q39_frontier_adj` (см. `formal/WIP/Work.lean`).
**Q39 (two‑strip toy rank).**
Toy при $n=4$: даже если каждый внутренний узел имеет
$|S_j\\cap\\delta(U)|\\le 2$ и $|S_{j+1}\\cap\\delta(U)|\\le 2$, проекционный ранг на два блока
остаётся равным 2 (верхняя/нижняя половины полос дают независимые проекции).
См. `formal/Notes/TseitinQ39.lean` §16.167 (Q39.S23-2k-two-strip-rank-toy).
**Q43 (flat local‑EF(s), параметр‑сводка).**
При явном $A\le 668$ из HR’22 получаем $n_0(A)=2$, поэтому в HR‑режиме
условие $n\ge n_0(A)$ избыточно по сравнению с $n\ge 20 C n' \log_2 n'$
(при $C\ge 3$ и $t\le s\le n'/32$). Итоговая сводка оставляет
единственный $n$‑барьер $n \ge 20 C n' \log_2 n'$ и прочие предпосылки без изменений.
См. `formal/Notes/TseitinLocalEF.lean` §16.275 (Q43.S132-update-summary-dominant-bound).
**Q43 (compatibility после $t\mapsto(2s+1)t$).**
Для $M=\mathrm{poly}(n)$ и $s=\mathrm{polylog}(n)$ имеем $t'=(2s+1)\log_2 M=(\log_2 n)^{O(1)}$,
а рекурсия HR даёт $n_\eta \ge n/\mathrm{polylog}(n)^\eta$ при $\eta\le d=O(\log_2 n/\log_2\log_2 n)$.
Это обеспечивает совместимость условий $t'(d)\le n_d/16$ и $t'\le s_\eta\le n'/32$
при достаточно большом $n$; возможна замена $s_1=\log_2 N$ на $s_1=\max\{\log_2 N,t'\}$ без изменения
asymptotics (см. §16.276, Q43.S133-hr-compatibility-check).
**Q43 (axiom-size bound).**
Если в flat local-EF(s) размер доказательства $S$ измеряется размером строк и
extension-аксиомы $p_i\leftrightarrow\varphi_i(X)$ входят как строки, то $|\varphi_i|\le S$.
Тогда для любой строки $F$ размер развёртывания $M(F)\le |F|+|F|\cdot\max_i|\varphi_i|\le S+S^2$,
поэтому $t=\log_2 M(F)=O(\log_2 S)$, а при $S=\mathrm{poly}(n)$ получаем $t=O(\log_2 n)$.
Если аксиомы не учитываются в размере, можно взять $|\varphi_i|=2^{(\log_2 n)^2}$ при
$|\mathrm{supp}(\varphi_i)|\le s$, и тогда $t$ становится суперполиномиальным.
См. `formal/Notes/TseitinLocalEF.lean` §16.332 (Q43.S192-flat-eval-axiom-size-bound).
**Q43 (size metric formalized).**
В `formal/WIP/Work.lean` зафиксированы определения line-size/line-count/line-max
и лемма: если строка входит в proof, то ее размер не превышает суммарный размер proof.
Это дает формальное ядро для метрики $(N,M)$ и для контроля $M$ через суммарный размер.
См. `formal/WIP/Work.lean` (Q43_lineSize/Q43_proofSize/Q43_lineSize_le_proofSize).
**Q43 (t parameter formalized).**
В `formal/WIP/Work.lean` введен параметр $t:=\\log_2 M$ как `Nat.log2 M` и
доказана оценка $t\\le M$ (лемма `Q43_tParam_le`). Это фиксирует базовую
связь между line-size $M$ и глубиной evaluations в Q43.
См. `formal/WIP/Work.lean` (Q43_tParam/Q43_tParam_le).
**Q43 (t bounded by proof size).**
В `formal/WIP/Work.lean` доказано, что `lineMax` не превосходит суммарного
размера proof (`Q43_lineMax_le_proofSize`), а значит
$t=\\log_2(\\mathrm{lineMax})\\le\\mathrm{proofSize}$ через `Q43_tParam_le_proofSize`.
Это дает формальную связь между $t$ и общей метрикой размера.
См. `formal/WIP/Work.lean` (Q43_lineMax_le_proofSize/Q43_tParam_le_proofSize).
**Q43 (t <= log_2 S).**
В `formal/WIP/Work.lean` доказана монотонность $\\log_2$ на Nat и лемма
$t=\\log_2(\\mathrm{lineMax})\\le\\log_2(\\mathrm{proofSize})$.
Это формализует связь $t \\le \\log_2 S$ при $S=\\mathrm{proofSize}$ (логарифм базы 2).
См. `formal/WIP/Work.lean` (Q43_log2_mono/Q43_tParam_le_log2_proofSize).
**Q43 (swap $s_1$).**
Замена стартового $s_1=\log_2 N$ на $s_1=\max\{\log_2 N,t'\}$ не ломает HR‑проверки:
$s_\eta$ и $t(\eta)=\sum s_i+\log_2 M$ монотонно увеличиваются, а в режиме
$M=\mathrm{poly}(n)$, $s=\mathrm{polylog}(n)$ остаётся $t(\eta)\ll n_\eta$.
Это снимает формальный риск несогласованности условия $t'\le s_\eta$ и сохраняет
$s_\eta\le n'/32$ при больших $n$ (см. §16.277, Q43.S134-s1-swap-compatibility).
**Q43 (audit $s_1$).**
В Proof of Thm. 4.3 HR’22 $s_1=\log_2 N$ появляется только через
$s_\eta=2^{\eta-1}\log_2 N$ и $t(\eta)=\sum_{i\le\eta}s_i+\log_2 M$; в Lemma 4.5
используются лишь суммы $\sum s_i$ и условие $t(\eta)\le n_\eta/16$.
Прямые вхождения $\log_2 N$ в Proof of Thm. 4.3/Lemma 4.5 идут только через
$s_\eta/t(\eta)$ и bound $t(d)\le 2^d\log_2 N+\log_2 M$, так что замена $s_1$
влияет лишь через $s_\eta/t(\eta)$ (см. §16.278–§16.279, Q43.S135–S136).
Оставшиеся $\log_2 N$ в §4 относятся к Proof of Thm. 4.1 (single‑switching):
там фиксируется $s=152\log_2 N$ и используется $t_d=152\log_2 N$, но это не входит
в Proof of Thm. 4.3/Lemma 4.5 (см. §16.280, Q43.S137-logn-remaining-scan).
**Q43 (явные $c_1,c_2$ в Thm. 4.1).**
Из §16.302–§16.303 и §16.215 берём $A_{\\mathrm{bits}}=76$, значит $A=2^{76}$
(для двоичного счёта; при переходе к $\\ln$ заменить на $e^{76\\ln 2}$).
Определяем $c_2:=8\\cdot 152\\cdot A$ и $c_1:=16\\cdot 152\\cdot c_2$ — этим
устраняются фразы “large/some constant” в Proof Thm. 4.1.
Рекурсия $n_i=\\lfloor n_{i-1}/(4A t\\log_2^4 n_{i-1})\\rfloor$ даёт
$n_d\\ge n/(\\log_2^{d-1} N\\cdot(c_2\\log_2^4 n)^d)$ при $t=152\\log_2 N$.
Условие $\\log_2 N\\le n^{1/d}/(c_1\\log_2^4 n)$ обеспечивает $t_d\\le n_d/16$,
и Proof Thm. 4.1 завершает переход к Lemma 2.13; см. §16.310 и
`formal/WIP/Work.lean`.
Кратко: Tseitin — паритеты на графе (нечетная сумма зарядов ⇒ невыполнимость);
нижние оценки через ограниченную степень и экспансию; Clique-Coloring —
несовместимость клики и раскраски.
Замечание: Tseitin часто изучают в алгебраических системах (PC/Nullstellensatz).
Beame–Sabharwal 2000; обзор: Pitassi–Tzameret 2016, `../resources/downloads/pitassi_tzameret_2016_algebraic_proof_complexity.pdf`.
Статус: для этих семейств EF-нижние оценки остаются открыты; «Открытые шаги» ниже.
Достаточно: сверхполиномиальная EF-нижняя оценка на таких $tt$-формулах уже даёт вывод (через Pich–Santhanam).
Точнее: для Theorem 9 требуется отсутствие доказательств длины $2^{a n}$
(экспоненциальная граница), а для Cor. 2 достаточно суперполиномиальной
неполиномиальности EF+$w$.
Речь о формулах вида $tt(g_n,n^t,t(n))$ (шаблон выше).
Здесь $t(n)=1/2-1/2^{n/4}$ по настройке из Pich–Santhanam.
Чем ближе $t(n)$ к $1/2$, тем сильнее требование средней-сложности (меньше допустимая корреляция).
Напоминание: $t(n)$ — порог ошибки в определении $tt(f_n,s,t)$ (доля входов, на которых схема ошибается).
- (L1) Лемма (кодирование EF). p-time $\mathrm{Enc}(n,\pi)$, $\mathrm{Len}(n,\pi)$.
  «есть EF-вывод $tt(g_n,n^t,t(n))$ длины $\le 2^{a n}$» $\Leftrightarrow$
  $\exists\pi\,\mathrm{Enc}(n,\pi)\wedge(\mathrm{Len}(n,\pi)\le 2^{a n})$.
  $\mathrm{Enc}$ проверяет локальные правила/аксиомы и последнюю строку (Cook–Reckhow).
- (L2) Лемма (короткий EF $\Rightarrow$ аппроксимация). p-time редукция $R$
  по коду $\pi$ строит схему $C$ размера $n^t$ с ошибкой $< t(n)$ за
  $\mathrm{poly}(|\pi|,n)$.
  Формализуется в $\mathrm{S}^1_2$ и соответствует $\mathrm{RedCorr}$/learning. *(Открытый шаг.)*
  Скелет: $\mathrm{RedCorr}(n,C,y):=(y=R(n,C))\wedge \mathrm{Err}_{t(n)}(C,y)$.
  $\mathrm{Err}_{t(n)}$: $\exists S\le 2^n, |S|<t(n)2^n\wedge\forall x<2^n\ (x\notin S\to C(x)=g_n(x))$.
  Pich–Santhanam, Sec. 2.4/Thm 9; минимум (A)–(C) ниже.
- (L3) Лемма (противоречие). Если $g_n\in\mathrm{E}$ не аппроксимируется схемами размера $n^t$ с ошибкой $< t(n)$, то L2 противоречит этому.
**Формализационный минимум (кванторы).**
**Шаблон.** $tt(g_n,n^t,t(n))$: никакая схема размера $n^t$ не аппроксимирует $g_n$ (ошибка $\ge t(n)=1/2-1/2^{n/4}$).
Минимум: (A) $\mathrm{S}^1_2\vdash \exists n_0\,\forall n>n_0\ tt(h_{0,n},2^{n/4},t(n))$;
(B) $\mathrm{S}^1_2\vdash \forall n\,\forall C\,\exists y\le n^{O(1)}\ \mathrm{RedCorr}(n,C,y)$.
  (C) EF: $\exists a>0\,\forall n>n_0$ нет EF-вывода длины $\le 2^{a n}$
  для $tt(g_n,n^t,t(n))$. Thm 9 / Cor. 2 ⇒ схемные и равномерные нижние оценки.
**Определение (tt-формулы; Pich–Santhanam Sec. 2.4).** Пусть $f_n:\{0,1\}^n\to\{0,1\}$ задана таблицей истинности.
$tt(f_n,s)$: ни одна схема размера $s$ не вычисляет $f_n$ (нужны схемы $>s$).
$tt(f_n,s,t)$: все схемы размера $s$ ошибаются на доле входов $\ge t$; эти формулы — аксиомы EF+tt (см. шаблон $tt(g_n,n^t)$ выше).

**Определение (формальная $tt(f_n,s,t)$).** Зафиксируем кодирование схем размера $s$ битстроками $C$ длины $m(s)$ и формулу $\mathrm{Eval}(C,x)$ полиномиального размера, вычисляющую выход схемы $C$ на фиксированном $x$ (через переменные значений гейтов). Для каждого $x\in\{0,1\}^n$ положим $e_x:=\mathrm{Eval}(C,x)\oplus f_n(x)$. Пусть $\mathrm{Count}_{\ge t2^n}(e)$ — стандартная формула подсчёта (например, сортировочная сеть), истинная тогда и только тогда, когда $\sum_x e_x\ge t2^n$. Тогда
$$tt(f_n,s,t)\ :=\ \mathrm{Valid}_s(C)\ \to\ \mathrm{Count}_{\ge t2^n}\bigl((e_x)_{x\in\{0,1\}^n}\bigr).$$
Размер $|tt|=\mathrm{poly}(2^n,s)$.

**Лемма 15.7.1a (Pich–Santhanam, Sec. 2.4.1).** В PS средняя сложность фиксируется формулой $LB_{tt}(h,s(n),t(n)2^n)$ при масштабе $n\in\mathrm{LogLog}$; её пропозициональный перевод и есть $tt(f,s(n),t(n))$ с порогом $\mathrm{Count}_{\ge T(n)}$, где $T(n)=t(n)2^n$ — целое. В частности, при $t(n)=1/2-1/2^{n/4}$ имеем $T(n)=2^{n-1}-2^{3n/4}$, и именно такой порог используется в (H1) и далее в Theorem 9/Cor. 2.

**Барьер-чек (для 15.7.1a).**
- Relativization: перевод $LB_{tt}\mapsto tt$ сохраняется при оракульных гейтах; это чисто синтаксический шаг.
- Natural proofs: фиксация порога $T(n)$ не избегает барьер RR, если доказательство средней сложности строится через конструктивные/крупные свойства.
- Algebrization: шаг не алгебраизирует; это лишь кодирование счётчика.

**Лемма 15.7.1b (масштаб $n\in\mathrm{LogLog}$ и округление порога).** В PS (Sec. 2.4.1) $tt(f,s(n),t(n))$ получается переводом $LB_{tt}(h,s(n),t(n)2^n)$ с подстановкой фиксированной константы $x=2^{2^n}$ (то есть $n=||x||$), что делает таблицу истинности $f$ «доступной» и сохраняет $\Pi^b_1$-форму. Если $t(n)2^n$ не целое, порог в $\mathrm{Count}_{\ge T(n)}$ можно взять как $T(n):=\lceil t(n)2^n\rceil$ (или $\lfloor\cdot\rfloor$); это меняет формулу лишь на $\pm1$ по счёту и не влияет на использование в (H1)/Thm 9.

**Лемма 15.7.1c (деление $n/4$ и реализация $\mathrm{Count}_{\ge T}$).** В PS параметры пишутся как $2^{||x||/4}$ и $1/2-1/2^{||x||/4}$ (Sec. 2.4.2, Def. 3), то есть фактически используется целочисленное $r(n)=\lfloor n/4\rfloor$. Тогда $t(n)=1/2-1/2^{r(n)}$ и
$$T(n)=t(n)2^n=2^{n-1}-2^{n-r(n)}\quad(\text{при }4\mid n\text{ это }2^{n-1}-2^{3n/4}).$$
Можно либо ограничиться $n$ кратными $4$ (добавив условие в (H1)), либо принять $r(n)=\lfloor n/4\rfloor$ без изменения вывода. Формулу $\mathrm{Count}_{\ge T}$ можно реализовать стандартной сортировочной сетью или сумматором за $\mathrm{poly}(2^n)$ (это достаточно для EF и для масштаба $n\in\mathrm{LogLog}$).

**Лемма 15.7.1d (размер счётчика).** Пусть $N=2^n$ — число битов $(e_x)_x$. Существует булева схема размера $O(N\log N)$ и глубины $O(\log N)$, вычисляющая сумму $\sum_x e_x$ в двоичном виде (например, двоичное дерево сумматоров), а затем компаратором проверяющая $\sum_x e_x\ge T$. Следовательно, $\mathrm{Count}_{\ge T}$ можно зашить в $tt(f,s,t)$ схемой размера $\mathrm{poly}(N)=\mathrm{poly}(2^n)$.

**Замечание (3‑CNF для $\mathrm{Count}_{\ge T}$).** Если нужно иметь именно CNF/3‑CNF подформулу, то схему из Леммы 15.7.1d можно перевести в 3‑CNF с $O(N\log N)$ клаузами стандартным Tseitin‑кодированием (см. §16.80).

**Барьер-чек (для 15.7.1b–15.7.1d).**
- Relativization: фиксация $x=2^{2^n}$ и округление — синтаксис, релятивизируется.
- Natural proofs: не даёт обхода RR-барьера (чисто кодирование).
- Algebrization: не алгебраизирует.

**Лемма 15.7.1 (эквивалентность).** $tt(f_n,s,t)$ — тавтология $\iff$ любая схема размера $s$ ошибается на доле входов $\ge t$.

*Доказательство.* ($\Rightarrow$) Пусть есть схема $C$ размера $s$ с ошибкой $<t$. Подставим её код в $C$ и согласованные значения гейтов; тогда $\mathrm{Valid}_s(C)=1$, но счётчик выдаёт $0$, формула ложна. ($\Leftarrow$) Если формула ложна на некотором присваивании, то $C$ валидна и $\sum_x e_x<t2^n$, значит найдена схема с ошибкой $<t$. $\square$

**Где используется.** В гипотезе (H1) раздела 15.7 берётся $s=2^{n/4}$ и $t(n)=1/2-1/2^{n/4}$, и утверждается, что $tt(h_{0,n},s,t(n))$ — тавтология для всех больших $n$. Эти формулы входят в аксиомную схему $\mathrm{EF}+tt(h,s,t)$ и используются как предпосылка в Theorem 8/9 (Pich–Santhanam) для вывода схемных нижних оценок.

**Барьер-чек.**
- Relativization: определение полностью релятивизируется (можно добавить оракульные гейты), так что само по себе не даёт нерелятивизирующего шага.
- Natural proofs: доказательство средней сложности явной $h_0$ через конструктивное/крупное свойство попадёт под барьер Разборова–Рудича, если существуют PRF.
- Algebrization: шаг не алгебраизует проблему; перевод в алгебраическую форму не снимает требований к non-algebrizing техникам.

**Лемма 15.7.2 (распаковка S$^1_2$-предпосылок).** Зафиксируем явную $h_0\in\mathrm{E}$ с предикатом вычисления $\mathrm{Eval}_{h_0}(n,x,b)$, а также явную p-time редукцию $R$ с граф-предикатом $\mathrm{Graph}_R(n,C,y)$ и оценкой $|y|\le p(n)$. Тогда предпосылки из Pich–Santhanam можно записать как $\forall\Pi^b_1$-предложения:

1) (H1$_\Pi$) $\exists n_0\,\forall n>n_0\,\forall C\le m(2^{n/4})\;
\bigl(\mathrm{Valid}_{2^{n/4}}(C)\to \mathrm{Count}_{\ge t(n)2^n}((e_x)_x)\bigr)$,
где $e_x:=\mathrm{Eval}(C,x)\oplus \mathrm{Eval}_{h_0}(n,x,1)$.

2) (H2$_\Pi$) $\forall n\,\forall C\le m(n)\;\mathrm{RedCorr}(n,C,R(n,C))$,
где $R(n,C)$ определяется $\mathrm{Graph}_R(n,C,y)$.

*Доказательство (эскиз).* В (H1$_\Pi$) все кванторы ограничены,
$\mathrm{Eval}_{h_0}$ задаётся bounded-проверкой вычисления за $2^{O(n)}$,
а $\mathrm{Count}_{\ge}$ реализуется стандартной схемой подсчёта; это даёт
формулу класса $\Pi^b_1$ под внешним $\exists n_0$. В (H2$_\Pi$) замена
$\exists y$ на $y=R(n,C)$ делает формулу $\Pi^b_1$, а в $\mathrm{S}^1_2$
провозится тотальность p-time $R$, поэтому (H2$_\Pi$) $\Rightarrow$
$\forall n\,\forall C\,\exists y\,\mathrm{RedCorr}(n,C,y)$. $\square$

**Лемма 15.7.2a (кодирование $\mathrm{Eval}_{h_0}$ и $\mathrm{Graph}_R$).** В формализации PS (Sec. 2.2/2.4) предикаты $\mathrm{Eval}_{h_0}$ и $\mathrm{Graph}_R$ можно считать PV-формулами с полиномиальными ограничениями длины: если $h_0\in\mathrm{E}$, то при масштабе $n\in\mathrm{LogLog}$ (то есть $\exists x,\ n=||x||$) вычисление $h_0$ за $2^{O(n)}$ времени становится $\mathrm{poly}(|x|)$ и допускает PV-определение $\mathrm{Eval}_{h_0}(n,x,b)$; если $R$ — p-time редукция, то её граф $\mathrm{Graph}_R(n,C,y)$ задаётся PV-формулой с ограничением $|y|\le p(n)$ для некоторого полинома $p$.

**Барьер-чек (для 15.7.2a).**
- Relativization: шаг чисто синтаксический (PV-определимость) и релятивизируется.
- Natural proofs: не применимо (нет утверждения о схемной сложности).
- Algebrization: не применимо (нет алгебраической трансформации).

**Лемма 15.7.2b (длина кода схемы и $\mathrm{Valid}_s$).** Зафиксируем стандартное списковое кодирование булевой схемы размера $s$ с фан-ин $2$: для каждой вершины $i$ храним тип гейта и два индекса входов $<i$ (плюс входные переменные и константы). Тогда длина кода $m(s,n)=O(s\log s+n\log s)$, и при $n\le s$ можно взять $m(s)=O(s\log s)$. Предикат $\mathrm{Valid}_s(C)$, проверяющий корректность индексов/типов, является $\Delta^b_0$-формулой (и потому PV-вычислим), что оправдывает ограничение $C\le m(s)$ в (H1$_\Pi$)/(H2$_\Pi$). В частности, при $s=2^{n/4}$ имеем $m(s)=2^{O(n)}$.

**Барьер-чек (для 15.7.2b).**
- Relativization: кодирование и проверка корректности схемы — чисто синтаксический шаг.
- Natural proofs: не применимо.
- Algebrization: не применимо.

**Замечание (паддинг; смысл ограничения $C\le m(s)$).** В (H1$_\Pi$)/(H2$_\Pi$) квантор по $C$ читается как bounded-квантор по коду схемы длины $\le m(s)$ (эквивалентно, по числу $C<2^{m(s)}$). Это ограничение не исключает ни одной схемы размера $\le s$: при gate-list кодировании можно всегда привести код к фиксированной длине $m(s)$ (например, дополнив список до $s$ гейтов фиктивными записями/нулями), не меняя декодированную схему. Поэтому все содержательные ограничения на $C$ идут через $\mathrm{Valid}_s(C)$, а $C\le m(s)$ лишь делает квантор bounded (см. §16.79).

**Лемма 15.7.2c (оценка $\mathrm{Eval}(C,x)$).** Для gate-list кодирования из Леммы 15.7.2b функция $\mathrm{Out}(C,x)$, вычисляющая выход схемы $C$ на входе $x$, является PV-функцией (вычисляется за $\mathrm{poly}(s)$ шагов). Тогда предикат $\mathrm{Eval}(C,x,b):\equiv (\mathrm{Out}(C,x)=b)$ — $\Delta^b_0$-формула. В пропозициональном переводе можно использовать $O(s)$ вспомогательных переменных для значений гейтов и $O(s)$ локальных ограничений, так что размер формулы $\mathrm{Eval}(C,x)$ — $\mathrm{poly}(s)$ (и, следовательно, $|tt|=\mathrm{poly}(2^n,s)$).

**Барьер-чек (для 15.7.2c).**
- Relativization: оценка выхода схемы релятивизируется.
- Natural proofs: не применимо.
- Algebrization: не применимо.

**Где скрыто усиление.**
- (H1$_\Pi$) — это a.e.-твёрдость (для всех больших $n$), а не i.o.-вариант,
и функция $h_0$ фиксирована и явна.
- (H2$_\Pi$) требует **фиксированную** редукцию $R$ и доказуемую тотальность
в $\mathrm{S}^1_2$; без $R$ формула становится $\Sigma^b_2$.

**Барьер-чек.**
- Relativization: обе формулы релятивизируются при добавлении оракульных гейтов.
- Natural proofs: (H1$_\Pi$) при конструктивном/крупном доказательстве подпадает под барьер RR (при PRF).
- Algebrization: формулы не снимают алгебраизирующий барьер; нужны неалгебраизирующие идеи.

**Определение (схема аксиом EF + tt(h,s,t); Pich–Santhanam Sec. 2.4).** Пусть $h\in\mathrm{E}$ и функции $s(2^n),t(2^n)$ таковы.
Для всех больших $n$ любая схема размера $s(2^n)$ ошибается на доле $\ge t(2^n)$ на $h_n$.
Тогда $\mathrm{EF}+tt(h,s,t)$ — EF с аксиомами $\{tt(h_n,s(2^n),t(2^n)):\ n\ge n_0\}$.

**Определение (anticheckers).** Для функции $f$ и $s$ множество
$A_n^{f,s}\subseteq\{0,1\}^n$ называется antichecker, если
$|A_n^{f,s}|=\mathrm{poly}(s)$.
Любая схема такого размера ошибается на входе из $A_n^{f,s}$.
Для функций $f$, трудных для схем размера $s^3$ (при $s\ge n^3$), anticheckers существуют.
Средняя сложность $f$ даёт anticheckers; Pich–Santhanam, Sec. 3 (`../resources/downloads/pich_santhanam_2023_ef_lower_bounds.pdf`).
Thm 7: «feasible anticheckers» формализуются через EF+$w$ и дают схемные нижние оценки при неполиномиальности EF (average‑case предпосылка).

**Теоремы 7–9 (Pich–Santhanam 2023, Sec. 3–5; цитируются).**
**Схема зависимостей (сжато).**
- (H1) $\mathrm{S}^1_2$ доказывает среднюю сложность $h_0\in\mathrm{E}$: $tt(h_{0,n},2^{n/4},t(n))$ *(статус: не доказано для явных $h_0$).*
- (H2a) $\mathrm{S}^1_2$ формализует редукцию $\neg\exists\mathrm{OWF}\Rightarrow$ learning (через $\mathrm{RedCorr}$).
- (H2b) $\mathrm{S}^1_2$ формализует редукцию $\mathrm{NP}\not\subseteq\mathrm{P/poly}\Rightarrow$ OWF (альтернатива).
- (H3a) EF+tt имеет нижние оценки $2^{a n}$ на $tt(g_n,n^t,t(n))$ (шаблон выше) *(статус: открыто).*
- (H3b) EF (или EF+$w$) не p-bounded (вариант Thm 7/Cor. 2) *(статус: открыто).*
Тогда: (H1)+(H2a)+(H3a) $\Rightarrow$ $\mathrm{SAT}\notin\mathrm{Circuit}[n^k]$ (Thm 9; Cor. 2 даёт равномерный вариант).
(H1)+(H2b)+(H3b) $\Rightarrow$ $\mathrm{SAT}\notin\mathrm{P/poly}$ (Thm 8).
Замечание: EF‑нижние оценки сами по себе недостаточны для $\mathrm{NP}\ne\mathrm{coNP}$ без p‑оптимальности.

**Открытые шаги (checklist).**
- (O1) Доказать среднюю сложность $h_0\in\mathrm{E}$: $tt(h_{0,n},2^{n/4},t(n))$.
- (O2) Доказать EF‑нижние оценки $2^{a n}$ для $tt(g_n,n^t,t(n))$ (или неполиномиальность EF/EF+$w$ на явных тавтологиях).

Статус: (O1) — стандартная гипотеза о средней сложности в $\mathrm{E}$ (для явных функций границы не доказаны); (O2) — открытая EF‑задача.

Барьерный контекст: Natural Proofs и Algebrization ограничивают схемные техники;
сильные EF‑нижние оценки ожидают нерелятивизирующих/ненатуральных идей.

**Определение (вариант с советом).** $w_{n,k,u}(f)$: схемы $C$ читаются как коды
алгоритмов времени $O(n^k)$ с советом длины $u(n)$ (p-time, $u(n)\le n^k$).
$W_{n,k,u}(f)$ — $\forall\Pi^b_1$-формализация "для всех $n>n_0$ формулы $w_{n,k,u}(f)$ — тавтологии".
$\mathrm{Time}[n^k]/u(n)$ — класс языков, решаемых такими алгоритмами.

Замечание: EF+tt фиксирует hardness конкретного $h$, тогда как EF+$w$ кодирует нижние оценки против $\mathrm{Time}[n^k]/u(n)$.
Thm 9 использует EF+tt, Cor. 2 — EF+$w$. См. список «Открытые шаги» ниже.

**Обозначение.** $\mathrm{EF}+w_{k,u}(f)$ означает EF с аксиомной схемой
$\{w_{n,k,u}(f): n\ge n_0\}$ (аналогично определению $\mathrm{EF}+tt(h,s,t)$ выше).

**Следствие (Pich–Santhanam 2023, Cor. 2).**
Пусть $k\ge 1$ и $u$ p-time, $u(n)\le n^k$.

1) Если существует p-time $f$ такое, что для всех больших $n$ $w_{n,k,u}(f)$ — тавтологии, и система $\mathrm{EF}+w_{k,u}(f)$ не p-bounded,
то $\mathrm{SAT}\notin\mathrm{Time}[n^{\Omega(k)}]/u(n)$ бесконечно многих $n$.

2) Если $\mathrm{S}^1_2\vdash W_{n,k,u}(f)$ и EF не p-bounded, то то же заключение.

**Сравнение систем (кратко).**
| Система | Идея | Комментарий |
|---|---|---|
| Frege | фиксированные схемы аксиом + правила | разные варианты полиномиально эквивалентны |
| EF | Frege + расширения $p\leftrightarrow\psi$ | одна из самых сильных стандартных систем |
| AC⁰-Frege | Frege с глубиной $d$ | существенно слабее EF; нижние оценки известны |
| CP | линейные неравенства над $\{0,1\}$ | удобно для счётных аргументов (`../resources/downloads/buss_cutting_planes_notes.pdf`) |

### 15.8. PHP имеет полиномиальное опровержение в CP (полное доказательство)

Здесь видно «почему» резолюция слаба: PHP экспоненциально трудна
для резолюции, но элементарно опровергается в CP за счёт счётного
(линейного) аргумента.

Рассмотрим $m=n+1$ голубей и $n$ норок, переменные $x_{i,j}\in\{0,1\}$.

Вместо CNF‑кодировки из раздел 15 используем эквивалентную (на $\{0,1\}$) систему линейных неравенств:

1) *(голубь где‑то сидит)* для каждого $i\in\{1,\dots,m\}$:
$$\sum_{j=1}^n x_{i,j}\ \ge\ 1.$$

2) *(не вместе)* для каждого $j\in\{1,\dots,n\}$:
$$\sum_{i=1}^m x_{i,j}\ \le\ 1,$$
то есть эквивалентно
$$-\sum_{i=1}^m x_{i,j}\ \ge\ -1.$$

Замечание: попарные CNF‑клаузы $(\neg x_{i,j}\lor\neg x_{i',j})$ на $\{0,1\}$
эквивалентны ограничению $\sum_i x_{i,j}\le 1$ ("не более одной единицы в столбце").
$(\Leftarrow)$ очевидно, а если $\sum_i x_{i,j}\ge 2$, то найдутся $i\ne i'$ с $x_{i,j}=x_{i',j}=1$, и клауза ложна.

**Теорема 15.8.** Существует CP‑опровержение $\mathrm{PHP}^{n}_{n+1}$ размера $\mathrm{poly}(n)$.

*Доказательство.* Обозначим $S:=\sum_{i=1}^m\sum_{j=1}^n x_{i,j}$.

Сложим неравенства (1) по всем $i$ (правило сложения CP): получаем
$$S\ \ge\ m\ =\ n+1.$$ 

Сложим неравенства (2') по всем $j$ (в форме с $\ge$):
$$-S\ \ge\ -n.$$ 

Сложив эти два неравенства, получаем $0\ge 1$ (эквивалентно $-1\ge 0$),
то есть противоречие. Значит система не имеет 0/1‑решений, и это и есть
CP‑опровержение.

*Оценка размера.* Мы используем $O(n)$ сложений, каждое неравенство имеет
$O(n)$ мономов, поэтому общий размер вывода $\mathrm{poly}(n)$. $\square$
