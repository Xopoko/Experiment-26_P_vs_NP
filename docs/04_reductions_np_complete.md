## 4. Редукции и NP‑полнота (минимальный аппарат)

**Определение (полиномиальная many‑one редукция).** Язык $A$ *сводится* к $B$
(обозначение $A\le_m^p B$), если существует полиномиально вычислимая функция
$f$ такая, что для всех $x$:
$$x\in A \iff f(x)\in B.$$

**Lean‑скелет:** определения many‑one редукции и NP‑полноты заведены в `formal/PvNP/Reductions.lean`.

**Определение (NP‑полный).** Язык $B$ NP‑полон, если (i) $B\in\mathrm{NP}$ и (ii) для любого $A\in\mathrm{NP}$ верно $A\le_m^p B$.

**Лемма 4.1.** $\mathrm{SAT}\in\mathrm{NP}$.

*Доказательство.* Сертификат — присваивание булевых переменных.
Верификатор за полиномиальное время подставляет его в формулу и проверяет,
что каждая клауза истинна. $\square$

**Теорема 4.2 (Cook–Levin).** SAT NP‑полна.

*Доказательство.* Пусть $L\in\mathrm{NP}$.
По сертификатной формулировке (Раздел 2) существует полином $p$
и детерминированный полиномиальный верификатор $V$, такой что
$$x\in L \iff \exists y\in\{0,1\}^{p(|x|)}:\ V(x,y)=1.$$

Зафиксируем детерминированную одноленточную МТ $M$, вычисляющую $V$ (робастность модели).
Для входа $x$ длины $n$ машина $M$ останавливается не более чем за $T(n)$ шагов на всех строках $\langle x,y\rangle$ (где $|y|=p(n)$).
Заменим $T(n)$ на $T(n)+n+p(n)+2$, чтобы места под вход хватило; дополним $M$ холостыми шагами, чтобы она делала **ровно** $T:=T(n)$ шагов.

Построим по $x$ CNF‑формулу $\varphi_x$, выполнимую тогда и только тогда,
когда существует сертификат $y$, при котором $M$ принимает $\langle x,y\rangle$.

**Переменные.** Пусть $\Gamma$ — алфавит ленты $M$ (включая $0,1,\square,\#,\triangleright$).
$Q$ — множество состояний; $q_0$ — стартовое, $q_{\mathrm{acc}}$ — принимающее.
Рассмотрим расширенный алфавит $\Gamma':=\Gamma\cup(Q\times\Gamma)$:
символ $(q,a)$ означает, что головка стоит в клетке, машина в состоянии $q$,
и «под головкой» записан $a$.

Положим $W:=T+2$ и рассматриваем клетки $i\in\{0,1,\dots,W\}$ (крайние — границы).
Для каждого $t\in\{0,1,\dots,T\}$, $i\in\{0,1,\dots,W\}$ и $s\in\Gamma'$
вводим переменную $X_{t,i,s}$: «в момент $t$ в клетке $i$ записан символ $s$».

**Клаузы (CNF).** Формула $\varphi_x$ — конъюнкция следующих семейств.

(A) *(Ровно один символ в клетке.)* Для каждого $(t,i)$:
- «хотя бы один» : $\bigvee_{s\in\Gamma'} X_{t,i,s}$;
- «не более одного» : для всех $s\ne s'$ добавляем $(\neg X_{t,i,s}\lor\neg X_{t,i,s'})$.

(B) *(Ровно одна позиция головки/состояние.)* Для каждого $t$ требуем, что ровно одна клетка содержит «состоянийный» символ:
- $\bigvee_{i\in\{1,\dots,W-1\},\ q\in Q,\ a\in\Gamma} X_{t,i,(q,a)}$;
- попарные запреты для разных троек $(i,q,a)$.

(C) *(Границы и начальная конфигурация.)* Для всех $t$ фиксируем границы: $X_{t,0,\triangleright}$ и $X_{t,W,\square}$.
Пусть $x=x_1\dots x_n$. В момент $0$ задаём ленту вида $\triangleright\ x\ \#\ y\ \square\cdots$ и стартовое состояние в первой букве $x$:
- $X_{0,1,(q_0,x_1)}$;
- для $i=2,\dots,n$ : $X_{0,i,x_i}$;
- $X_{0,n+1,\#}$;
- для «сертификатной зоны» $i=n+2,\dots,n+1+p(n)$ : добавляем $(X_{0,i,0}\lor X_{0,i,1})$;
- для остальных $i>n+1+p(n)$ фиксируем $X_{0,i,\square}$.

(D) *(Один шаг вычисления, локальные ограничения.)* Для каждого $t<T$
и $i\in\{1,\dots,W-1\}$ требуем согласование окна $3\times 2$ с переходом $\delta$.
Формально: рассмотрим все 6‑тройки символов
$$(a_{-1},a_0,a_{+1};\ b_{-1},b_0,b_{+1})\in(\Gamma')^6,$$
которые **не могут** встретиться как
$$(\text{символы в }(t,i-1),(t,i),(t,i+1);\ \text{символы в }(t+1,i-1),(t+1,i),(t+1,i+1))$$
в корректном ходе $M$. Для каждой такой 6‑тройки добавляем клаузу, запрещающую её появление:
$$(
eg X_{t,i-1,a_{-1}}\lor
eg X_{t,i,a_0}\lor
eg X_{t,i+1,a_{+1}}\lor
eg X_{t+1,i-1,b_{-1}}\lor
eg X_{t+1,i,b_0}\lor
eg X_{t+1,i+1,b_{+1}}).$$
Так как $M$ фиксирована, $|\Gamma'|$ — константа, поэтому число локальных шаблонов — константа; всего клауз (D) $O(T\cdot W)=O(T^2)$.
$$(a_{-1},a_0,a_{+1};\ b_{-1},b_0,b_{+1})\in(\Gamma')^6,$$
которые **не могут** встретиться как
$$(\text{символы в }(t,i-1),(t,i),(t,i+1);\ \text{символы в }(t+1,i-1),(t+1,i),(t+1,i+1))$$
в корректном ходе $M$. Для каждой такой запрещённой 6‑тройки добавляем одну CNF‑клаузу, запрещающую её одновременное появление:
$$(
\neg X_{t,i-1,a_{-1}}\lor\neg X_{t,i,a_0}\lor\neg X_{t,i+1,a_{+1}}\lor
\neg X_{t+1,i-1,b_{-1}}\lor\neg X_{t+1,i,b_0}\lor\neg X_{t+1,i+1,b_{+1}}).$$

(E) *(Принятие.)* Требуем, чтобы на шаге $T$ машина была в принимающем состоянии:
$$\bigvee_{i\in\{1,\dots,W-1\},\ a\in\Gamma} X_{T,i,(q_{\mathrm{acc}},a)}.$$

**Оценка размера.** Число переменных $|\{X_{t,i,s}\}|=(T+1)(W+1)|\Gamma'|=O(T^2)$, и число клауз также $O(T^2)$.
Значит $x\mapsto\varphi_x$ вычисляется за $\mathrm{poly}(|x|)$.

**Корректность.**
- Если $x\in L$, то существует $y$ такое, что $M$ принимает $\langle x,y\rangle$.
  Таблица вычисления длины $T$ задаёт значения $X_{t,i,s}$; по построению выполняются (A)–(E), значит $\varphi_x$ выполнима.
- Если $\varphi_x$ выполнима, то из (A),(B) получаем корректное кодирование «ровно одного символа» и «ровно одной головки/состояния».
  (C) фиксирует вход $x$ и задаёт сертификат $y$ в выделенной зоне, (D) согласует соседние такты с $\delta$.
  Значит переменные описывают вычисление $M$ на $\langle x,y\rangle$, и по (E) оно принимающее; значит $x\in L$.

Итак, для любого $L\in\mathrm{NP}$ имеем $L\le_m^p\mathrm{SAT}$,
то есть SAT NP‑трудна. Совместно с Леммой 4.1 получаем, что SAT NP‑полна.
$\square$

Ниже — полностью выписанная редукция SAT $\le_m^p$ 3SAT.
