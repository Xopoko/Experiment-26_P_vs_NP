## 12. Иерархия по времени: диагонализация (полное доказательство)

Этот раздел нужен как «калибровка»: мы докажем строгий результат о разделении
классов по времени и явно увидим, что доказательство **релятивизирует**
(барьер Baker–Gill–Solovay).

**Определение (time-constructible).** Функция $t:\mathbb{N}\to\mathbb{N}$
называется *времени‑конструируемой*, если существует детерминированная МТ $T$
такая, что на входе $1^n$ она останавливается ровно через $t(n)$ шагов
(или, эквивалентно, может выписать $t(n)$ в унарном виде за $O(t(n))$ времени).

**Лемма 12.1 (универсальная симуляция, цитируется).** Существует универсальная
детерминированная многоленточная МТ $U$, которая по входу $(\langle M\rangle, x, 1^s)$
симулирует работу детерминированной МТ $M$ на $x$ в течение $s$ шагов
и останавливается за $O(s\log s)$ шагов.
См. `../resources/downloads/uw_hierarchy_2022_lecture5.pdf`.

*Комментарий.* Этот лог‑фактор — стандартная плата за универсальность
(кодирование переходов, адресация лент и т.п.). Для целей иерархии он допустим.

**Определение (диагональный язык).** Зафиксируем кодирование, которое каждому
слову $y\in\{0,1\}^*$ сопоставляет детерминированную МТ $M_y$
(если $y$ некорректен как код, считаем $M_y$ машиной, которая всегда отвергает).

Для time-constructible $t$ определим язык
$$L_t:=\{y:\ M_y(y)\ \text{не принимает за}\ \le t(|y|)\ \text{шагов}\}.$$

**Теорема 12.2 (Deterministic Time Hierarchy).** Пусть $t(n)\ge n$ —
time-constructible. Тогда
$$\mathrm{TIME}(t(n))\subsetneq\mathrm{TIME}(t(n)\log t(n)).$$

*Доказательство.*

1) Покажем, что $L_t\in\mathrm{TIME}(t(n)\log t(n))$.
Алгоритм $A$ на входе $y$ длины $n$:

- с помощью машины‑«часов» (существует по time-constructible) получаем лимит $t(n)$;
- запускаем универсальную симуляцию $U(\langle M_y\rangle, y, 1^{t(n)})$;
- если симуляция обнаружила принятие за $\le t(n)$ шагов — отвергаем, иначе принимаем.

По Лемме 12.1 симуляция занимает $O(t(n)\log t(n))$ времени;
остальная работа доминируемо меньше, значит $A$ укладывается в
$O(t(n)\log t(n))$.

2) Покажем, что $L_t\notin\mathrm{TIME}(t(n))$. Предположим противное:
существует детерминированная МТ $D$, которая решает $L_t$ за $\le t(n)$ шагов
на входах длины $n$.

Рассмотрим вход $y:=\langle D\rangle$ (код самой $D$).
Так как $D$ решает $L_t$, имеем:

- если $D(y)$ принимает, то $y\in L_t$, то есть по определению
  $M_y(y)=D(y)$ **не** принимает за $\le t(|y|)$ шагов — противоречие;
- если $D(y)$ отвергает, то $y\notin L_t$, то есть $D(y)$ принимает
  за $\le t(|y|)$ шагов — противоречие.

Следовательно, такого $D$ не существует и $L_t\notin\mathrm{TIME}(t(n))$.

Из пункта (1) и (2) следует строгость включения. $\square$

**Замечание 12.3 (релятивизация).** Это доказательство переносится почти дословно
в оракульный мир: для любого оракула $A$ верно
$\mathrm{TIME}^A(t)\subsetneq\mathrm{TIME}^A(t\log t)$.
Поэтому оно не может напрямую решить $\mathrm{P}$ vs $\mathrm{NP}$
из-за существования оракулов $A,B$ с противоположными ответами.

**Следствие 12.4.** $\mathrm{P}\subsetneq\mathrm{EXP}$.

*Доказательство.* Сначала отметим, что $\mathrm{P}\subseteq\mathrm{TIME}(2^n)$:
любая функция $n^k$ в конце концов не превосходит $2^n$, значит
$\bigcup_k\mathrm{TIME}(n^k)\subseteq\mathrm{TIME}(2^n)$.

Применим Теорему 12.2 к $t(n)=2^n$ (она time-constructible).
Получаем язык $L\in\mathrm{TIME}(2^n\cdot n)\setminus\mathrm{TIME}(2^n)$.
Тогда $L\notin\mathrm{P}$, так как $\mathrm{P}\subseteq\mathrm{TIME}(2^n)$.
При этом $\mathrm{TIME}(2^n\cdot n)\subseteq\mathrm{EXP}$.
Значит $\mathrm{P}\subsetneq\mathrm{EXP}$. $\square$
