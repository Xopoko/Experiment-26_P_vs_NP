# P vs NP — исследовательские шаги 16.3–16.36

Этот файл — часть `docs/research/` (см. [index](index.md)).
Главный файл: `P_vs_NP.md`.

[Открыть главный ноутбук](../../P_vs_NP.md)

### 16.3. Исследовательский шаг: decision vs search для SAT

**Вопрос («А что если…?»).** Может ли SAT решаться в полиномиальное время,
а задача поиска удовлетворяющего присваивания оставаться существенно труднее?

**Определение (SAT‑SEARCH).** По входу CNF‑формулы $\varphi$: если $\varphi$ выполнима,
выдать удовлетворяющее присваивание; иначе вывести $\bot$.

**Лемма 16.3.** Существует полиномиальный алгоритм, который решает SAT‑SEARCH,
используя $O(n)$ вызовов решения SAT (где $n$ — число переменных).
В частности, если $\mathrm{SAT}\in\mathrm{P}$, то SAT‑SEARCH $\in\mathrm{FP}$.

*Доказательство.* Сначала одним вызовом проверяем, выполнима ли $\varphi$.
Если нет — возвращаем $\bot$.
Иначе последовательно фиксируем переменные: для $i=1..n$ проверяем выполнимость
$\varphi\upharpoonright (x_i=0)$. Если выполнима — ставим $x_i:=0$,
иначе $x_i:=1$ (при этом $\varphi\upharpoonright (x_i=1)$ обязана быть выполнима,
иначе исходная $\varphi$ невыполнима). Индукцией по $i$ сохраняется выполнимость,
и после $n$ шагов получаем удовлетворяющее присваивание.
Время — $O(n)$ вызовов SAT и полиномиальные подстановки. $\square$

**Вывод.** Попытка разделить P и NP через «decision проще, чем search»
для SAT не работает: SAT саморедуцируем.

**Барьер‑чек.**
- *Релятивизация:* да, алгоритм оракульный (тот же аргумент для $\mathrm{SAT}^A$).
- *Natural proofs:* неприменимо (нет схемных нижних оценок).
- *Algebrization:* неприменимо (нет алгебраизации/полиномов; чисто комбинаторика).

### 16.4. Исследовательский шаг: sparse NP‑полный ⇒ P=NP

**Вопрос («А что если…?»).** Что если у NP есть разреженный (sparse) NP‑полный язык?

**Определение (sparse).** Язык $S$ разрежен, если существует полином $p$, что
$|S\cap \Sigma^{\le m}|\le p(m)$ для всех $m$.

**Лемма 16.4 (Мэхэни).** Если существует разреженный NP‑полный язык
относительно $\le_m^p$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $S$ sparse и $\mathrm{SAT}\le_m^p S$ через $f$.
Зафиксируем полином $p$ для sparsity и полином $q$, ограничивающий длину $f(\psi)$
на формулах $\psi$ размера $\mathrm{poly}(|\varphi|)$.
Положим $K:=p(q(|\varphi|))$. Построим алгоритм SAT.

Поддерживаем список $L$ формул с инвариантом:
(i) $|L|\le K$, (ii) если $\varphi$ выполнима, то выполнима хотя бы одна формула из $L$.
Старт: $L=\{\varphi\}$. Для переменной $x_i$ каждую $\psi\in L$ заменяем
на $\psi\upharpoonright(x_i=0)$ и $\psi\upharpoonright(x_i=1)$,
получая $L'$, затем применяем «подрезку».
(Если нужно оставаться в CNF, используем стандартное полиномиальное Tseitin‑кодирование дизъюнкций.)

**Pruning‑лемма.** Для списка $\varphi_1,\dots,\varphi_k$ (где $k> K$) можно за полиномиальное
время удалить хотя бы одну формулу, сохранив (ii).

Доказательство pruning: положим $\psi_i:=\varphi_1\lor\cdots\lor\varphi_i$ и $y_i:=f(\psi_i)$.
- Если найдены $i<j$ с $y_i=y_j$, то $\psi_i$ и $\psi_j$ имеют одинаковую выполнимость,
  поэтому удаление $\varphi_{i+1},\dots,\varphi_j$ сохраняет (ii).
- Иначе все $y_i$ различны. Тогда среди $\psi_i$ выполнимых $\le K$ (иначе в $S$ было бы
  $>K$ различных строк). Выполнимые $\psi_i$ образуют суффикс, значит при наличии
  выполнимой формулы она среди последних $K$; удаляем первые $k-K$.

Повторяя pruning, держим $|L|\le K$. После обработки всех переменных все формулы в $L$
константны; проверяем, есть ли истинная. Это полиномиально, значит $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент остаётся верным с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.5. Исследовательский шаг: p‑bounded резолюция?

**Вопрос («А что если…?»).** Может ли резолюция быть p‑bounded для всех
невыполнимых CNF‑формул?

**Лемма 16.5.** Если резолюция p‑bounded, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* При p‑bounded резолюции каждая невыполнимая CNF
имеет полиномиальную рефутацию. Проверка корректности резолюционного вывода
полиномиальна, значит $\mathrm{UNSAT}\in\mathrm{NP}$.
Так как $\mathrm{UNSAT}$ coNP‑полна, получаем $\mathrm{coNP}\subseteq\mathrm{NP}$,
а значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к предпосылке.** Формулы $\mathrm{PHP}^{n}_{n+1}$ требуют
экспоненциальных резолюционных рефутаций (Теорема 15.2),
так что резолюция не является p‑bounded в общем случае.

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированной proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.6. Исследовательский шаг: резолюция vs CP (p‑симуляция)

**Вопрос («А что если…?»).** Может ли резолюция p‑симулировать систему Cutting Planes (CP)?

**Лемма 16.6.** Резолюция не p‑симулирует CP.

*Доказательство (контрпример).* Предположим, что резолюция p‑симулирует CP.
Тогда любую CP‑рефутацию размера $\mathrm{poly}(n)$ можно преобразовать
в резолюционную рефутацию размера $\mathrm{poly}(n)$.
По Теореме 15.8 формулы $\mathrm{PHP}^{n}_{n+1}$ имеют полиномиальные CP‑рефутации,
а по Теореме 15.2 любая резолюционная рефутация $\mathrm{PHP}^{n}_{n+1}$
имеет экспоненциальный размер. Противоречие. $\square$

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о конкретных proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.7. Исследовательский шаг: приближение MAX‑3SAT

**Вопрос («А что если…?»).** Что если существует полиномиальный алгоритм,
который отличает выполнимые 3CNF от формул, где нельзя удовлетворить
более чем $(1-\varepsilon)$ долю клауз (для некоторого константного $\varepsilon>0$)?

**Определение (GAP‑3SAT$_\varepsilon$).** Вход — 3CNF $\varphi$.
YES: $\varphi$ выполнима. NO: любая подстановка удовлетворяет
не более $(1-\varepsilon)$ доли клауз.

**Лемма 16.7.** Если для некоторого $\varepsilon>0$ задача GAP‑3SAT$_\varepsilon$
решается за полиномиальное время, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* По теореме PCP (Раздел 16.2) существует константа
$\varepsilon>0$, для которой GAP‑3SAT$_\varepsilon$ NP‑трудна.
Если бы она решалась за полиномиальное время, то решалась бы SAT,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* не обязано релятивизировать (PCP использует аритметизацию).
- *Natural proofs:* неприменимо (это не схемные нижние оценки).
- *Algebrization:* не ясно; доказательство PCP не сводится к чистой алгебризации.

### 16.8. Исследовательский шаг: NP‑ и coNP‑полнота одного языка

**Вопрос («А что если…?»).** Может ли существовать язык $L$, который
NP‑полон и coNP‑полон (по $\le_m^p$)?

**Лемма 16.8.** Если существует язык, который одновременно NP‑полон и coNP‑полон
(по $\le_m^p$), то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $L$ — такой язык. Тогда $L\in\mathrm{NP}\cap\mathrm{coNP}$.
Для любого $A\in\mathrm{NP}$ существует полиномиальная редукция $f$ такая, что
$x\in A \iff f(x)\in L$. Тогда
$$x\in A^c \iff f(x)\in L^c.$$
Поскольку $L\in\mathrm{coNP}$, имеем $L^c\in\mathrm{NP}$, значит $A^c\in\mathrm{NP}$,
то есть $A\in\mathrm{coNP}$. Следовательно, $\mathrm{NP}\subseteq\mathrm{coNP}$.
Симметрично, из coNP‑полноты $L$ и того, что $L\in\mathrm{NP}$, получаем
$\mathrm{coNP}\subseteq\mathrm{NP}$. Итак, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.9. Исследовательский шаг: SAT ≤ UNSAT?

**Вопрос («А что если…?»).** Может ли SAT полиномиально сводиться к UNSAT?

**Лемма 16.9.** Если $\mathrm{SAT}\le_m^p\mathrm{UNSAT}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $f$ — редукция SAT к UNSAT.
Тогда SAT принадлежит coNP (coNP замкнут по $\le_m^p$‑редукциям).
Так как SAT NP‑полна, получаем $\mathrm{NP}\subseteq\mathrm{coNP}$.
Берём дополнения: $\mathrm{coNP}\subseteq\mathrm{NP}$. Следовательно, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.10. Исследовательский шаг: Unique-SAT и рандомизация

**Вопрос («А что если…?»).** Что если Unique-SAT решается за полиномиальное время — следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (Unique-SAT, promise).** Вход: CNF‑формула $\varphi$ над $n$ переменными.
YES: $\varphi$ имеет ровно одно удовлетворяющее присваивание.
NO: $\varphi$ не имеет удовлетворяющих присваиваний.
(Иные случаи не обязаны обрабатываться корректно.)

**Лемма 16.10 (Valiant-Vazirani).** Существует вероятностная полиномиальная редукция,
которая по формуле $\varphi$ строит CNF‑формулу $\varphi'$ такую, что:
- если $\varphi$ невыполнима, то $\varphi'$ невыполнима всегда;
- если $\varphi$ выполнима, то с вероятностью $\ge 1/(8n)$ $\varphi'$ имеет ровно одно решение.

В частности, если Unique-SAT $\in\mathrm{P}$, то $\mathrm{SAT}\in\mathrm{RP}$.

*Доказательство.* Пусть $S\subseteq\{0,1\}^n$ — множество решений $\varphi$, $s=|S|$.
Выбираем $m\in\{1,\dots,n{+}1\}$, случайную попарно независимую хэш‑функцию
$h:\{0,1\}^n\to\{0,1\}^m$ (например, $h(x)=Ax\oplus b$ над $\mathbb{F}_2$)
и случайный $t\in\{0,1\}^m$. Строим
$$\varphi' := \varphi\land (h(x)=t),$$
кодируя $m$ линейных уравнений в CNF с полиномиальным ростом (кодирование Тсейтина).
Если $\varphi$ невыполнима, то $\varphi'$ тоже.

Пусть $s\ge 1$. Существует $m$ такое, что $2^{m-2}< s\le 2^{m-1}$.
Положим $Z=|S\cap h^{-1}(t)|=\sum_{x\in S} I_x$, где $I_x=[h(x)=t]$.
Тогда $\mu=\mathbb{E}[Z]=s/2^m\in(1/4,1/2]$ и по попарной независимости
$$\mathbb{E}[Z(Z-1)]=\sum_{x\ne y}\Pr[I_x=I_y=1]=\frac{s(s-1)}{2^{2m}}\le \mu^2.$$
Так как при $Z\ge 2$ выполнено $Z(Z-1)\ge Z$, получаем
$$\Pr[Z=1]\ge \mu-\mathbb{E}[Z(Z-1)]\ge \mu-\mu^2\ge 3/16.$$
Следовательно, для «правильного» $m$ вероятность уникальности $\ge 3/16$.
При случайном $m$ получаем успех $\ge 1/(8n)$ (с запасом).
Повторением (усилением) получаем RP-алгоритм при наличии решателя Unique-SAT. $\square$

**Вывод/провал.** Unique-SAT $\in\mathrm{P}$ даёт лишь $\mathrm{SAT}\in\mathrm{RP}$.
Чтобы получить $\mathrm{P}=\mathrm{NP}$, нужна дерэндомизация (например, $\mathrm{RP}=\mathrm{P}$)
или детерминированная «изоляция» решений.

**Барьер‑чек.**
- *Релятивизация:* да (редукция комбинаторная и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо/неочевидно.

### 16.11. Исследовательский шаг: NP ⊆ BPP ⇒ коллапс PH

**Вопрос («А что если…?»).** Что если SAT (или весь NP) решается в BPP — следует ли коллапс полиномиальной иерархии?

**Определение (BPP).** Язык $L\in\mathrm{BPP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 2/3,\quad x\notin L\Rightarrow \Pr[A(x)=0]\ge 2/3.$$

**Лемма 16.11.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то $\mathrm{PH}\subseteq\mathrm{BPP}$.
(В частности, если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{PH}$ коллапсирует в BPP.)

*Доказательство.* Сначала покажем $\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}$.
Пусть $M^{O}$ — BPP‑машина, делающая не более $q(n)$ запросов к оракулу $O\in\mathrm{BPP}$.
Каждый запрос $y$ симулируем алгоритмом $A_O(y)$, усиливая его до ошибки
$\delta:=1/(10q(n))$ повторением $O(\log q(n))$ раз и мажоритарным голосованием.
По объединённой вероятности (union bound) шанс, что хоть один из ответов оракула
ошибочен, не превосходит $q(n)\cdot\delta\le 1/10$.
Условно на правильных ответах оракула $M$ ошибается с вероятностью $\le 1/10$.
Итого общая ошибка $\le 1/5<1/3$, а время остаётся полиномиальным.
Следовательно, $\mathrm{BPP}^{\mathrm{BPP}}\subseteq\mathrm{BPP}$;
обратное включение тривиально.

Теперь индукция по $k$ для $\Sigma_k^p$.
База: $\Sigma_1^p=\mathrm{NP}\subseteq\mathrm{BPP}$ по предположению.
Переход: если $\Sigma_k^p\subseteq\mathrm{BPP}$, то
$$\Sigma_{k+1}^p=\mathrm{NP}^{\Sigma_k^p}\subseteq\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}.$$
Значит все уровни PH лежат в BPP, т.е. $\mathrm{PH}\subseteq\mathrm{BPP}$. $\square$

**Вывод/провал.** Предположение $\mathrm{SAT}\in\mathrm{BPP}$ не даёт $\mathrm{P}=\mathrm{NP}$,
а лишь коллапс PH в BPP. Для $\mathrm{P}=\mathrm{NP}$ нужна дерэндомизация
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.12. Исследовательский шаг: BPP in Sigma2 cap Pi2 (Sipser-Gacs-Lautemann)

**Вопрос ("А что если...?").** Можно ли поместить BPP на втором уровне PH?

**Лемма 16.12 (Sipser-Gacs-Lautemann).** $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$. Существует вероятностная машина $R(x,r)$,
работающая за $\mathrm{poly}(|x|)$ и использующая $m$ случайных бит, такая что
ошибка $\le 1/3$. Усилим (повторением и большинством) до ошибки
$\varepsilon:=2^{-2n}$, где $n=|x|$; это даёт новое $m=\mathrm{poly}(n)$.
Положим $G_x:=\{r\in\{0,1\}^m:\ R(x,r)=1\}$.
Тогда
$$x\in L\Rightarrow |G_x|\ge (1-\varepsilon)2^m,\quad x\notin L\Rightarrow |G_x|\le \varepsilon 2^m.$$

Зафиксируем $k:=m+1$. Для $r_1,\dots,r_k\in\{0,1\}^m$ рассмотрим
$$U:=\bigcup_{i=1}^k (G_x\oplus r_i),$$
где $\oplus$ — поразрядное XOR.

(1) Пусть $x\in L$. Выберем $r_i$ равномерно и независимо. Для фиксированного $z$
$$\Pr[z\notin U]=(1-|G_x|/2^m)^k\le \varepsilon^k.$$
По объединённой вероятности
$$\Pr[U\ne\{0,1\}^m]\le 2^m\varepsilon^k\le 2^m\cdot 2^{-2n(m+1)}<1.$$
Следовательно, существует набор $r_1,\dots,r_k$ с $U=\{0,1\}^m$.

(2) Пусть $x\notin L$. Тогда для любых $r_1,\dots,r_k$ имеем
$|U|\le k|G_x|\le k\varepsilon 2^m<2^m$ (для всех достаточно больших $n$),
значит существует $z$ с $z\notin U$.

Итак,
$$x\in L\iff \exists r_1,\dots,r_k\ \forall z\ \exists i\ R(x,z\oplus r_i)=1,$$
что есть $\Sigma_2^p$-формула (так как $k,m=\mathrm{poly}(n)$).
Так как $\mathrm{BPP}$ замкнут по дополнению, получаем также
$L\in\Pi_2^p$. Значит $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$. $\square$

**Вывод/провал.** Лемма лишь помещает $\mathrm{BPP}$ во второй уровень PH;
сама по себе она не даёт $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный, переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.13. Исследовательский шаг: NP in BPP => PH = Sigma2^p

**Вопрос ("А что если...?").** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, коллапсирует ли PH на втором уровне?

**Лемма 16.13.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то
$$\mathrm{PH}=\Sigma_2^p=\Pi_2^p.$$

*Доказательство.* По Лемме 16.11 получаем $\mathrm{PH}\subseteq\mathrm{BPP}$.
По Лемме 16.12 имеем $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.
Следовательно,
$$\mathrm{PH}\subseteq\Sigma_2^p\cap\Pi_2^p\subseteq\Sigma_2^p.$$
Но $\Sigma_2^p\subseteq\mathrm{PH}$ по определению, значит
$\mathrm{PH}=\Sigma_2^p$. Аналогично $\mathrm{PH}=\Pi_2^p$.
Следовательно, $\Sigma_2^p=\Pi_2^p$. $\square$

**Вывод/провал.** Даже при $\mathrm{NP}\subseteq\mathrm{BPP}$ получаем лишь коллапс PH
на уровне 2; до $\mathrm{P}=\mathrm{NP}$ это не доводит без дерэндомизации
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (используются релятивизирующие шаги 16.11 и 16.12).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.14. Исследовательский шаг: SAT в RP => NP = RP

**Вопрос ("А что если...?").** Что если SAT решается в RP — следует ли равенство $\mathrm{NP}=\mathrm{RP}$?

**Определение (RP).** Язык $L\in\mathrm{RP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 1/2,\quad x\notin L\Rightarrow \Pr[A(x)=1]=0.$$

**Лемма 16.14.** Если $\mathrm{SAT}\in\mathrm{RP}$, то $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* (1) $\mathrm{RP}\subseteq\mathrm{NP}$: пусть $A$ использует $m(n)$ случайных бит.
НМТ угадывает строку $r\in\{0,1\}^{m(n)}$ и принимает тогда и только тогда,
когда $A(x,r)=1$. Если $x\in L$, существует принимающий $r$;
если $x\notin L$, принимающих $r$ нет.

(2) $\mathrm{NP}\subseteq\mathrm{RP}$ при $\mathrm{SAT}\in\mathrm{RP}$:
пусть $L\in\mathrm{NP}$ и $f$ — полиномиальная many-one редукция $L\le_m^p\mathrm{SAT}$.
Алгоритм для $L$ вычисляет $y=f(x)$ и запускает RP-алгоритм для SAT на $y$.
Если $x\notin L$, то $y$ невыполним и RP-алгоритм всегда отвергает.
Если $x\in L$, то $y$ выполним и RP-алгоритм принимает с вероятностью $\ge 1/2$.
Значит $L\in\mathrm{RP}$.

Итак, $\mathrm{NP}=\mathrm{RP}$. $\square$

**Вывод/провал.** Даже если SAT в RP, получаем лишь $\mathrm{NP}=\mathrm{RP}$,
а не $\mathrm{P}=\mathrm{NP}$ без дерэндомизации (например, $\mathrm{RP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.15. Исследовательский шаг: P-uniform схемы для SAT

**Вопрос ("А что если...?").** Что если SAT имеет полиномиальные P-uniform схемы?

**Определение (P-uniform).** Семейство схем $\{C_n\}$ называется P-uniform, если
существует детерминированная полиномиальная машина $U$, которая по входу $1^n$
выводит описание схемы $C_n$.

**Лемма 16.15.** Если SAT имеет P-uniform семейство схем полиномиального размера,
то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $U$ строит $C_n$ за $\mathrm{poly}(n)$.
На входе формулы $\varphi$ длины $n$ вычисляем $C_n$ с помощью $U$ и затем
вычисляем $C_n(\varphi)$ за время $\mathrm{poly}(n)$ (размер схемы полиномиален).
Следовательно, $\mathrm{SAT}\in\mathrm{P}$, а значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить P-uniform на $\mathrm{P/poly}$.
Существует tally-язык $L\subseteq\{1\}^*$, не лежащий в $\mathrm{P}$
(диагонализация как в теореме иерархии по времени, Раздел 12).
Для каждого $n$ единственный вход длины $n$ - строка $1^n$, поэтому
константная схема размера $O(1)$ решает $L$ на длине $n$.
Следовательно, $L\in\mathrm{P/poly}$, но $L\notin\mathrm{P}$.

**Вывод/провал.** Полиномиальные неравномерные схемы не дают $\mathrm{P}=\mathrm{NP}$;
критична униформность построения.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - симуляция и диагонализация).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.16. Исследовательский шаг: P-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-immune язык?

**Определение (P-immune).** Бесконечный язык $L$ называется P-immune, если у него нет
бесконечного подмножества в $\mathrm{P}$.

**Лемма 16.16.** Если существует P-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Но тогда $L$ само является бесконечным подмножеством $L$, лежащим в $\mathrm{P}$,
что противоречит P-иммунности. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-immune. Например, SAT имеет
бесконечное подмножество в $\mathrm{P}$: формулы вида
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i)$$
всегда выполнимы и распознаются за полиномиальное время. Следовательно, SAT не P-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.17. Исследовательский шаг: P-bi-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-bi-immune язык?

**Определение (P-bi-immune).** Бесконечный язык $L$ называется P-bi-immune, если
$L$ и $\overline{L}$ являются P-immune.

**Лемма 16.17.** Если существует P-bi-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Так как $\mathrm{P}$ замкнут по дополнению, имеем $\overline{L}\in\mathrm{P}$.
Но тогда и $L$, и $\overline{L}$ содержат бесконечные подмножества в $\mathrm{P}$
(они сами), что противоречит P-immune. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-bi-immune. Для SAT есть
бесконечное подмножество в $\mathrm{P}$, например формулы
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i),$$
а для $\overline{\mathrm{SAT}}$ есть бесконечное подмножество в $\mathrm{P}$, например
$$\bigwedge_{i=1}^m (x_i\land\neg x_i).$$
Следовательно, SAT не P-bi-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.18. Исследовательский шаг: NP-hard P-selective

**Вопрос ("А что если...?").** Что если существует P-selective язык, NP-трудный по $\le_m^p$?

**Определение (P-selective).** Язык $S$ называется P-selective, если существует
детерминированная полиномиальная функция $s(x,y)$, возвращающая $x$ или $y$, такая что
если $x\in S$ или $y\in S$, то $s(x,y)\in S$.

**Лемма 16.18.** Если существует P-selective язык $S$ и $\mathrm{SAT}\le_m^p S$,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $f$ - полиномиальная редукция SAT к $S$ и $s$ - селектор для $S$.
Для формулы $\varphi$ последовательно фиксируем переменные. На шаге $i$ строим
$\varphi_0=\varphi\upharpoonright(x_i=0)$ и $\varphi_1=\varphi\upharpoonright(x_i=1)$,
вычисляем $f(\varphi_0), f(\varphi_1)$ и берём
$$w:=s(f(\varphi_0), f(\varphi_1)).$$
Если $w=f(\varphi_0)$, ставим $x_i:=0$, иначе $x_i:=1$ (если оба равны, выбор не важен).
Если $\varphi$ выполнима, то хотя бы одна из $\varphi_0,\varphi_1$ выполнима,
значит соответствующий образ лежит в $S$, и селектор выбирает выполнимую ветвь.
Индукцией после всех шагов получаем удовлетворяющее присваивание, которое проверяем.
Если $\varphi$ невыполнима, любая ветвь приведёт к ложному присваиванию, проверка отвергнет.
Время полиномиально. Значит $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** P-selective само по себе не означает трудность.
Например, язык $L=\{x: x_1=1\}$ находится в $\mathrm{P}$ и P-selective,
но не NP-труден (если $\mathrm{P}\ne\mathrm{NP}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.19. Исследовательский шаг: SAT в coRP => NP = coNP

**Вопрос ("А что если...?").** Что если SAT решается в coRP - следует ли $\mathrm{NP}=\mathrm{coNP}$?

**Определение (coRP).** Язык $L\in\mathrm{coRP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]=1,\quad x\notin L\Rightarrow \Pr[A(x)=1]\le 1/2.$$

**Лемма 16.19.** Если $\mathrm{SAT}\in\mathrm{coRP}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* (1) $\mathrm{coRP}\subseteq\mathrm{coNP}$: если $L\in\mathrm{coRP}$,
то $\overline{L}\in\mathrm{RP}$, а $\mathrm{RP}\subseteq\mathrm{NP}$ (угадать случайные биты).
Значит $L\in\mathrm{coNP}$.

(2) coRP замкнут по детерминированным $\le_m^p$-редукциям: если $L\le_m^p A$ и
$A\in\mathrm{coRP}$, то алгоритм для $A$ на входе $f(x)$ даёт корректную coRP
процедуру для $L$.

Так как SAT NP-полон, из $\mathrm{SAT}\in\mathrm{coRP}$ получаем
$\mathrm{NP}\subseteq\mathrm{coRP}\subseteq\mathrm{coNP}$, значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к усилению.** coRP само по себе не означает NP-трудность.
Например, язык $\Sigma^*$ лежит в $\mathrm{coRP}\cap\mathrm{P}$ и не может быть
NP-трудным по $\le_m^p$, иначе следовало бы $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.20. Исследовательский шаг: точный подсчет решений SAT

**Вопрос ("А что если...?").** Что если #SAT вычислима за полиномиальное время?

**Определение (#SAT).** Для CNF-формулы $\varphi$ функция $\#\mathrm{SAT}(\varphi)$
равна числу удовлетворяющих присваиваний.

**Лемма 16.20.** Если $\#\mathrm{SAT}$ вычислима за полиномиальное время,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* На входе формулы $\varphi$ вычисляем $\#\mathrm{SAT}(\varphi)$.
Если значение больше нуля, то $\varphi$ выполнима, иначе нет.
Это решает SAT за полиномиальное время, значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить точный подсчет на подсчет по модулю 2.
Формула
$$\psi=(x_1\lor x_2)\land(\neg x_1\lor \neg x_2)$$
имеет ровно 2 решения (четность 0), а формула
$$\theta=(x_1\land\neg x_1)$$
имеет 0 решений (четность 0). Следовательно, знание $\#\mathrm{SAT}(\cdot)\bmod 2$
не позволяет решать SAT в общем случае.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - прямое вычисление числа решений).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.21. Исследовательский шаг: FPRAS для #SAT

**Вопрос ("А что если...?").** Что если существует FPRAS для #SAT?

**Определение (FPRAS для #SAT).** Рандомизированный алгоритм $A$ — FPRAS для
$\#\mathrm{SAT}$, если для любой формулы $\varphi$, параметров $\varepsilon\in(0,1)$ и
$\delta\in(0,1)$ он работает за $\mathrm{poly}(|\varphi|,1/\varepsilon,\log(1/\delta))$ и
с вероятностью $\ge 1-\delta$ возвращает число $\widetilde{N}$, такое что
$$ (1-\varepsilon)\#\mathrm{SAT}(\varphi)\le \widetilde{N}\le (1+\varepsilon)\#\mathrm{SAT}(\varphi). $$

**Лемма 16.21.** Если для $\#\mathrm{SAT}$ существует FPRAS, то $\mathrm{SAT}\in\mathrm{RP}$,
следовательно $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* Используем саморедукцию поиска (шаг 16.3), заменив вызовы SAT
на FPRAS для $\#\mathrm{SAT}$.

Пусть $\varphi$ над $n$ переменными. Для $i=1..n$ рассмотрим
$\varphi_0:=\varphi\upharpoonright(x_i=0)$ и $\varphi_1:=\varphi\upharpoonright(x_i=1)$ и
запустим FPRAS на обеих формулах с $\varepsilon=1/2$ и $\delta:=1/(10n)$. Если обе оценки равны 0,
отвергаем; иначе выбираем ветвь с ненулевой оценкой и продолжаем. В конце получаем присваивание $a$
и детерминированно проверяем $\varphi(a)=1$; принимаем тогда и только тогда, когда проверка проходит.

Если $\varphi$ невыполнима, то проверка никогда не пройдёт, значит мы всегда отвергаем.
Если $\varphi$ выполнима, то при успешных вызовах FPRAS нулевая оценка появляется тогда и только тогда,
когда соответствующая ветвь имеет 0 решений, поэтому мы всегда можем выбрать ветвь с хотя бы одним решением
и дойти до удовлетворяющего $a$. По объединённой вероятности все $2n$ вызовов успешны с вероятностью
$\ge 1-2n\delta\ge 4/5$, значит принимаем с вероятностью $\ge 1/2$.
Итак, $\mathrm{SAT}\in\mathrm{RP}$, а по Лемме 16.14 $\mathrm{NP}=\mathrm{RP}$. $\square$

**Контрпример к усилению.** Знание $\#\mathrm{SAT}(\varphi)\bmod 2$ не решает SAT
(см. контрпример в шаге 16.20), значит «аппроксимация» без гарантии
мультипликативной точности может быть недостаточна.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.22. Исследовательский шаг: SAT в ZPP => NP = ZPP

**Вопрос ("А что если...?").** Что если SAT решается в ZPP - следует ли равенство $\mathrm{NP}=\mathrm{ZPP}$?

**Определение (ZPP).** $\mathrm{ZPP}=\mathrm{RP}\cap\mathrm{coRP}$; эквивалентно,
это класс языков, распознаваемых рандомизированными алгоритмами ожидаемого
полиномиального времени без ошибок (Las Vegas).

**Лемма 16.22.** Если $\mathrm{SAT}\in\mathrm{ZPP}$, то $\mathrm{NP}=\mathrm{ZPP}$.

*Доказательство.* Так как SAT NP-полна и ZPP замкнут по детерминированным
$\le_m^p$-редукциям, из $\mathrm{SAT}\in\mathrm{ZPP}$ следует
$\mathrm{NP}\subseteq\mathrm{ZPP}$. С другой стороны, $\mathrm{ZPP}\subseteq\mathrm{RP}\subseteq\mathrm{NP}$.
Следовательно, $\mathrm{NP}=\mathrm{ZPP}$. $\square$

**Вывод/провал.** Равенство $\mathrm{NP}=\mathrm{ZPP}$ само по себе не даёт
$\mathrm{P}=\mathrm{NP}$ без дерэндомизации $\mathrm{ZPP}=\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.23. Исследовательский шаг: SAT почти всюду в P

**Вопрос ("А что если...?").** Что если SAT решается за полиномиальное время на всех достаточно больших длинах входа?

**Определение (a.e.-P).** Язык $L$ называется *почти всюду* в $\mathrm{P}$, если
существует $n_0$ и полиномиальный алгоритм $A$, такой что для всех $x$ с $|x|\ge n_0$:
$A(x)$ решает принадлежность $x\in L$.

**Лемма 16.23.** Если SAT почти всюду в $\mathrm{P}$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ корректен для всех длины $\ge n_0$.
Для длин $<n_0$ заранее вычислим ответы (это конечное множество строк) и
зашьем их в алгоритм. Тогда получаем полиномиальный алгоритм, решающий SAT на всех входах.
Следовательно, $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Условие "в $\mathrm{P}$ на бесконечном числе длин" недостаточно.
Пусть $H\in\mathrm{DTIME}(2^n)\setminus\mathrm{P}$ (существует по теореме иерархии по времени).
Определим
$$L:=\{z:\ |z|\ \text{четно}\}\ \cup\ \{1^{|x|}0x:\ x\in H\}.$$
Тогда $L$ тривиален на всех четных длинах (значит "легок" на бесконечно многих длинах),
но $H\le_m^p L$ по редукции $x\mapsto 1^{|x|}0x$ (длина $2|x|+1$), поэтому из $L\in\mathrm{P}$
следовало бы $H\in\mathrm{P}$ — противоречие. Значит условие "на бесконечно многих длинах" не даёт $\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.24. Исследовательский шаг: SAT в RP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в RP, используя лишь $O(\log n)$ случайных бит?

**Определение (RP$_{\log}$).** Язык $L\in\mathrm{RP}_{\log}$, если существует RP-машина,
которая на входах длины $n$ использует не более $c\log n$ случайных битов.

**Лемма 16.24.** Если $\mathrm{SAT}\in\mathrm{RP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ - RP-алгоритм для SAT с $m(n)\le c\log n$ случайных битов.
Для входа $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$ случайные строки $r$ и
запустим $A(\varphi,r)$.
Если $\varphi$ невыполнима, то $A$ никогда не принимает, значит мы отвергаем.
Если $\varphi$ выполнима, существует хотя бы один $r$ с принятием, значит мы принимаем.
Время полиномиально. $\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
занимает $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий RP.
Следовательно, ограничение $O(\log n)$ существенно.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.25. Исследовательский шаг: NP-полный язык в io-P

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на бесконечно многих длинах входа, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (io-P).** Язык $L$ принадлежит io-P, если существует полиномиальный
алгоритм $A$ и бесконечное множество длин $N\subseteq\mathbb{N}$, такое что для всех
$n\in N$ и всех строк $x$ длины $n$ выполняется $A(x)=1\iff x\in L$.

**Лемма 16.25 (контрпример).** Существует NP-полный язык $L'$ такой, что $L'\in$ io-P.

*Доказательство.* Пусть $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$ 
Тогда любая строка из $L'$ имеет длину $n^2$. Редукция $x\mapsto x0^{n^2-n}$
полиномиальна, значит $L'$ NP-полон. Для любой длины $m$, не являющейся квадратом,
в $L'$ нет строк, поэтому алгоритм, всегда отвергающий на таких длинах,
решает $L'$ за полиномиальное время. Неквадратных длин бесконечно много, значит
$L'\in$ io-P. Следовательно, условие "NP-полный и легок на бесконечно многих длинах"
не влечет $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.26. Исследовательский шаг: NP-полный язык легок на плотности 1 длин

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на множестве длин плотности 1, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (плотность 1 по длинам).** Множество длин $N\subseteq\mathbb{N}$ имеет
плотность 1, если
$$\lim_{m\to\infty} \frac{|N\cap\{1,\dots,m\}|}{m}=1.$$
Язык $L$ называется *легким на длинах из $N$*, если существует полиномиальный
алгоритм $A$, корректный для всех строк $x$ с $|x|\in N$.

**Лемма 16.26 (контрпример).** Существует NP-полный язык $L'$ и множество длин $N$
плотности 1, такое что $L'$ легок на длинах из $N$.

*Доказательство.* Положим $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{n^2-n}$ полиномиальна, значит $L'$ NP-полон.
Любая строка из $L'$ имеет длину квадрат; на длинах, не являющихся квадратами,
$L'$ пуст, и алгоритм, всегда отвергающий, корректен. Пусть $N$ - множество
неквадратных длин. Тогда $|N\cap\{1,\dots,m\}|=m-\lfloor\sqrt{m}\rfloor$, поэтому
$N$ имеет плотность 1. Значит $L'$ легок на длинах из $N$. $\square$

**Вывод/провал.** Свойство "NP-полный язык легок на плотности 1 длин" слишком слабое:
оно уже достигается простой паддинг-конструкцией и не ведет к $\mathrm{P}=\mathrm{NP}$
без дополнительных идей.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.27. Исследовательский шаг: SAT в BPP => SAT в P/poly

**Вопрос ("А что если...?").** Если SAT решается в BPP, следует ли из этого
существование полиномиальных схем?

**Лемма 16.27 (Adleman).** Если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{SAT}\in\mathrm{P/poly}$.

*Доказательство.* Пусть $A$ - BPP-алгоритм для SAT, использующий $m(n)$ случайных битов.
Усилим его повторением до ошибки $\varepsilon=2^{-2n}$, получив алгоритм $A'$
(время и число битов остаются полиномиальными).
Для фиксированной длины $n$ обозначим через $B_x$ множество случайных строк $r$
длины $m(n)$, на которых $A'(x,r)$ ошибается. Тогда $|B_x|\le \varepsilon 2^{m(n)}$.
Объединение по всем $x\in\{0,1\}^n$ имеет размер
$$\left|\bigcup_{x} B_x\right|\le 2^n\cdot \varepsilon 2^{m(n)}<2^{m(n)},$$
поэтому существует строка $r_n$, на которой $A'$ корректен для всех входов длины $n$.
Жестко зашив $r_n$ в схему, получаем семейство схем полиномиального размера,
решающее SAT на каждой длине $n$. Значит $\mathrm{SAT}\in\mathrm{P/poly}$. $\square$

**Вывод/провал.** Из SAT $\in\mathrm{BPP}$ следует лишь неравномерность
($\mathrm{SAT}\in\mathrm{P/poly}$) и, по Karp-Lipton, коллапс PH до $\Sigma_2^p$;
это не дает $\mathrm{P}=\mathrm{NP}$ без дополнительных идей о униформности.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.28. Исследовательский шаг: NP ⊆ AC^0?

**Вопрос ("А что если...?").** Что если весь $\mathrm{NP}$ лежит в $\mathrm{AC}^0$?

**Лемма 16.28 (контрпример).** $\mathrm{NP}\not\subseteq\mathrm{AC}^0$.

*Доказательство.* Функция $\mathrm{PARITY}$ принадлежит $\mathrm{P}\subseteq\mathrm{NP}$.
По разделу 11.3, $\mathrm{PARITY}\notin\mathrm{AC}^0$.
Значит существует язык из $\mathrm{NP}$, не лежащий в $\mathrm{AC}^0$, то есть
$\mathrm{NP}\not\subseteq\mathrm{AC}^0$. $\square$

**Вывод/провал.** Утверждение $\mathrm{NP}\subseteq\mathrm{AC}^0$ слишком сильное:
оно уже опровергается классическими нижними оценками для $\mathrm{AC}^0$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о неравномерных схемах).
- *Natural proofs:* не препятствует; нижние оценки для $\mathrm{AC}^0$ известны.
- *Algebrization:* неприменимо.

### 16.29. Исследовательский шаг: средняя легкость NP-полного языка

**Вопрос ("А что если...?").** Если NP-полный язык решается полиномиально
на почти всех входах каждой длины (равномерно по $\{0,1\}^n$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (ошибка на длине $n$).** Алгоритм $A$ имеет ошибку $\varepsilon(n)$ на языке $L$,
если $\Pr_{x\in\{0,1\}^n}[A(x)\ne L(x)]\le \varepsilon(n)$.

**Лемма 16.29 (контрпример).** Существует NP-полный язык $L'$ и полиномиальный алгоритм $A$,
для которого ошибка на длине $n$ не превосходит $2^{-\Omega(n)}$.

*Доказательство.* Возьмем $p(m)=m^2$ и определим
$$L' = \{x0^{p(|x|)} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{p(|x|)}$ полиномиальна, значит $L'$ NP-полон.
Если длина $n$ имеет вид $n=m+p(m)=m+m^2$, то в $\{0,1\}^n$ не более $2^m$ строк из $L'$,
поэтому доля принимающих не превосходит $2^m/2^{m+m^2}=2^{-m^2}=2^{-\Theta(n)}$.
Если длина $n$ не такого вида, то $L'\cap\{0,1\}^n=\varnothing$.
Алгоритм $A$, всегда отвергающий, имеет ошибку не более $2^{-\Theta(n)}$ на каждой длине.
$\square$

**Вывод/провал.** Наличие NP-полного языка, легкого на почти всех входах каждой длины,
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается простым паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг и оценка доли сохраняются с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.30. Исследовательский шаг: NP-полный язык в субэкспоненциальном времени?

**Вопрос ("А что если...?").** Если существует NP-полный язык, решаемый за
время $2^{n^\varepsilon}$ (для некоторого $0<\varepsilon<1$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Лемма 16.30 (контрпример).** Существует NP-полный язык $L'$ в
$\mathrm{DTIME}(2^{O(\sqrt{n})})$ (то есть за субэкспоненциальное время).

*Доказательство.* Определим
$$L' = \{x0^{|x|^2-|x|} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{|x|^2-|x|}$ полиномиальна, значит $L'$ NP-полон.
Для входа длины $n$ проверим, является ли $n$ квадратом $m^2$ и что последние
$n-m$ битов нулевые; иначе отвергаем. Если $n=m^2$, берём первые $m$ битов как $x$
и решаем SAT полным перебором за $2^{O(m)}=2^{O(\sqrt{n})}$.
Следовательно, $L'\in\mathrm{DTIME}(2^{O(\sqrt{n})})$. $\square$

**Вывод/провал.** Наличие NP-полного языка в субэкспоненциальном времени
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.31. Исследовательский шаг: p-bounded proof system?

**Вопрос ("А что если...?").** Что если существует полиномиально ограниченная
пропозициональная система доказательств?

**Определение (p-bounded).** Доказательная система $P$ (в смысле Cook-Reckhow)
p-bounded, если существует полином $p$, что каждая тавтология $\varphi$
имеет $P$-доказательство длины $\le p(|\varphi|)$.

**Лемма 16.31.** Если существует p-bounded доказательная система, то
$\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $P$ p-bounded. НП-машина по входу $\varphi$
угадывает строку длины $\le p(|\varphi|)$ и проверяет, что это корректное
$P$-доказательство $\varphi$ (проверка полиномиальна по определению proof system).
Значит $\mathrm{TAUT}\in\mathrm{NP}$. Так как $\mathrm{TAUT}$ coNP-полна,
получаем $\mathrm{coNP}\subseteq\mathrm{NP}$, и следовательно
$\mathrm{NP}=\mathrm{coNP}$. $\square$

**Вывод/провал.** p-boundedness: чрезвычайно сильное требование:
оно сразу влечет коллапс $\mathrm{NP}$ и $\mathrm{coNP}$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о proof systems).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.32. Исследовательский шаг: SAT в BPP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в BPP, используя лишь
$O(\log n)$ случайных битов?

**Определение (BPP$_{\log}$).** Язык $L\in\mathrm{BPP}_{\log}$, если существует
BPP-алгоритм, использующий не более $c\log n$ случайных битов на входах длины $n$.

**Лемма 16.32.** Если $\mathrm{SAT}\in\mathrm{BPP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ — BPP-алгоритм для SAT, использующий $m(n)\le c\log n$
случайных битов. Для формулы $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$
случайные строки $r$ и вычислим долю принятий $A(\varphi,r)$.
Если $\varphi$ выполнима, эта доля $\ge 2/3$, иначе $\le 1/3$.
Сравнение с порогом $1/2$ дает детерминированное решение за полиномиальное время.
$\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий BPP.

**Барьер-чек.**
- *Релятивизация:* да (перебор случайных строк сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.33. Исследовательский шаг: SAT разрежен?

**Вопрос ("А что если...?").** Может ли SAT быть разреженным языком?

**Определение (sparse).** Язык $L$ разрежен, если существует полином $p$, что
$|L\cap\Sigma^{\le n}|\le p(n)$ для всех $n$.

**Лемма 16.33 (контрпример).** SAT не является разреженным языком.

*Доказательство.* Для каждого $m$ и каждого присваивания $a\in\{0,1\}^m$ рассмотрим формулу
$$\varphi_a:=\bigwedge_{i=1}^m \ell_i,$$
где $\ell_i=x_i$ при $a_i=1$ и $\ell_i=\neg x_i$ при $a_i=0$.
Каждая $\varphi_a$ выполнима (единственным образом) и имеет длину $\mathrm{poly}(m)$
(при любом стандартном кодировании входа).
Формулы $\varphi_a$ различны, поэтому среди строк длины $\le \mathrm{poly}(m)$ есть как минимум $2^m$
выполнимых формул. Так как $2^m$ перерастает любой полином от $\mathrm{poly}(m)$,
SAT не разрежен. $\square$

**Вывод/провал.** Попытка использовать разреженность SAT как путь к $\mathrm{P}\ne\mathrm{NP}$
обрывается на элементарном счете: SAT слишком плотен.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированном языке).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.34. Исследовательский шаг: SAT с логарифмическими сертификатами

**Вопрос ("А что если...?").** Если SAT имеет сертификаты длины $O(\log n)$,
следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (NP$_{\log}$).** Язык $L\in\mathrm{NP}_{\log}$, если существует
полиномиальный верификатор $V(x,y)$ и константа $c$ такие, что для всех $x$:
$$x\in L\iff \exists y\in\{0,1\}^{\le c\log|x|}: V(x,y)=1.$$

**Лемма 16.34.** Если $\mathrm{SAT}\in\mathrm{NP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть для SAT существует верификатор с сертификатом длины
не более $c\log n$. Тогда на входе длины $n$ можно перебрать все
$2^{c\log n}=n^c$ сертификатов $y$ и проверить $V(x,y)$.
Это детерминированное полиномиальное время. $\square$

**Контрпример к усилению.** При длине сертификата $\Theta(n)$ полный перебор
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий NP.

**Барьер-чек.**
- *Релятивизация:* да (перебор сертификатов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.35. Исследовательский шаг: односторонние функции

**Вопрос ("А что если...?").** Что если существуют односторонние функции?

**Определение (OWF).** Функция $f:\{0,1\}^*\to\{0,1\}^*$ односторонняя, если
она полиномиально вычислима и для любого полиномиального алгоритма $A$
вероятность $\Pr_{x\leftarrow\{0,1\}^n}[f(A(f(x)))=f(x)]$ пренебрежимо мала.

**Лемма 16.35.** Если существуют OWF, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим, что $\mathrm{P}=\mathrm{NP}$. Зафиксируем
полиномиально вычислимую $f$. Для данного $y$ будем по битам восстанавливать
преобраз: на шаге $i$ проверяем, существует ли строка $x$ с заданным префиксом
длины $i$ такая, что $f(x)=y$. Это NP-вопрос, значит при $\mathrm{P}=\mathrm{NP}$
решается за полиномиальное время. После $O(|y|)$ шагов получаем $x$ с $f(x)=y$.
Следовательно, $f$ инвертируема в полиномиальное время на всех $y$ из образа,
противоречие односторонности. Значит существование OWF влечет $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Вывод/провал.** Доказать существование OWF достаточно для $\mathrm{P}\ne\mathrm{NP}$,
но это не проще исходной задачи.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулом).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.36. Исследовательский шаг: PRG с логарифмическим seed

**Вопрос ("А что если...?").** Что если существует PRG с seed длины $O(\log n)$,
который обманывает все BPP-алгоритмы?

**Определение (PRG для BPP).** Семейство $g_n:\{0,1\}^{s(n)}\to\{0,1\}^{m(n)}$
c $s(n)=O(\log n)$ и $m(n)=\mathrm{poly}(n)$, вычислимое за полиномиальное время,
такое что для любого полиномиального алгоритма $A$ и всех $n$:
$$\left|\Pr[A(g_n(U_{s(n)}))=1]-\Pr[A(U_{m(n)})=1]\right|\le 1/10.$$

**Лемма 16.36.** Если такой PRG существует, то $\mathrm{BPP}=\mathrm{P}$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$ и $A$ — его вероятностный полиномиальный
алгоритм с $m(n)$ случайными битами и ошибкой $\le 1/3$.
Для входа $x$ длины $n$ переберем все $2^{s(n)}=\mathrm{poly}(n)$ seed'ы $r$,
посчитаем долю принятий $A(x,g_n(r))$ и сравним с порогом $1/2$.
Так как PRG сохраняет вероятность с точностью $1/10$, то при $x\in L$ среднее
$\ge 2/3-1/10>1/2$, а при $x\notin L$ среднее $\le 1/3+1/10<1/2$.
Получаем детерминированный полиномиальный алгоритм. $\square$

**Контрпример к усилению.** Если $s(n)=\Theta(n)$, то полный перебор seed'ов
занимает $2^{\Theta(n)}$ времени и доказательство не работает.

**Барьер-чек.**
- *Релятивизация:* да (перебор seed'ов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.
