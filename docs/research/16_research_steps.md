# P vs NP — исследовательские шаги (16.x)

Этот подноутбук содержит короткие "А что если…?" шаги и контрпримеры.
Главный файл остаётся `P_vs_NP.md`.

[Открыть главный ноутбук](../../P_vs_NP.md)

### 16.3. Исследовательский шаг: decision vs search для SAT

**Вопрос («А что если…?»).** Может ли SAT решаться в полиномиальное время,
а задача поиска удовлетворяющего присваивания оставаться существенно труднее?

**Определение (SAT‑SEARCH).** По входу CNF‑формулы $\varphi$: если $\varphi$ выполнима,
выдать удовлетворяющее присваивание; иначе вывести $\bot$.

**Лемма 16.3.** Существует полиномиальный алгоритм, который решает SAT‑SEARCH,
используя $O(n)$ вызовов решения SAT (где $n$ — число переменных).
В частности, если $\mathrm{SAT}\in\mathrm{P}$, то SAT‑SEARCH $\in\mathrm{FP}$.

*Доказательство.* Сначала одним вызовом проверяем, выполнима ли $\varphi$.
Если нет — возвращаем $\bot$.
Иначе последовательно фиксируем переменные: для $i=1..n$ проверяем выполнимость
$\varphi\upharpoonright (x_i=0)$. Если выполнима — ставим $x_i:=0$,
иначе $x_i:=1$ (при этом $\varphi\upharpoonright (x_i=1)$ обязана быть выполнима,
иначе исходная $\varphi$ невыполнима). Индукцией по $i$ сохраняется выполнимость,
и после $n$ шагов получаем удовлетворяющее присваивание.
Время — $O(n)$ вызовов SAT и полиномиальные подстановки. $\square$

**Вывод.** Попытка разделить P и NP через «decision проще, чем search»
для SAT не работает: SAT саморедуцируем.

**Барьер‑чек.**
- *Релятивизация:* да, алгоритм оракульный (тот же аргумент для $\mathrm{SAT}^A$).
- *Natural proofs:* неприменимо (нет схемных нижних оценок).
- *Algebrization:* неприменимо (нет алгебраизации/полиномов; чисто комбинаторика).

### 16.4. Исследовательский шаг: sparse NP‑полный ⇒ P=NP

**Вопрос («А что если…?»).** Что если у NP есть разреженный (sparse) NP‑полный язык?

**Определение (sparse).** Язык $S$ разрежен, если существует полином $p$, что
$|S\cap \Sigma^{\le m}|\le p(m)$ для всех $m$.

**Лемма 16.4 (Мэхэни).** Если существует разреженный NP‑полный язык
относительно $\le_m^p$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $S$ sparse и $\mathrm{SAT}\le_m^p S$ через $f$.
Зафиксируем полином $p$ для sparsity и полином $q$, ограничивающий длину $f(\psi)$
на формулах $\psi$ размера $\mathrm{poly}(|\varphi|)$.
Положим $K:=p(q(|\varphi|))$. Построим алгоритм SAT.

Поддерживаем список $L$ формул с инвариантом:
(i) $|L|\le K$, (ii) если $\varphi$ выполнима, то выполнима хотя бы одна формула из $L$.
Старт: $L=\{\varphi\}$. Для переменной $x_i$ каждую $\psi\in L$ заменяем
на $\psi\upharpoonright(x_i=0)$ и $\psi\upharpoonright(x_i=1)$,
получая $L'$, затем применяем «подрезку».
(Если нужно оставаться в CNF, используем стандартное полиномиальное Tseitin‑кодирование дизъюнкций.)

**Pruning‑лемма.** Для списка $\varphi_1,\dots,\varphi_k$ (где $k> K$) можно за полиномиальное
время удалить хотя бы одну формулу, сохранив (ii).

Доказательство pruning: положим $\psi_i:=\varphi_1\lor\cdots\lor\varphi_i$ и $y_i:=f(\psi_i)$.
- Если найдены $i<j$ с $y_i=y_j$, то $\psi_i$ и $\psi_j$ имеют одинаковую выполнимость,
  поэтому удаление $\varphi_{i+1},\dots,\varphi_j$ сохраняет (ii).
- Иначе все $y_i$ различны. Тогда среди $\psi_i$ выполнимых $\le K$ (иначе в $S$ было бы
  $>K$ различных строк). Выполнимые $\psi_i$ образуют суффикс, значит при наличии
  выполнимой формулы она среди последних $K$; удаляем первые $k-K$.

Повторяя pruning, держим $|L|\le K$. После обработки всех переменных все формулы в $L$
константны; проверяем, есть ли истинная. Это полиномиально, значит $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент остаётся верным с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.5. Исследовательский шаг: p‑bounded резолюция?

**Вопрос («А что если…?»).** Может ли резолюция быть p‑bounded для всех
невыполнимых CNF‑формул?

**Лемма 16.5.** Если резолюция p‑bounded, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* При p‑bounded резолюции каждая невыполнимая CNF
имеет полиномиальную рефутацию. Проверка корректности резолюционного вывода
полиномиальна, значит $\mathrm{UNSAT}\in\mathrm{NP}$.
Так как $\mathrm{UNSAT}$ coNP‑полна, получаем $\mathrm{coNP}\subseteq\mathrm{NP}$,
а значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к предпосылке.** Формулы $\mathrm{PHP}^{n}_{n+1}$ требуют
экспоненциальных резолюционных рефутаций (Теорема 15.2),
так что резолюция не является p‑bounded в общем случае.

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированной proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.6. Исследовательский шаг: резолюция vs CP (p‑симуляция)

**Вопрос («А что если…?»).** Может ли резолюция p‑симулировать систему Cutting Planes (CP)?

**Лемма 16.6.** Резолюция не p‑симулирует CP.

*Доказательство (контрпример).* Предположим, что резолюция p‑симулирует CP.
Тогда любую CP‑рефутацию размера $\mathrm{poly}(n)$ можно преобразовать
в резолюционную рефутацию размера $\mathrm{poly}(n)$.
По Теореме 15.8 формулы $\mathrm{PHP}^{n}_{n+1}$ имеют полиномиальные CP‑рефутации,
а по Теореме 15.2 любая резолюционная рефутация $\mathrm{PHP}^{n}_{n+1}$
имеет экспоненциальный размер. Противоречие. $\square$

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о конкретных proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.7. Исследовательский шаг: приближение MAX‑3SAT

**Вопрос («А что если…?»).** Что если существует полиномиальный алгоритм,
который отличает выполнимые 3CNF от формул, где нельзя удовлетворить
более чем $(1-\varepsilon)$ долю клауз (для некоторого константного $\varepsilon>0$)?

**Определение (GAP‑3SAT$_\varepsilon$).** Вход — 3CNF $\varphi$.
YES: $\varphi$ выполнима. NO: любая подстановка удовлетворяет
не более $(1-\varepsilon)$ доли клауз.

**Лемма 16.7.** Если для некоторого $\varepsilon>0$ задача GAP‑3SAT$_\varepsilon$
решается за полиномиальное время, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* По теореме PCP (Раздел 16.2) существует константа
$\varepsilon>0$, для которой GAP‑3SAT$_\varepsilon$ NP‑трудна.
Если бы она решалась за полиномиальное время, то решалась бы SAT,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* не обязано релятивизировать (PCP использует аритметизацию).
- *Natural proofs:* неприменимо (это не схемные нижние оценки).
- *Algebrization:* не ясно; доказательство PCP не сводится к чистой алгебризации.

### 16.8. Исследовательский шаг: NP‑ и coNP‑полнота одного языка

**Вопрос («А что если…?»).** Может ли существовать язык $L$, который
NP‑полон и coNP‑полон (по $\le_m^p$)?

**Лемма 16.8.** Если существует язык, который одновременно NP‑полон и coNP‑полон
(по $\le_m^p$), то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $L$ — такой язык. Тогда $L\in\mathrm{NP}\cap\mathrm{coNP}$.
Для любого $A\in\mathrm{NP}$ существует полиномиальная редукция $f$ такая, что
$x\in A \iff f(x)\in L$. Тогда
$$x\in A^c \iff f(x)\in L^c.$$
Поскольку $L\in\mathrm{coNP}$, имеем $L^c\in\mathrm{NP}$, значит $A^c\in\mathrm{NP}$,
то есть $A\in\mathrm{coNP}$. Следовательно, $\mathrm{NP}\subseteq\mathrm{coNP}$.
Симметрично, из coNP‑полноты $L$ и того, что $L\in\mathrm{NP}$, получаем
$\mathrm{coNP}\subseteq\mathrm{NP}$. Итак, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.9. Исследовательский шаг: SAT ≤ UNSAT?

**Вопрос («А что если…?»).** Может ли SAT полиномиально сводиться к UNSAT?

**Лемма 16.9.** Если $\mathrm{SAT}\le_m^p\mathrm{UNSAT}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $f$ — редукция SAT к UNSAT.
Тогда SAT принадлежит coNP (coNP замкнут по $\le_m^p$‑редукциям).
Так как SAT NP‑полна, получаем $\mathrm{NP}\subseteq\mathrm{coNP}$.
Берём дополнения: $\mathrm{coNP}\subseteq\mathrm{NP}$. Следовательно, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.


### 16.10. Исследовательский шаг: Unique-SAT и рандомизация

**Вопрос («А что если…?»).** Что если Unique-SAT решается за полиномиальное время — следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (Unique-SAT, promise).** Вход: CNF‑формула $\varphi$ над $n$ переменными.
YES: $\varphi$ имеет ровно одно удовлетворяющее присваивание.
NO: $\varphi$ не имеет удовлетворяющих присваиваний.
(Иные случаи не обязаны обрабатываться корректно.)

**Лемма 16.10 (Valiant-Vazirani).** Существует вероятностная полиномиальная редукция,
которая по формуле $\varphi$ строит CNF‑формулу $\varphi'$ такую, что:
- если $\varphi$ невыполнима, то $\varphi'$ невыполнима всегда;
- если $\varphi$ выполнима, то с вероятностью $\ge 1/(8n)$ $\varphi'$ имеет ровно одно решение.

В частности, если Unique-SAT $\in\mathrm{P}$, то $\mathrm{SAT}\in\mathrm{RP}$.

*Доказательство.* Пусть $S\subseteq\{0,1\}^n$ — множество решений $\varphi$, $s=|S|$.
Выбираем $m\in\{1,\dots,n{+}1\}$, случайную попарно независимую хэш‑функцию
$h:\{0,1\}^n\to\{0,1\}^m$ (например, $h(x)=Ax\oplus b$ над $\mathbb{F}_2$)
и случайный $t\in\{0,1\}^m$. Строим
$$\varphi' := \varphi\land (h(x)=t),$$
кодируя $m$ линейных уравнений в CNF с полиномиальным ростом (кодирование Тсейтина).
Если $\varphi$ невыполнима, то $\varphi'$ тоже.

Пусть $s\ge 1$. Существует $m$ такое, что $2^{m-2}< s\le 2^{m-1}$.
Положим $Z=|S\cap h^{-1}(t)|=\sum_{x\in S} I_x$, где $I_x=[h(x)=t]$.
Тогда $\mu=\mathbb{E}[Z]=s/2^m\in(1/4,1/2]$ и по попарной независимости
$$\mathbb{E}[Z(Z-1)]=\sum_{x\ne y}\Pr[I_x=I_y=1]=\frac{s(s-1)}{2^{2m}}\le \mu^2.$$
Так как при $Z\ge 2$ выполнено $Z(Z-1)\ge Z$, получаем
$$\Pr[Z=1]\ge \mu-\mathbb{E}[Z(Z-1)]\ge \mu-\mu^2\ge 3/16.$$
Следовательно, для «правильного» $m$ вероятность уникальности $\ge 3/16$.
При случайном $m$ получаем успех $\ge 1/(8n)$ (с запасом).
Повторением (усилением) получаем RP-алгоритм при наличии решателя Unique-SAT. $\square$

**Вывод/провал.** Unique-SAT $\in\mathrm{P}$ даёт лишь $\mathrm{SAT}\in\mathrm{RP}$.
Чтобы получить $\mathrm{P}=\mathrm{NP}$, нужна дерэндомизация (например, $\mathrm{RP}=\mathrm{P}$)
или детерминированная «изоляция» решений.

**Барьер‑чек.**
- *Релятивизация:* да (редукция комбинаторная и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо/неочевидно.

### 16.11. Исследовательский шаг: NP ⊆ BPP ⇒ коллапс PH

**Вопрос («А что если…?»).** Что если SAT (или весь NP) решается в BPP — следует ли коллапс полиномиальной иерархии?

**Определение (BPP).** Язык $L\in\mathrm{BPP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 2/3,\quad x\notin L\Rightarrow \Pr[A(x)=0]\ge 2/3.$$

**Лемма 16.11.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то $\mathrm{PH}\subseteq\mathrm{BPP}$.
(В частности, если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{PH}$ коллапсирует в BPP.)

*Доказательство.* Сначала покажем $\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}$.
Пусть $M^{O}$ — BPP‑машина, делающая не более $q(n)$ запросов к оракулу $O\in\mathrm{BPP}$.
Каждый запрос $y$ симулируем алгоритмом $A_O(y)$, усиливая его до ошибки
$\delta:=1/(10q(n))$ повторением $O(\log q(n))$ раз и мажоритарным голосованием.
По объединённой вероятности (union bound) шанс, что хоть один из ответов оракула
ошибочен, не превосходит $q(n)\cdot\delta\le 1/10$.
Условно на правильных ответах оракула $M$ ошибается с вероятностью $\le 1/10$.
Итого общая ошибка $\le 1/5<1/3$, а время остаётся полиномиальным.
Следовательно, $\mathrm{BPP}^{\mathrm{BPP}}\subseteq\mathrm{BPP}$;
обратное включение тривиально.

Теперь индукция по $k$ для $\Sigma_k^p$.
База: $\Sigma_1^p=\mathrm{NP}\subseteq\mathrm{BPP}$ по предположению.
Переход: если $\Sigma_k^p\subseteq\mathrm{BPP}$, то
$$\Sigma_{k+1}^p=\mathrm{NP}^{\Sigma_k^p}\subseteq\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}.$$
Значит все уровни PH лежат в BPP, т.е. $\mathrm{PH}\subseteq\mathrm{BPP}$. $\square$

**Вывод/провал.** Предположение $\mathrm{SAT}\in\mathrm{BPP}$ не даёт $\mathrm{P}=\mathrm{NP}$,
а лишь коллапс PH в BPP. Для $\mathrm{P}=\mathrm{NP}$ нужна дерэндомизация
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.12. Исследовательский шаг: BPP in Sigma2 cap Pi2 (Sipser-Gacs-Lautemann)

**Вопрос ("А что если...?").** Можно ли поместить BPP на втором уровне PH?

**Лемма 16.12 (Sipser-Gacs-Lautemann).** $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$. Существует вероятностная машина $R(x,r)$,
работающая за $\mathrm{poly}(|x|)$ и использующая $m$ случайных бит, такая что
ошибка $\le 1/3$. Усилим (повторением и большинством) до ошибки
$\varepsilon:=2^{-2n}$, где $n=|x|$; это даёт новое $m=\mathrm{poly}(n)$.
Положим $G_x:=\{r\in\{0,1\}^m:\ R(x,r)=1\}$.
Тогда
$$x\in L\Rightarrow |G_x|\ge (1-\varepsilon)2^m,\quad x\notin L\Rightarrow |G_x|\le \varepsilon 2^m.$$

Зафиксируем $k:=m+1$. Для $r_1,\dots,r_k\in\{0,1\}^m$ рассмотрим
$$U:=\bigcup_{i=1}^k (G_x\oplus r_i),$$
где $\oplus$ — поразрядное XOR.

(1) Пусть $x\in L$. Выберем $r_i$ равномерно и независимо. Для фиксированного $z$
$$\Pr[z\notin U]=(1-|G_x|/2^m)^k\le \varepsilon^k.$$
По объединённой вероятности
$$\Pr[U\ne\{0,1\}^m]\le 2^m\varepsilon^k\le 2^m\cdot 2^{-2n(m+1)}<1.$$
Следовательно, существует набор $r_1,\dots,r_k$ с $U=\{0,1\}^m$.

(2) Пусть $x\notin L$. Тогда для любых $r_1,\dots,r_k$ имеем
$|U|\le k|G_x|\le k\varepsilon 2^m<2^m$ (для всех достаточно больших $n$),
значит существует $z$ с $z\notin U$.

Итак,
$$x\in L\iff \exists r_1,\dots,r_k\ \forall z\ \exists i\ R(x,z\oplus r_i)=1,$$
что есть $\Sigma_2^p$-формула (так как $k,m=\mathrm{poly}(n)$).
Так как $\mathrm{BPP}$ замкнут по дополнению, получаем также
$L\in\Pi_2^p$. Значит $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$. $\square$

**Вывод/провал.** Лемма лишь помещает $\mathrm{BPP}$ во второй уровень PH;
сама по себе она не даёт $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный, переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.13. Исследовательский шаг: NP in BPP => PH = Sigma2^p

**Вопрос ("А что если...?").** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, коллапсирует ли PH на втором уровне?

**Лемма 16.13.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то
$$\mathrm{PH}=\Sigma_2^p=\Pi_2^p.$$

*Доказательство.* По Лемме 16.11 получаем $\mathrm{PH}\subseteq\mathrm{BPP}$.
По Лемме 16.12 имеем $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.
Следовательно,
$$\mathrm{PH}\subseteq\Sigma_2^p\cap\Pi_2^p\subseteq\Sigma_2^p.$$
Но $\Sigma_2^p\subseteq\mathrm{PH}$ по определению, значит
$\mathrm{PH}=\Sigma_2^p$. Аналогично $\mathrm{PH}=\Pi_2^p$.
Следовательно, $\Sigma_2^p=\Pi_2^p$. $\square$

**Вывод/провал.** Даже при $\mathrm{NP}\subseteq\mathrm{BPP}$ получаем лишь коллапс PH
на уровне 2; до $\mathrm{P}=\mathrm{NP}$ это не доводит без дерэндомизации
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (используются релятивизирующие шаги 16.11 и 16.12).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.14. Исследовательский шаг: SAT в RP => NP = RP

**Вопрос ("А что если...?").** Что если SAT решается в RP — следует ли равенство $\mathrm{NP}=\mathrm{RP}$?

**Определение (RP).** Язык $L\in\mathrm{RP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 1/2,\quad x\notin L\Rightarrow \Pr[A(x)=1]=0.$$

**Лемма 16.14.** Если $\mathrm{SAT}\in\mathrm{RP}$, то $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* (1) $\mathrm{RP}\subseteq\mathrm{NP}$: пусть $A$ использует $m(n)$ случайных бит.
НМТ угадывает строку $r\in\{0,1\}^{m(n)}$ и принимает тогда и только тогда,
когда $A(x,r)=1$. Если $x\in L$, существует принимающий $r$;
если $x\notin L$, принимающих $r$ нет.

(2) $\mathrm{NP}\subseteq\mathrm{RP}$ при $\mathrm{SAT}\in\mathrm{RP}$:
пусть $L\in\mathrm{NP}$ и $f$ — полиномиальная many-one редукция $L\le_m^p\mathrm{SAT}$.
Алгоритм для $L$ вычисляет $y=f(x)$ и запускает RP-алгоритм для SAT на $y$.
Если $x\notin L$, то $y$ невыполним и RP-алгоритм всегда отвергает.
Если $x\in L$, то $y$ выполним и RP-алгоритм принимает с вероятностью $\ge 1/2$.
Значит $L\in\mathrm{RP}$.

Итак, $\mathrm{NP}=\mathrm{RP}$. $\square$

**Вывод/провал.** Даже если SAT в RP, получаем лишь $\mathrm{NP}=\mathrm{RP}$,
а не $\mathrm{P}=\mathrm{NP}$ без дерэндомизации (например, $\mathrm{RP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.15. Исследовательский шаг: P-uniform схемы для SAT

**Вопрос ("А что если...?").** Что если SAT имеет полиномиальные P-uniform схемы?

**Определение (P-uniform).** Семейство схем $\{C_n\}$ называется P-uniform, если
существует детерминированная полиномиальная машина $U$, которая по входу $1^n$
выводит описание схемы $C_n$.

**Лемма 16.15.** Если SAT имеет P-uniform семейство схем полиномиального размера,
то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $U$ строит $C_n$ за $\mathrm{poly}(n)$.
На входе формулы $\varphi$ длины $n$ вычисляем $C_n$ с помощью $U$ и затем
вычисляем $C_n(\varphi)$ за время $\mathrm{poly}(n)$ (размер схемы полиномиален).
Следовательно, $\mathrm{SAT}\in\mathrm{P}$, а значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить P-uniform на $\mathrm{P/poly}$.
Существует tally-язык $L\subseteq\{1\}^*$, не лежащий в $\mathrm{P}$
(диагонализация как в теореме иерархии по времени, Раздел 12).
Для каждого $n$ единственный вход длины $n$ - строка $1^n$, поэтому
константная схема размера $O(1)$ решает $L$ на длине $n$.
Следовательно, $L\in\mathrm{P/poly}$, но $L\notin\mathrm{P}$.

**Вывод/провал.** Полиномиальные неравномерные схемы не дают $\mathrm{P}=\mathrm{NP}$;
критична униформность построения.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - симуляция и диагонализация).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.16. Исследовательский шаг: P-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-immune язык?

**Определение (P-immune).** Бесконечный язык $L$ называется P-immune, если у него нет
бесконечного подмножества в $\mathrm{P}$.

**Лемма 16.16.** Если существует P-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Но тогда $L$ само является бесконечным подмножеством $L$, лежащим в $\mathrm{P}$,
что противоречит P-иммунности. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-immune. Например, SAT имеет
бесконечное подмножество в $\mathrm{P}$: формулы вида
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i)$$
всегда выполнимы и распознаются за полиномиальное время. Следовательно, SAT не P-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.17. Исследовательский шаг: P-bi-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-bi-immune язык?

**Определение (P-bi-immune).** Бесконечный язык $L$ называется P-bi-immune, если
$L$ и $\overline{L}$ являются P-immune.

**Лемма 16.17.** Если существует P-bi-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Так как $\mathrm{P}$ замкнут по дополнению, имеем $\overline{L}\in\mathrm{P}$.
Но тогда и $L$, и $\overline{L}$ содержат бесконечные подмножества в $\mathrm{P}$
(они сами), что противоречит P-immune. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-bi-immune. Для SAT есть
бесконечное подмножество в $\mathrm{P}$, например формулы
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i),$$
а для $\overline{\mathrm{SAT}}$ есть бесконечное подмножество в $\mathrm{P}$, например
$$\bigwedge_{i=1}^m (x_i\land\neg x_i).$$
Следовательно, SAT не P-bi-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.18. Исследовательский шаг: NP-hard P-selective

**Вопрос ("А что если...?").** Что если существует P-selective язык, NP-трудный по $\le_m^p$?

**Определение (P-selective).** Язык $S$ называется P-selective, если существует
детерминированная полиномиальная функция $s(x,y)$, возвращающая $x$ или $y$, такая что
если $x\in S$ или $y\in S$, то $s(x,y)\in S$.

**Лемма 16.18.** Если существует P-selective язык $S$ и $\mathrm{SAT}\le_m^p S$,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $f$ - полиномиальная редукция SAT к $S$ и $s$ - селектор для $S$.
Для формулы $\varphi$ последовательно фиксируем переменные. На шаге $i$ строим
$\varphi_0=\varphi\upharpoonright(x_i=0)$ и $\varphi_1=\varphi\upharpoonright(x_i=1)$,
вычисляем $f(\varphi_0), f(\varphi_1)$ и берём
$$w:=s(f(\varphi_0), f(\varphi_1)).$$
Если $w=f(\varphi_0)$, ставим $x_i:=0$, иначе $x_i:=1$ (если оба равны, выбор не важен).
Если $\varphi$ выполнима, то хотя бы одна из $\varphi_0,\varphi_1$ выполнима,
значит соответствующий образ лежит в $S$, и селектор выбирает выполнимую ветвь.
Индукцией после всех шагов получаем удовлетворяющее присваивание, которое проверяем.
Если $\varphi$ невыполнима, любая ветвь приведёт к ложному присваиванию, проверка отвергнет.
Время полиномиально. Значит $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** P-selective само по себе не означает трудность.
Например, язык $L=\{x: x_1=1\}$ находится в $\mathrm{P}$ и P-selective,
но не NP-труден (если $\mathrm{P}\ne\mathrm{NP}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.19. Исследовательский шаг: SAT в coRP => NP = coNP

**Вопрос ("А что если...?").** Что если SAT решается в coRP - следует ли $\mathrm{NP}=\mathrm{coNP}$?

**Определение (coRP).** Язык $L\in\mathrm{coRP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]=1,\quad x\notin L\Rightarrow \Pr[A(x)=1]\le 1/2.$$

**Лемма 16.19.** Если $\mathrm{SAT}\in\mathrm{coRP}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* (1) $\mathrm{coRP}\subseteq\mathrm{coNP}$: если $L\in\mathrm{coRP}$,
то $\overline{L}\in\mathrm{RP}$, а $\mathrm{RP}\subseteq\mathrm{NP}$ (угадать случайные биты).
Значит $L\in\mathrm{coNP}$.

(2) coRP замкнут по детерминированным $\le_m^p$-редукциям: если $L\le_m^p A$ и
$A\in\mathrm{coRP}$, то алгоритм для $A$ на входе $f(x)$ даёт корректную coRP
процедуру для $L$.

Так как SAT NP-полон, из $\mathrm{SAT}\in\mathrm{coRP}$ получаем
$\mathrm{NP}\subseteq\mathrm{coRP}\subseteq\mathrm{coNP}$, значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к усилению.** coRP само по себе не означает NP-трудность.
Например, язык $\Sigma^*$ лежит в $\mathrm{coRP}\cap\mathrm{P}$ и не может быть
NP-трудным по $\le_m^p$, иначе следовало бы $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.20. Исследовательский шаг: точный подсчет решений SAT

**Вопрос ("А что если...?").** Что если #SAT вычислима за полиномиальное время?

**Определение (#SAT).** Для CNF-формулы $\varphi$ функция $\#\mathrm{SAT}(\varphi)$
равна числу удовлетворяющих присваиваний.

**Лемма 16.20.** Если $\#\mathrm{SAT}$ вычислима за полиномиальное время,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* На входе формулы $\varphi$ вычисляем $\#\mathrm{SAT}(\varphi)$.
Если значение больше нуля, то $\varphi$ выполнима, иначе нет.
Это решает SAT за полиномиальное время, значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить точный подсчет на подсчет по модулю 2.
Формула
$$\psi=(x_1\lor x_2)\land(\neg x_1\lor \neg x_2)$$
имеет ровно 2 решения (четность 0), а формула
$$\theta=(x_1\land\neg x_1)$$
имеет 0 решений (четность 0). Следовательно, знание $\#\mathrm{SAT}(\cdot)\bmod 2$
не позволяет решать SAT в общем случае.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - прямое вычисление числа решений).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.21. Исследовательский шаг: FPRAS для #SAT

**Вопрос ("А что если...?").** Что если существует FPRAS для #SAT?

**Определение (FPRAS для #SAT).** Рандомизированный алгоритм $A$ — FPRAS для
$\#\mathrm{SAT}$, если для любой формулы $\varphi$, параметров $\varepsilon\in(0,1)$ и
$\delta\in(0,1)$ он работает за $\mathrm{poly}(|\varphi|,1/\varepsilon,\log(1/\delta))$ и
с вероятностью $\ge 1-\delta$ возвращает число $\widetilde{N}$, такое что
$$ (1-\varepsilon)\#\mathrm{SAT}(\varphi)\le \widetilde{N}\le (1+\varepsilon)\#\mathrm{SAT}(\varphi). $$

**Лемма 16.21.** Если для $\#\mathrm{SAT}$ существует FPRAS, то $\mathrm{SAT}\in\mathrm{RP}$,
следовательно $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* Используем саморедукцию поиска (шаг 16.3), заменив вызовы SAT
на FPRAS для $\#\mathrm{SAT}$.

Пусть $\varphi$ над $n$ переменными. Для $i=1..n$ рассмотрим
$\varphi_0:=\varphi\upharpoonright(x_i=0)$ и $\varphi_1:=\varphi\upharpoonright(x_i=1)$ и
запустим FPRAS на обеих формулах с $\varepsilon=1/2$ и $\delta:=1/(10n)$. Если обе оценки равны 0,
отвергаем; иначе выбираем ветвь с ненулевой оценкой и продолжаем. В конце получаем присваивание $a$
и детерминированно проверяем $\varphi(a)=1$; принимаем тогда и только тогда, когда проверка проходит.

Если $\varphi$ невыполнима, то проверка никогда не пройдёт, значит мы всегда отвергаем.
Если $\varphi$ выполнима, то при успешных вызовах FPRAS нулевая оценка появляется тогда и только тогда,
когда соответствующая ветвь имеет 0 решений, поэтому мы всегда можем выбрать ветвь с хотя бы одним решением
и дойти до удовлетворяющего $a$. По объединённой вероятности все $2n$ вызовов успешны с вероятностью
$\ge 1-2n\delta\ge 4/5$, значит принимаем с вероятностью $\ge 1/2$.
Итак, $\mathrm{SAT}\in\mathrm{RP}$, а по Лемме 16.14 $\mathrm{NP}=\mathrm{RP}$. $\square$

**Контрпример к усилению.** Знание $\#\mathrm{SAT}(\varphi)\bmod 2$ не решает SAT
(см. контрпример в шаге 16.20), значит «аппроксимация» без гарантии
мультипликативной точности может быть недостаточна.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.22. Исследовательский шаг: SAT в ZPP => NP = ZPP

**Вопрос ("А что если...?").** Что если SAT решается в ZPP - следует ли равенство $\mathrm{NP}=\mathrm{ZPP}$?

**Определение (ZPP).** $\mathrm{ZPP}=\mathrm{RP}\cap\mathrm{coRP}$; эквивалентно,
это класс языков, распознаваемых рандомизированными алгоритмами ожидаемого
полиномиального времени без ошибок (Las Vegas).

**Лемма 16.22.** Если $\mathrm{SAT}\in\mathrm{ZPP}$, то $\mathrm{NP}=\mathrm{ZPP}$.

*Доказательство.* Так как SAT NP-полна и ZPP замкнут по детерминированным
$\le_m^p$-редукциям, из $\mathrm{SAT}\in\mathrm{ZPP}$ следует
$\mathrm{NP}\subseteq\mathrm{ZPP}$. С другой стороны, $\mathrm{ZPP}\subseteq\mathrm{RP}\subseteq\mathrm{NP}$.
Следовательно, $\mathrm{NP}=\mathrm{ZPP}$. $\square$

**Вывод/провал.** Равенство $\mathrm{NP}=\mathrm{ZPP}$ само по себе не даёт
$\mathrm{P}=\mathrm{NP}$ без дерэндомизации $\mathrm{ZPP}=\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.23. Исследовательский шаг: SAT почти всюду в P

**Вопрос ("А что если...?").** Что если SAT решается за полиномиальное время на всех достаточно больших длинах входа?

**Определение (a.e.-P).** Язык $L$ называется *почти всюду* в $\mathrm{P}$, если
существует $n_0$ и полиномиальный алгоритм $A$, такой что для всех $x$ с $|x|\ge n_0$:
$A(x)$ решает принадлежность $x\in L$.

**Лемма 16.23.** Если SAT почти всюду в $\mathrm{P}$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ корректен для всех длины $\ge n_0$.
Для длин $<n_0$ заранее вычислим ответы (это конечное множество строк) и
зашьем их в алгоритм. Тогда получаем полиномиальный алгоритм, решающий SAT на всех входах.
Следовательно, $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Условие "в $\mathrm{P}$ на бесконечном числе длин" недостаточно.
Пусть $H\in\mathrm{DTIME}(2^n)\setminus\mathrm{P}$ (существует по теореме иерархии по времени).
Определим
$$L:=\{z:\ |z|\ \text{четно}\}\ \cup\ \{1^{|x|}0x:\ x\in H\}.$$
Тогда $L$ тривиален на всех четных длинах (значит "легок" на бесконечно многих длинах),
но $H\le_m^p L$ по редукции $x\mapsto 1^{|x|}0x$ (длина $2|x|+1$), поэтому из $L\in\mathrm{P}$
следовало бы $H\in\mathrm{P}$ — противоречие. Значит условие "на бесконечно многих длинах" не даёт $\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.24. Исследовательский шаг: SAT в RP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в RP, используя лишь $O(\log n)$ случайных бит?

**Определение (RP$_{\log}$).** Язык $L\in\mathrm{RP}_{\log}$, если существует RP-машина,
которая на входах длины $n$ использует не более $c\log n$ случайных битов.

**Лемма 16.24.** Если $\mathrm{SAT}\in\mathrm{RP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ - RP-алгоритм для SAT с $m(n)\le c\log n$ случайных битов.
Для входа $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$ случайные строки $r$ и
запустим $A(\varphi,r)$.
Если $\varphi$ невыполнима, то $A$ никогда не принимает, значит мы отвергаем.
Если $\varphi$ выполнима, существует хотя бы один $r$ с принятием, значит мы принимаем.
Время полиномиально. $\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
занимает $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий RP.
Следовательно, ограничение $O(\log n)$ существенно.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.25. Исследовательский шаг: NP-полный язык в io-P

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на бесконечно многих длинах входа, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (io-P).** Язык $L$ принадлежит io-P, если существует полиномиальный
алгоритм $A$ и бесконечное множество длин $N\subseteq\mathbb{N}$, такое что для всех
$n\in N$ и всех строк $x$ длины $n$ выполняется $A(x)=1\iff x\in L$.

**Лемма 16.25 (контрпример).** Существует NP-полный язык $L'$ такой, что $L'\in$ io-P.

*Доказательство.* Пусть $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$ 
Тогда любая строка из $L'$ имеет длину $n^2$. Редукция $x\mapsto x0^{n^2-n}$
полиномиальна, значит $L'$ NP-полон. Для любой длины $m$, не являющейся квадратом,
в $L'$ нет строк, поэтому алгоритм, всегда отвергающий на таких длинах,
решает $L'$ за полиномиальное время. Неквадратных длин бесконечно много, значит
$L'\in$ io-P. Следовательно, условие "NP-полный и легок на бесконечно многих длинах"
не влечет $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.26. Исследовательский шаг: NP-полный язык легок на плотности 1 длин

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на множестве длин плотности 1, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (плотность 1 по длинам).** Множество длин $N\subseteq\mathbb{N}$ имеет
плотность 1, если
$$\lim_{m\to\infty} \frac{|N\cap\{1,\dots,m\}|}{m}=1.$$
Язык $L$ называется *легким на длинах из $N$*, если существует полиномиальный
алгоритм $A$, корректный для всех строк $x$ с $|x|\in N$.

**Лемма 16.26 (контрпример).** Существует NP-полный язык $L'$ и множество длин $N$
плотности 1, такое что $L'$ легок на длинах из $N$.

*Доказательство.* Положим $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{n^2-n}$ полиномиальна, значит $L'$ NP-полон.
Любая строка из $L'$ имеет длину квадрат; на длинах, не являющихся квадратами,
$L'$ пуст, и алгоритм, всегда отвергающий, корректен. Пусть $N$ - множество
неквадратных длин. Тогда $|N\cap\{1,\dots,m\}|=m-\lfloor\sqrt{m}\rfloor$, поэтому
$N$ имеет плотность 1. Значит $L'$ легок на длинах из $N$. $\square$

**Вывод/провал.** Свойство "NP-полный язык легок на плотности 1 длин" слишком слабое:
оно уже достигается простой паддинг-конструкцией и не ведет к $\mathrm{P}=\mathrm{NP}$
без дополнительных идей.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.27. Исследовательский шаг: SAT в BPP => SAT в P/poly

**Вопрос ("А что если...?").** Если SAT решается в BPP, следует ли из этого
существование полиномиальных схем?

**Лемма 16.27 (Adleman).** Если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{SAT}\in\mathrm{P/poly}$.

*Доказательство.* Пусть $A$ - BPP-алгоритм для SAT, использующий $m(n)$ случайных битов.
Усилим его повторением до ошибки $\varepsilon=2^{-2n}$, получив алгоритм $A'$
(время и число битов остаются полиномиальными).
Для фиксированной длины $n$ обозначим через $B_x$ множество случайных строк $r$
длины $m(n)$, на которых $A'(x,r)$ ошибается. Тогда $|B_x|\le \varepsilon 2^{m(n)}$.
Объединение по всем $x\in\{0,1\}^n$ имеет размер
$$\left|\bigcup_{x} B_x\right|\le 2^n\cdot \varepsilon 2^{m(n)}<2^{m(n)},$$
поэтому существует строка $r_n$, на которой $A'$ корректен для всех входов длины $n$.
Жестко зашив $r_n$ в схему, получаем семейство схем полиномиального размера,
решающее SAT на каждой длине $n$. Значит $\mathrm{SAT}\in\mathrm{P/poly}$. $\square$

**Вывод/провал.** Из SAT $\in\mathrm{BPP}$ следует лишь неравномерность
($\mathrm{SAT}\in\mathrm{P/poly}$) и, по Karp-Lipton, коллапс PH до $\Sigma_2^p$;
это не дает $\mathrm{P}=\mathrm{NP}$ без дополнительных идей о униформности.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.28. Исследовательский шаг: NP ⊆ AC^0?

**Вопрос ("А что если...?").** Что если весь $\mathrm{NP}$ лежит в $\mathrm{AC}^0$?

**Лемма 16.28 (контрпример).** $\mathrm{NP}\not\subseteq\mathrm{AC}^0$.

*Доказательство.* Функция $\mathrm{PARITY}$ принадлежит $\mathrm{P}\subseteq\mathrm{NP}$.
По разделу 11.3, $\mathrm{PARITY}\notin\mathrm{AC}^0$.
Значит существует язык из $\mathrm{NP}$, не лежащий в $\mathrm{AC}^0$, то есть
$\mathrm{NP}\not\subseteq\mathrm{AC}^0$. $\square$

**Вывод/провал.** Утверждение $\mathrm{NP}\subseteq\mathrm{AC}^0$ слишком сильное:
оно уже опровергается классическими нижними оценками для $\mathrm{AC}^0$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о неравномерных схемах).
- *Natural proofs:* не препятствует; нижние оценки для $\mathrm{AC}^0$ известны.
- *Algebrization:* неприменимо.

### 16.29. Исследовательский шаг: средняя легкость NP-полного языка

**Вопрос ("А что если...?").** Если NP-полный язык решается полиномиально
на почти всех входах каждой длины (равномерно по $\{0,1\}^n$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (ошибка на длине $n$).** Алгоритм $A$ имеет ошибку $\varepsilon(n)$ на языке $L$,
если $\Pr_{x\in\{0,1\}^n}[A(x)\ne L(x)]\le \varepsilon(n)$.

**Лемма 16.29 (контрпример).** Существует NP-полный язык $L'$ и полиномиальный алгоритм $A$,
для которого ошибка на длине $n$ не превосходит $2^{-\Omega(n)}$.

*Доказательство.* Возьмем $p(m)=m^2$ и определим
$$L' = \{x0^{p(|x|)} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{p(|x|)}$ полиномиальна, значит $L'$ NP-полон.
Если длина $n$ имеет вид $n=m+p(m)=m+m^2$, то в $\{0,1\}^n$ не более $2^m$ строк из $L'$,
поэтому доля принимающих не превосходит $2^m/2^{m+m^2}=2^{-m^2}=2^{-\Theta(n)}$.
Если длина $n$ не такого вида, то $L'\cap\{0,1\}^n=\varnothing$.
Алгоритм $A$, всегда отвергающий, имеет ошибку не более $2^{-\Theta(n)}$ на каждой длине.
$\square$

**Вывод/провал.** Наличие NP-полного языка, легкого на почти всех входах каждой длины,
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается простым паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг и оценка доли сохраняются с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.30. Исследовательский шаг: NP-полный язык в субэкспоненциальном времени?

**Вопрос ("А что если...?").** Если существует NP-полный язык, решаемый за
время $2^{n^\varepsilon}$ (для некоторого $0<\varepsilon<1$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Лемма 16.30 (контрпример).** Существует NP-полный язык $L'$ в
$\mathrm{DTIME}(2^{O(\sqrt{n})})$ (то есть за субэкспоненциальное время).

*Доказательство.* Определим
$$L' = \{x0^{|x|^2-|x|} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{|x|^2-|x|}$ полиномиальна, значит $L'$ NP-полон.
Для входа длины $n$ проверим, является ли $n$ квадратом $m^2$ и что последние
$n-m$ битов нулевые; иначе отвергаем. Если $n=m^2$, берём первые $m$ битов как $x$
и решаем SAT полным перебором за $2^{O(m)}=2^{O(\sqrt{n})}$.
Следовательно, $L'\in\mathrm{DTIME}(2^{O(\sqrt{n})})$. $\square$

**Вывод/провал.** Наличие NP-полного языка в субэкспоненциальном времени
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.31. Исследовательский шаг: p-bounded proof system?

**Вопрос ("А что если...?").** Что если существует полиномиально ограниченная
пропозициональная система доказательств?

**Определение (p-bounded).** Доказательная система $P$ (в смысле Cook-Reckhow)
p-bounded, если существует полином $p$, что каждая тавтология $\varphi$
имеет $P$-доказательство длины $\le p(|\varphi|)$.

**Лемма 16.31.** Если существует p-bounded доказательная система, то
$\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $P$ p-bounded. НП-машина по входу $\varphi$
угадывает строку длины $\le p(|\varphi|)$ и проверяет, что это корректное
$P$-доказательство $\varphi$ (проверка полиномиальна по определению proof system).
Значит $\mathrm{TAUT}\in\mathrm{NP}$. Так как $\mathrm{TAUT}$ coNP-полна,
получаем $\mathrm{coNP}\subseteq\mathrm{NP}$, и следовательно
$\mathrm{NP}=\mathrm{coNP}$. $\square$

**Вывод/провал.** p-boundedness: чрезвычайно сильное требование:
оно сразу влечет коллапс $\mathrm{NP}$ и $\mathrm{coNP}$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о proof systems).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.32. Исследовательский шаг: SAT в BPP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в BPP, используя лишь
$O(\log n)$ случайных битов?

**Определение (BPP$_{\log}$).** Язык $L\in\mathrm{BPP}_{\log}$, если существует
BPP-алгоритм, использующий не более $c\log n$ случайных битов на входах длины $n$.

**Лемма 16.32.** Если $\mathrm{SAT}\in\mathrm{BPP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ — BPP-алгоритм для SAT, использующий $m(n)\le c\log n$
случайных битов. Для формулы $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$
случайные строки $r$ и вычислим долю принятий $A(\varphi,r)$.
Если $\varphi$ выполнима, эта доля $\ge 2/3$, иначе $\le 1/3$.
Сравнение с порогом $1/2$ дает детерминированное решение за полиномиальное время.
$\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий BPP.

**Барьер-чек.**
- *Релятивизация:* да (перебор случайных строк сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.33. Исследовательский шаг: SAT разрежен?

**Вопрос ("А что если...?").** Может ли SAT быть разреженным языком?

**Определение (sparse).** Язык $L$ разрежен, если существует полином $p$, что
$|L\cap\Sigma^{\le n}|\le p(n)$ для всех $n$.

**Лемма 16.33 (контрпример).** SAT не является разреженным языком.

*Доказательство.* Для каждого $m$ и каждого присваивания $a\in\{0,1\}^m$ рассмотрим формулу
$$\varphi_a:=\bigwedge_{i=1}^m \ell_i,$$
где $\ell_i=x_i$ при $a_i=1$ и $\ell_i=\neg x_i$ при $a_i=0$.
Каждая $\varphi_a$ выполнима (единственным образом) и имеет длину $\mathrm{poly}(m)$
(при любом стандартном кодировании входа).
Формулы $\varphi_a$ различны, поэтому среди строк длины $\le \mathrm{poly}(m)$ есть как минимум $2^m$
выполнимых формул. Так как $2^m$ перерастает любой полином от $\mathrm{poly}(m)$,
SAT не разрежен. $\square$

**Вывод/провал.** Попытка использовать разреженность SAT как путь к $\mathrm{P}\ne\mathrm{NP}$
обрывается на элементарном счете: SAT слишком плотен.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированном языке).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.34. Исследовательский шаг: SAT с логарифмическими сертификатами

**Вопрос ("А что если...?").** Если SAT имеет сертификаты длины $O(\log n)$,
следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (NP$_{\log}$).** Язык $L\in\mathrm{NP}_{\log}$, если существует
полиномиальный верификатор $V(x,y)$ и константа $c$ такие, что для всех $x$:
$$x\in L\iff \exists y\in\{0,1\}^{\le c\log|x|}: V(x,y)=1.$$

**Лемма 16.34.** Если $\mathrm{SAT}\in\mathrm{NP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть для SAT существует верификатор с сертификатом длины
не более $c\log n$. Тогда на входе длины $n$ можно перебрать все
$2^{c\log n}=n^c$ сертификатов $y$ и проверить $V(x,y)$.
Это детерминированное полиномиальное время. $\square$

**Контрпример к усилению.** При длине сертификата $\Theta(n)$ полный перебор
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий NP.

**Барьер-чек.**
- *Релятивизация:* да (перебор сертификатов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.35. Исследовательский шаг: односторонние функции

**Вопрос ("А что если...?").** Что если существуют односторонние функции?

**Определение (OWF).** Функция $f:\{0,1\}^*\to\{0,1\}^*$ односторонняя, если
она полиномиально вычислима и для любого полиномиального алгоритма $A$
вероятность $\Pr_{x\leftarrow\{0,1\}^n}[f(A(f(x)))=f(x)]$ пренебрежимо мала.

**Лемма 16.35.** Если существуют OWF, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим, что $\mathrm{P}=\mathrm{NP}$. Зафиксируем
полиномиально вычислимую $f$. Для данного $y$ будем по битам восстанавливать
преобраз: на шаге $i$ проверяем, существует ли строка $x$ с заданным префиксом
длины $i$ такая, что $f(x)=y$. Это NP-вопрос, значит при $\mathrm{P}=\mathrm{NP}$
решается за полиномиальное время. После $O(|y|)$ шагов получаем $x$ с $f(x)=y$.
Следовательно, $f$ инвертируема в полиномиальное время на всех $y$ из образа,
противоречие односторонности. Значит существование OWF влечет $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Вывод/провал.** Доказать существование OWF достаточно для $\mathrm{P}\ne\mathrm{NP}$,
но это не проще исходной задачи.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулом).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.36. Исследовательский шаг: PRG с логарифмическим seed

**Вопрос ("А что если...?").** Что если существует PRG с seed длины $O(\log n)$,
который обманывает все BPP-алгоритмы?

**Определение (PRG для BPP).** Семейство $g_n:\{0,1\}^{s(n)}\to\{0,1\}^{m(n)}$
c $s(n)=O(\log n)$ и $m(n)=\mathrm{poly}(n)$, вычислимое за полиномиальное время,
такое что для любого полиномиального алгоритма $A$ и всех $n$:
$$\left|\Pr[A(g_n(U_{s(n)}))=1]-\Pr[A(U_{m(n)})=1]\right|\le 1/10.$$

**Лемма 16.36.** Если такой PRG существует, то $\mathrm{BPP}=\mathrm{P}$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$ и $A$ — его вероятностный полиномиальный
алгоритм с $m(n)$ случайными битами и ошибкой $\le 1/3$.
Для входа $x$ длины $n$ переберем все $2^{s(n)}=\mathrm{poly}(n)$ seed'ы $r$,
посчитаем долю принятий $A(x,g_n(r))$ и сравним с порогом $1/2$.
Так как PRG сохраняет вероятность с точностью $1/10$, то при $x\in L$ среднее
$\ge 2/3-1/10>1/2$, а при $x\notin L$ среднее $\le 1/3+1/10<1/2$.
Получаем детерминированный полиномиальный алгоритм. $\square$

**Контрпример к усилению.** Если $s(n)=\Theta(n)$, то полный перебор seed'ов
занимает $2^{\Theta(n)}$ времени и доказательство не работает.

**Барьер-чек.**
- *Релятивизация:* да (перебор seed'ов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.37. Исследовательский шаг: счётчик ошибок в tt‑формуле

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для любого $N=2^n$ и $T\in\{0,\dots,N\}$ существует булева схема
  размера $O(N\log N)$ и глубины $O(\log N)$, вычисляющая
  $\mathrm{Count}_{\ge T}(e_1,\dots,e_N)$; построение — двоичное дерево сумматоров
  и компаратор с $T$.
- `Toy‑тест:` $N=4$: складываем $(e_1,e_2)$ и $(e_3,e_4)$ 2‑битными сумматорами,
  затем 3‑битным сумматором получаем сумму $\in\{0,\dots,4\}$; компаратор на 3 битах
  проверяет $\ge T$. Размер и глубина соответствуют $O(N\log N)$ и $O(\log N)$.
- `Статус:` доказано (явная конструкция).
- `Барьер‑чек:` r — неприменимо (верхняя оценка), NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости зафиксировать в основном тексте конкретную
  реализацию (adder tree/Batcher) и кодирование $T$ длины $O(\log N)$.

### 16.38. Исследовательский шаг: Tseitin-кодирование $\mathrm{Eval}(C,x)$

- `Линза:` Эквивалентность.
- `Утверждение:` Для gate-list кодирования схемы $C$ размера $s$ (fan-in 2)
  существует CNF формула $\mathrm{Eval}_C(x,b)$ с $O(s)$ вспомогательными
  переменными и $O(s)$ клаузами, такая что для любого назначения входов $x$
  формула выполнима тогда и только тогда, когда выход схемы равен $b$.
- `Toy‑тест:` Схема: $g_1:=x_1\land x_2$, $g_2:=g_1\lor x_3$ (выход $g_2$).
  Tseitin-клаузы:
  $(\neg g_1\lor x_1)\land(\neg g_1\lor x_2)\land(g_1\lor\neg x_1\lor\neg x_2)$ и
  $(\neg g_2\lor g_1\lor x_3)\land(g_2\lor\neg g_1)\land(g_2\lor\neg x_3)$,
  плюс единичная клауза $(g_2)$ для $b=1$.
  При $x_1=x_2=1,x_3=0$ удовлетворяется с $g_1=g_2=1$; при $b=0$ невыполнима.
  На один гейт приходится $O(1)$ клауз, значит размер $O(s)$.
- `Статус:` доказано (стандартное Tseitin-кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` связать это кодирование с местом, где в тексте фиксируется
  $n=||x||$ при пропозициональном переводе в EF.

### 16.39. Исследовательский шаг: эквивалентность vs эквисатисфакция в CNF→3-CNF

- `Линза:` Эквивалентность.
- `Утверждение:` Стандартная редукция CNF→3-CNF порождает формулу $r(\varphi)$,
  логически эквивалентную $\varphi$ как формула над *всеми* переменными
  (исходными и новыми).
- `Toy‑тест:` Возьмём клаузу $\varphi=(x_1\lor x_2\lor x_3\lor x_4)$ и редукцию
  $r(\varphi)=(x_1\lor x_2\lor y)\land(\neg y\lor x_3\lor x_4)$.
  Присваивание $x_1=1,x_2=x_3=x_4=0,y=1$ делает $\varphi$ истинной, но
  $r(\varphi)$ ложной (вторая клауза ложна). Следовательно, полная эквивалентность
  неверна; верно лишь $\varphi\equiv \exists y\, r(\varphi)$.
- `Статус:` контрпример.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` использовать явную функцию $g$ (как в Лемме 15.7.3d),
  чтобы переносить истинность $\varphi$ на $r(\varphi)$ в EF.

### 16.40. Исследовательский шаг: порядок blow-up не влияет на барьер

- `Линза:` Трейд‑офф (размеры).
- `Утверждение:` Для барьера 15.7.4 достаточно любого полиномиального blow-up
  редукции $r$; явный порядок (линейный/квадратичный) не меняет вывода
  $\mathrm{P}=\mathrm{NP}$.
- `Toy‑тест:` Пусть $|r(\varphi)|\le |\varphi|^2$ и алгоритм $\mathcal A$
  строит ROABP размера $\le |\psi|^3$. Тогда композиция даёт ROABP
  размера $\le |\varphi|^6$, что остаётся полиномом. Следовательно, даже
  квадратичный blow-up не ломает аргумент.
- `Статус:` доказано (тривиальная оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости найти точный порядок blow-up в
  редукциях Лихтенштейна/Товея для библиографической аккуратности.

### 16.41. Исследовательский шаг: фиксация $n=||x||$ в масштабе LogLog

- `Линза:` Эквивалентность.
- `Утверждение:` Если в $LB_{tt}(h,s(n),t(n)2^n)$ подставить параметр
  $x:=2^{2^n}$, то $||x||=2^n+1$, и все ограничения вида $u<2^n$ становятся
  bounded (например, $u\le ||x||$). Поэтому формула остаётся $\Pi^b_1$,
  а её пропозициональный перевод имеет размер $\mathrm{poly}(2^n)$ и даёт
  стандартный $tt(h_n,s(n),t(n))$.
- `Toy‑тест:` $n=2$: берём $x=2^{2^2}=16$, получаем $||x||=5$, и любой
  квантор $u<2^n=4$ можно заменить на $u\le 5$ без изменения истинности.
  Это иллюстрирует, как «таблица истинности» длины $2^n$ укладывается
  в bounded‑кванторы по $x$.
- `Статус:` доказано (прямая оценка длины).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` указать в основном тексте конкретное место, где
  фиксируется подстановка $x=2^{2^n}$ (PS Sec. 2.4.1) и как это отражается
  в EF‑переводе.

### 16.42. Исследовательский шаг: $\mathrm{Count}_{\ge T}$ через сортировочную сеть

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть сеть сортирует биты $e_1,\dots,e_N$ по невозрастанию,
  выдавая $b_1\ge \cdots \ge b_N$. Тогда $\mathrm{Count}_{\ge T}(e)$ эквивалентно
  условию $b_T=1$. Бэтчерова сортировочная сеть имеет $O(N\log^2 N)$ компараторов,
  каждый компаратор реализуется $O(1)$ AND/OR‑гейтами, значит схема для
  $\mathrm{Count}_{\ge T}$ имеет размер $O(N\log^2 N)$.
- `Toy‑тест:` $N=4$ и сеть с компараторами $(1,2),(3,4),(1,3),(2,4),(2,3)$
  (выходы — $(\max,\min)$). На входе $(1,0,1,0)$ получаем
  $(1,1,0,0)$, поэтому $\mathrm{Count}_{\ge 3}$ ложно, а $\mathrm{Count}_{\ge 2}$
  истинно (проверка по $b_3$ и $b_2$).
- `Статус:` доказано (стандартная сеть).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` решить, какой из вариантов (adder tree vs sorting network)
  удобнее фиксировать в основном тексте около Леммы 15.7.1d.

### 16.43. Исследовательский шаг: размер компаратора и кодирование порога $T$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для $N=2^n$ и любого целого $T\in[0,N]$ длина двоичного кода $T$
  равна $O(\log N)=O(n)$. Компаратор, проверяющий $S\ge T$ для суммы $S\in[0,N]$
  (в двоичном виде), реализуется схемой размера $O(\log N)$. Поэтому добавление
  порога не меняет асимптотику конструкции $\mathrm{Count}_{\ge T}$.
- `Toy‑тест:` $N=8$, $T=5=0101_2$, сумма $S=s_3s_2s_1s_0$.
  Условие $S\ge 5$ эквивалентно $s_3\ \lor\ (s_2\land(s_1\lor s_0))$,
  что даёт константный компаратор; размер растёт как $O(\log N)$ в общем случае.
- `Статус:` доказано (стандартный компаратор по двоичному сравнению).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить короткую ремарку о размере компаратора
  рядом с Леммой 15.7.1d.

### 16.44. Исследовательский шаг: длина gate‑list и $\Delta^b_0$‑валидность

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для схемы размера $s$ с fan‑in 2 и $n$ входами gate‑list
  кодирование имеет длину $m(s,n)=O(s\log s+n\log s)$: на каждый гейт
  сохраняются тип (константа) и два индекса входов $<i$, каждый индекс
  занимает $O(\log s)$ бит. Предикат $\mathrm{Valid}_s(C)$ проверяется
  bounded‑кванторами по $i\le s$ и индексам $<i$, поэтому является $\Delta^b_0$.
- `Toy‑тест:` $s=3,n=2$: кодируем гейты
  $g_1=\mathrm{IN}(1)$, $g_2=\mathrm{IN}(2)$, $g_3=\mathrm{AND}(1,2)$.
  Каждый индекс $\le 3$ кодируется 2 битами, тип — константным числом бит.
  Проверка $\mathrm{Valid}_3$ требует лишь условий «индексы $<i$».
  Если заменить $g_3=\mathrm{AND}(3,2)$, то условие $3<i$ ложно — контрпример
  к валидности при тех же bounded‑кванторах.
- `Статус:` доказано (явная оценка и проверка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании сослаться на Лемму 15.7.2b в основном тексте
  и отметить, что при $n\le s$ можно брать $m(s)=O(s\log s)$.

### 16.45. Исследовательский шаг: корректность явного $g$ в CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для клаузы $(\ell_1\lor\cdots\lor\ell_k)$ и цепочки
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land\cdots\land
  (\neg y_{k-3}\lor\ell_{k-1}\lor\ell_k)$ выбор
  $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ удовлетворяет всем новым клаузам
  при любом истинном значении исходной клаузы.
- `Toy‑тест:` $k=5$, пусть $\ell_3$ истинна, а $\ell_1=\ell_2=\ell_4=\ell_5=0$.
  Тогда $y_1=\neg(\ell_1\lor\ell_2)=1$, $y_2=\neg(\ell_1\lor\ell_2\lor\ell_3)=0$.
  Проверка цепочки:
  $(\ell_1\lor\ell_2\lor y_1)=(0\lor 0\lor 1)=1$,
  $(\neg y_1\lor\ell_3\lor y_2)=(0\lor 1\lor 0)=1$,
  $(\neg y_2\lor\ell_4\lor\ell_5)=(1\lor 0\lor 0)=1$.
- `Статус:` доказано (инвариант «префикс ложен»).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку к Лемме 15.7.3d,
  поясняющую инвариант «префикс ложен» для выбора $g$.

### 16.46. Исследовательский шаг: $\mathrm{Eval}(C,x)$ уже в 3-CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для gate‑list схемы fan‑in 2 Tseitin‑кодирование
  $\mathrm{Eval}_C(x,b)$ состоит из клауз ширины $\le 3$ (формулы для AND/OR/NOT)
  и потому является 3‑CNF без дополнительного blow-up; число клауз $O(s)$.
- `Toy‑тест:` Гейт $g=a\land b$ кодируется тремя клаузами:
  $(\neg g\lor a)$, $(\neg g\lor b)$, $(g\lor\neg a\lor\neg b)$ — ширина $\le 3$.
  Аналогично для $g=a\lor b$ и $g=\neg a$ (ширина $\le 2$).
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте, что для fan‑in 2
  дополнительная редукция в 3‑CNF не нужна.

### 16.47. Исследовательский шаг: граф p‑time функции как $\Delta^b_0$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R(n,C)$ вычисляется за полиномиальное время и
  $|R(n,C)|\le p(n)$, то существует bounded‑формула
  $\mathrm{Graph}_R(n,C,y)$ (кванторы по времени/ячейкам $\le p(n)$),
  такая что $\mathrm{Graph}_R(n,C,y)\iff y=R(n,C)$. Следовательно,
  подстановка $y:=R(n,C)$ в $\mathrm{RedCorr}(n,C,y)$ сохраняет
  $\Pi^b_1$‑форму.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1\oplus C_2$ (первые два бита).
  Тогда $\mathrm{Graph}_R(n,C,y)$ можно записать как bounded‑формулу
  $y\leftrightarrow (C_1\oplus C_2)$. Для $C=10$ получаем $y=1$;
  при $y=0$ формула ложна.
- `Статус:` доказано (стандартная $\Delta^b_0$‑граф‑формализация).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании связать это с формулировкой (H2$_\Pi$),
  где используется $R(n,C)$ вместо $\exists y$.

### 16.48. Исследовательский шаг: устранение $\exists y$ через $\mathrm{Graph}_R$

- `Линза:` Эквивалентность.
- `Утверждение:` Если определить
  $\mathrm{RedCorr}(n,C,y):=\mathrm{Graph}_R(n,C,y)\wedge \mathrm{Err}_{t(n)}(C,y)$,
  то для тотальной p‑time функции $R$ имеем эквивалентность
  $$\forall n\,\forall C\,\exists y\,\mathrm{RedCorr}(n,C,y)\ \iff\
  \forall n\,\forall C\,\mathrm{Err}_{t(n)}(C,R(n,C)).$$
  Значит (H2$_\Pi$) можно писать как $\forall n\,\forall C\,\mathrm{RedCorr}(n,C,R(n,C))$
  без выхода за $\Pi^b_1$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает первый бит $C$, а
  $\mathrm{Err}_{t(n)}(C,y)$ := $(y=1)$.
  Тогда $\exists y\,\mathrm{RedCorr}$ истинно $\iff C_1=1$,
  и это эквивалентно $\mathrm{Err}_{t(n)}(C,R(n,C))$ (также $C_1=1$).
- `Статус:` доказано (подстановка по графу функции).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить это прямо рядом с (H2$_\Pi$)
  в основном тексте.

### 16.49. Исследовательский шаг: ошибка как счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $e_x:=C(x)\oplus g_n(x)$ для всех $x\in\{0,1\}^n$.
  Тогда формула $\mathrm{Err}_{t(n)}(C,g_n)$ эквивалентна условию
  $\sum_x e_x < t(n)2^n$, то есть $\neg\,\mathrm{Count}_{\ge T}(e)$ при
  $T:=\lceil t(n)2^n\rceil$. Множество $S$ из определения $\mathrm{Err}_{t(n)}$
  можно взять равным $\{x:e_x=1\}$.
- `Toy‑тест:` $n=2$, $g(x)=x_1\oplus x_2$, а $C$ ошибается ровно на одном входе.
  Тогда $\sum_x e_x=1$. При $t(n)=1/2$ имеем $T=2$ и $\mathrm{Count}_{\ge 2}(e)=0$,
  то есть ошибка $< t(n)$, как и по определению через множество $S$ размера 1.
- `Статус:` доказано (перепись определения).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте связь $\mathrm{Err}_{t(n)}$
  с $\mathrm{Count}_{\ge T}$ (как в $tt$‑формуле).

### 16.50. Исследовательский шаг: p‑time вычислимость $g$ для CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для каждой исходной клаузы $(\ell_1\lor\cdots\lor\ell_k)$
  значения $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ вычисляются за $O(k)$
  времени, поддерживая префиксное OR. Для всей формулы $g(p)$ вычисляется
  за $O(|\varphi|)$, значит $g$ — p‑time и PV‑функция (доступна в EF).
- `Toy‑тест:` Для $\ell=(0,1,0,0)$ имеем префиксы
  $p_2=\ell_1\lor\ell_2=1$, $p_3=1$, $p_4=1$,
  поэтому $y_1=\neg p_2=0$, $y_2=\neg p_3=0$.
  Вычисление требует одного прохода по клаузе.
- `Статус:` доказано (линейный проход).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить в основном тексте ремарку, что $g$
  p‑time/PV‑вычислима, поэтому EF может использовать её в 15.7.3d.

### 16.51. Исследовательский шаг: размер полинома $P_\varphi$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с $L$ литералами
  полином $P_\varphi(x)=\prod_j S_{C_j}(x)$, где
  $S_{C}(x)=1-\prod_{\ell\in C}(1-\llbracket \ell\rrbracket)$,
  имеет depth‑3 формулу размера $O(L)$ (по одному множителю на литерал
  плюс константы). Поэтому любой полиномиальный blow‑up редукции
  сохраняет условие «$P_\psi$ имеет размер $\mathrm{poly}(|\psi|)$» в Лемме 15.7.4.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge(x_2\lor x_3\lor x_4)$.
  Тогда $S_{C_1}=1-(1-x_1)(1-(1-x_2))$ и
  $S_{C_2}=1-(1-x_2)(1-x_3)(1-x_4)$, и
  $P_\varphi=S_{C_1}\cdot S_{C_2}$ — depth‑3 формула с числом множителей,
  линейным по числу литералов (5).
- `Статус:` доказано (прямой подсчёт).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.4,
  что размер $P_\varphi$ линеен по числу литералов и сохраняется при
  полиномиальном blow‑up редукций.

### 16.52. Исследовательский шаг: нуль на кубе ⇒ тождественный нуль

- `Линза:` Эквивалентность.
- `Утверждение:` Если multilinear‑полином $Q(x_1,\dots,x_n)$ над полем
  удовлетворяет $Q(a)=0$ для всех $a\in\{0,1\}^n$, то $Q\equiv 0$.
  (Значения на булевом кубе единственным образом задают multilinear‑полином.)
- `Toy‑тест:` $n=1$: $Q(x)=ax+b$. Из $Q(0)=b=0$ и $Q(1)=a+b=0$ следует $a=b=0$.
  $n=2$: $Q(x,y)=a xy+ b x + c y + d$. Нули на четырёх точках дают систему
  $d=0$, $b+d=0$, $c+d=0$, $a+b+c+d=0$, значит $a=b=c=d=0$.
- `Статус:` доказано (уникальность multilinear‑представления).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку рядом с санити‑чеком
  (разд. 15.7), что multilinear‑полином однозначно восстанавливается по
  значениям на $\{0,1\}^n$.

### 16.53. Исследовательский шаг: $P_\varphi$ как индикатор выполнимости

- `Линза:` Эквивалентность.
- `Утверждение:` Для булевого присваивания $a\in\{0,1\}^n$ и клаузы
  $C=(\ell_1\lor\cdots\lor\ell_k)$ полином
  $S_C(a)=1-\prod_{i=1}^k(1-\llbracket \ell_i\rrbracket)$ равен $1$
  тогда и только тогда, когда $C(a)=1$. Следовательно,
  $P_\varphi(a)=\prod_j S_{C_j}(a)=1$ тогда и только тогда, когда $\varphi(a)=1$,
  и $\varphi$ невыполнима $\iff P_\varphi$ нулевой на $\{0,1\}^n$.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge x_2$.
  При $a=(1,0)$ имеем $S_{x_1\lor\neg x_2}=1-(1-1)(1-(1-0))=1$,
  $S_{x_2}=1-(1-0)=0$, значит $P_\varphi(a)=0$ и $\varphi(a)=0$.
  При $a=(1,1)$ оба множителя равны $1$, и $\varphi(a)=1$.
- `Статус:` доказано (прямая проверка на булевом кубе).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку около санити‑чека,
  что $P_\varphi$ совпадает с индикатором выполнимости на $\{0,1\}^n$.

### 16.54. Исследовательский шаг: выбор «канонической» реализации счётчика

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для формулы $\mathrm{Count}_{\ge T}$ в $tt(f_n,s,t)$
  достаточно любой стандартной реализации размером $\mathrm{poly}(2^n)$.
  Adder‑tree даёт $O(N\log N)$, Batcher даёт $O(N\log^2 N)$, обе подходят
  для EF и масштаба $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $N=8$: adder‑tree складывает пары битов (4 сумматора),
  затем суммы (2 сумматора), затем финальная сумма (1 сумматор) и компаратор;
  всего $O(N\log N)$ элементов. Sorting‑network на $N=8$ имеет
  $O(N\log^2 N)$ компараторов. Оба дают булеву формулу размера poly.
- `Статус:` доказано (сравнение оценок).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` выбрать один вариант для фиксации в основном тексте рядом
  с Леммой 15.7.1d.

### 16.55. Исследовательский шаг: $m(s)$ полиномиально от $|x|$ при LogLog

- `Линза:` Сжатие/канонизация.
- `Утверждение:` При подстановке $x=2^{2^n}$ имеем $|x|=2^n+1$ и
  $s=2^{n/4}$. Тогда длина кода схемы $m(s)=O(s\log s)=2^{O(n)}$
  удовлетворяет $m(s)\le |x|^{O(1)}$. Значит ограничение $C\le m(s)$
  в (H1$_\Pi$) является bounded‑квантором в масштабе $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $n=4$: $x=2^{16}$, $|x|=17$, $s=2^{1}=2$ и
  $m(s)=O(2\log 2)=O(2)\le |x|$.
- `Статус:` доказано (прямая оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H1$_\Pi$),
  что $m(2^{n/4})$ полиномиально от $|x|$ при LogLog‑масштабе.

### 16.56. Исследовательский шаг: тотальность $R$ в $\mathrm{S}^1_2$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R$ — p‑time редукция, то её тотальность выражается
  $\Sigma^b_1$‑формулой $\forall n\,\forall C\le m(n)\,\exists y\le p(n)\,
  \mathrm{Graph}_R(n,C,y)$ и доказывается в $\mathrm{S}^1_2$ (PV‑вычислимость).
  Это обеспечивает переход от (H2$_\Pi$) к $\forall\exists$‑форме с $y$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1$. Тогда $\mathrm{Graph}_R(n,C,y)$
  — bounded‑формула $y\leftrightarrow C_1$. Очевидно,
  $\forall C\,\exists y\le 1\,\mathrm{Graph}_R(n,C,y)$ истинно.
- `Статус:` доказано (стандартная тотальность PV‑функций).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H2$_\Pi$),
  что тотальность $R$ доказуема в $\mathrm{S}^1_2$.

### 16.57. Исследовательский шаг: кодирование множества ошибок $S$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` В $\mathrm{Err}_{t(n)}$ множество $S\subseteq\{0,1\}^n$
  можно кодировать битовой маской длины $2^n$, то есть числом
  $S<2^{2^n}$. При LogLog‑подстановке $x=2^{2^n}$ имеем $S\le x$,
  поэтому квантор $\exists S$ является bounded, и $\mathrm{Err}_{t(n)}$
  остаётся $\Delta^b_0$‑формулой.
- `Toy‑тест:` $n=2$: $x=2^{2^2}=16$. Любое $S\subseteq\{0,1\}^2$ кодируется
  4‑битной маской $<2^4=16=x$ (например, $S=\{00,11\}$ соответствует $1001_2$).
- `Статус:` доказано (явное кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить рядом с $\mathrm{Err}_{t(n)}$ в L2,
  что квантор по $S$ bounded через $x=2^{2^n}$.

### 16.58. Исследовательский шаг: membership $x\in S$ как бит‑доступ

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Если $S<2^{2^n}$ кодирует подмножество $\{0,1\}^n$ битовой
  маской длины $2^n$, то предикат $x\in S$ эквивалентен $\mathrm{Bit}(S,x)=1$.
  Функция $\mathrm{Bit}$ PV‑вычислима, поэтому условие $x\in S$ является
  $\Delta^b_0$‑формулой при bounded‑кванторах $x<2^n$ и $S<2^{2^n}$.
- `Toy‑тест:` $n=2$, $S=1001_2$ кодирует $\{00,11\}$.
  Тогда $\mathrm{Bit}(S,0)=1$, $\mathrm{Bit}(S,3)=1$, а $\mathrm{Bit}(S,1)=0$.
- `Статус:` доказано (бит‑доступ).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании уточнить в L2, что проверка $x\notin S$
  реализуется через $\mathrm{Bit}(S,x)=0$.

### 16.59. Исследовательский шаг: размер $|S|$ через счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Если $S$ задано битовой маской длины $2^n$, то условие
  $|S|<T$ эквивалентно $\neg\mathrm{Count}_{\ge T}(S)$, где счётчик
  применяется к битам маски. При LogLog‑подстановке $x=2^{2^n}$ порог
  $T\le 2^n\le |x|$, поэтому проверка $|S|<T$ остаётся bounded и $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $S=1011_2$ имеет $|S|=3$. При $T=3$
  $\mathrm{Count}_{\ge 3}(S)=1$, значит $|S|<T$ ложно; при $T=4$
  $\mathrm{Count}_{\ge 4}(S)=0$, значит $|S|<T$ истинно.
- `Статус:` доказано (перепись через счётчик).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что условие $|S|<t(n)2^n$
  можно выразить через $\mathrm{Count}_{\ge T}$ на маске $S$.

### 16.62. Исследовательский шаг: $\mathrm{Err}_{t(n)}$ как $\Delta^b_0$‑формула

- `Линза:` Эквивалентность.
- `Утверждение:` В LogLog‑масштабе $\mathrm{Err}_{t(n)}(C,y)$ можно переписать
  как bounded‑формулу:
  $$\exists S\le 2^{2^n}\ \bigl(\neg\mathrm{Count}_{\ge T}(S)\ \wedge\
  \forall x<2^n\ (\mathrm{Bit}(S,x)=0\to \mathrm{Eval}(C,x)=y(x))\bigr),$$
  где $T=\lceil t(n)2^n\rceil$. Все кванторы bounded (через $x=2^{2^n}$),
  а $\mathrm{Bit}$ и $\mathrm{Eval}$ — PV‑вычислимы, значит
  $\mathrm{Err}_{t(n)}$ является $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $C=y$ (ошибок нет). Берём $S=0000_2$,
  $\mathrm{Count}_{\ge 1}(S)=0$, и для любого $x$ имеем
  $\mathrm{Bit}(S,x)=0\Rightarrow C(x)=y(x)$. Формула истинна.
  Если $C$ ошибается ровно на $x=3$, то берём $S=1000_2$;
  при $t(n)=1/2$ получаем $T=2$ и $\neg\mathrm{Count}_{\ge 2}(S)$ истинно.
- `Статус:` доказано (сведение к бит‑маске и счётчику).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что $\mathrm{Err}_{t(n)}$
  переписывается в явную bounded‑форму через $\mathrm{Bit}$ и счётчик.

### 16.63. Исследовательский шаг: линейный blow‑up в CNF→3‑CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для клаузы длины $k\ge 3$ стандартная цепочная редукция
  $(\ell_1\lor\cdots\lor\ell_k)\mapsto$ цепочку из $k-2$ 3‑клауз
  вводит $k-3$ новых переменных и $3(k-2)$ литералов. Следовательно, если
  $\varphi$ имеет суммарно $L$ литералов, то $r(\varphi)$ имеет размер $O(L)$
  (линейный blow‑up).
- `Toy‑тест:` $k=5$:
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land(\neg y_2\lor\ell_4\lor\ell_5)$.
  Здесь 3 клаузы, 2 новых переменных, 9 литералов, что равно $3(k-2)$.
- `Статус:` доказано (подсчёт по клауза‑в‑клаузу).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.3c
  с явным подсчётом числа клауз/литералов.

### 16.60. Исследовательский шаг: степень $P_\varphi$ полиномиальна

- `Линза:` Инвариант.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с суммарным числом
  литералов $L$ полином $P_\varphi=\prod_j S_{C_j}$ имеет степень
  $\deg(P_\varphi)=\sum_j |C_j|\le L$. После multilinearization степень
  не увеличивается. Следовательно, степень $P_\varphi$ и $\mathrm{ML}(P_\varphi)$
  полиномиальна в $|\varphi|$, что согласуется с требованиями PIT для ROABP.
- `Toy‑тест:` $\varphi=(x_1\lor x_2)\wedge(\neg x_2\lor x_3\lor x_4)$:
  $\deg S_{C_1}=2$, $\deg S_{C_2}=3$, значит $\deg P_\varphi=5$ (полиномиально).
- `Статус:` доказано (прямой подсчёт степени).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку возле Леммы 15.7.4,
  что степень $\mathrm{ML}(P_\varphi)$ ограничена $O(|\varphi|)$.

### 16.61. Исследовательский шаг: $r(\varphi)$ логически усиливает $\varphi$

- `Линза:` Инвариант.
- `Утверждение:` Для стандартной редукции CNF→3‑CNF формула $r(\varphi)$
  логически влечёт $\varphi$ по исходным переменным: для каждой клаузы
  $(\ell_1\lor\cdots\lor\ell_k)$ цепочка 3‑клауз в $r(\varphi)$
  удовлетворима только если исходная клауза истинна. Следовательно,
  $r(\varphi)\to \varphi$ (но обратное неверно).
- `Toy‑тест:` Клауза $(\ell_1\lor\ell_2\lor\ell_3\lor\ell_4)$ заменяется на
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor\ell_4)$.
  Если все $\ell_i=0$, то первая клауза требует $y_1=1$, а вторая даёт
  $(\neg y_1\lor 0\lor 0)=0$, противоречие. Значит $r(\varphi)$ возможно
  только при истинной исходной клаузе.
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.3c,
  что $r(\varphi)\Rightarrow \varphi$, а для обратного направления нужен $g$.
