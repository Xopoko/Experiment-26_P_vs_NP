# P vs NP — исследовательские шаги (16.x)

Этот подноутбук содержит короткие "А что если…?" шаги и контрпримеры.
Главный файл остаётся `P_vs_NP.md`.

[Открыть главный ноутбук](../../P_vs_NP.md)

### 16.3. Исследовательский шаг: decision vs search для SAT

**Вопрос («А что если…?»).** Может ли SAT решаться в полиномиальное время,
а задача поиска удовлетворяющего присваивания оставаться существенно труднее?

**Определение (SAT‑SEARCH).** По входу CNF‑формулы $\varphi$: если $\varphi$ выполнима,
выдать удовлетворяющее присваивание; иначе вывести $\bot$.

**Лемма 16.3.** Существует полиномиальный алгоритм, который решает SAT‑SEARCH,
используя $O(n)$ вызовов решения SAT (где $n$ — число переменных).
В частности, если $\mathrm{SAT}\in\mathrm{P}$, то SAT‑SEARCH $\in\mathrm{FP}$.

*Доказательство.* Сначала одним вызовом проверяем, выполнима ли $\varphi$.
Если нет — возвращаем $\bot$.
Иначе последовательно фиксируем переменные: для $i=1..n$ проверяем выполнимость
$\varphi\upharpoonright (x_i=0)$. Если выполнима — ставим $x_i:=0$,
иначе $x_i:=1$ (при этом $\varphi\upharpoonright (x_i=1)$ обязана быть выполнима,
иначе исходная $\varphi$ невыполнима). Индукцией по $i$ сохраняется выполнимость,
и после $n$ шагов получаем удовлетворяющее присваивание.
Время — $O(n)$ вызовов SAT и полиномиальные подстановки. $\square$

**Вывод.** Попытка разделить P и NP через «decision проще, чем search»
для SAT не работает: SAT саморедуцируем.

**Барьер‑чек.**
- *Релятивизация:* да, алгоритм оракульный (тот же аргумент для $\mathrm{SAT}^A$).
- *Natural proofs:* неприменимо (нет схемных нижних оценок).
- *Algebrization:* неприменимо (нет алгебраизации/полиномов; чисто комбинаторика).

### 16.4. Исследовательский шаг: sparse NP‑полный ⇒ P=NP

**Вопрос («А что если…?»).** Что если у NP есть разреженный (sparse) NP‑полный язык?

**Определение (sparse).** Язык $S$ разрежен, если существует полином $p$, что
$|S\cap \Sigma^{\le m}|\le p(m)$ для всех $m$.

**Лемма 16.4 (Мэхэни).** Если существует разреженный NP‑полный язык
относительно $\le_m^p$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $S$ sparse и $\mathrm{SAT}\le_m^p S$ через $f$.
Зафиксируем полином $p$ для sparsity и полином $q$, ограничивающий длину $f(\psi)$
на формулах $\psi$ размера $\mathrm{poly}(|\varphi|)$.
Положим $K:=p(q(|\varphi|))$. Построим алгоритм SAT.

Поддерживаем список $L$ формул с инвариантом:
(i) $|L|\le K$, (ii) если $\varphi$ выполнима, то выполнима хотя бы одна формула из $L$.
Старт: $L=\{\varphi\}$. Для переменной $x_i$ каждую $\psi\in L$ заменяем
на $\psi\upharpoonright(x_i=0)$ и $\psi\upharpoonright(x_i=1)$,
получая $L'$, затем применяем «подрезку».
(Если нужно оставаться в CNF, используем стандартное полиномиальное Tseitin‑кодирование дизъюнкций.)

**Pruning‑лемма.** Для списка $\varphi_1,\dots,\varphi_k$ (где $k> K$) можно за полиномиальное
время удалить хотя бы одну формулу, сохранив (ii).

Доказательство pruning: положим $\psi_i:=\varphi_1\lor\cdots\lor\varphi_i$ и $y_i:=f(\psi_i)$.
- Если найдены $i<j$ с $y_i=y_j$, то $\psi_i$ и $\psi_j$ имеют одинаковую выполнимость,
  поэтому удаление $\varphi_{i+1},\dots,\varphi_j$ сохраняет (ii).
- Иначе все $y_i$ различны. Тогда среди $\psi_i$ выполнимых $\le K$ (иначе в $S$ было бы
  $>K$ различных строк). Выполнимые $\psi_i$ образуют суффикс, значит при наличии
  выполнимой формулы она среди последних $K$; удаляем первые $k-K$.

Повторяя pruning, держим $|L|\le K$. После обработки всех переменных все формулы в $L$
константны; проверяем, есть ли истинная. Это полиномиально, значит $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент остаётся верным с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.5. Исследовательский шаг: p‑bounded резолюция?

**Вопрос («А что если…?»).** Может ли резолюция быть p‑bounded для всех
невыполнимых CNF‑формул?

**Лемма 16.5.** Если резолюция p‑bounded, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* При p‑bounded резолюции каждая невыполнимая CNF
имеет полиномиальную рефутацию. Проверка корректности резолюционного вывода
полиномиальна, значит $\mathrm{UNSAT}\in\mathrm{NP}$.
Так как $\mathrm{UNSAT}$ coNP‑полна, получаем $\mathrm{coNP}\subseteq\mathrm{NP}$,
а значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к предпосылке.** Формулы $\mathrm{PHP}^{n}_{n+1}$ требуют
экспоненциальных резолюционных рефутаций (Теорема 15.2),
так что резолюция не является p‑bounded в общем случае.

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированной proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.6. Исследовательский шаг: резолюция vs CP (p‑симуляция)

**Вопрос («А что если…?»).** Может ли резолюция p‑симулировать систему Cutting Planes (CP)?

**Лемма 16.6.** Резолюция не p‑симулирует CP.

*Доказательство (контрпример).* Предположим, что резолюция p‑симулирует CP.
Тогда любую CP‑рефутацию размера $\mathrm{poly}(n)$ можно преобразовать
в резолюционную рефутацию размера $\mathrm{poly}(n)$.
По Теореме 15.8 формулы $\mathrm{PHP}^{n}_{n+1}$ имеют полиномиальные CP‑рефутации,
а по Теореме 15.2 любая резолюционная рефутация $\mathrm{PHP}^{n}_{n+1}$
имеет экспоненциальный размер. Противоречие. $\square$

**Барьер‑чек.**
- *Релятивизация:* неприменимо (утверждение о конкретных proof‑system).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.7. Исследовательский шаг: приближение MAX‑3SAT

**Вопрос («А что если…?»).** Что если существует полиномиальный алгоритм,
который отличает выполнимые 3CNF от формул, где нельзя удовлетворить
более чем $(1-\varepsilon)$ долю клауз (для некоторого константного $\varepsilon>0$)?

**Определение (GAP‑3SAT$_\varepsilon$).** Вход — 3CNF $\varphi$.
YES: $\varphi$ выполнима. NO: любая подстановка удовлетворяет
не более $(1-\varepsilon)$ доли клауз.

**Лемма 16.7.** Если для некоторого $\varepsilon>0$ задача GAP‑3SAT$_\varepsilon$
решается за полиномиальное время, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* По теореме PCP (Раздел 16.2) существует константа
$\varepsilon>0$, для которой GAP‑3SAT$_\varepsilon$ NP‑трудна.
Если бы она решалась за полиномиальное время, то решалась бы SAT,
следовательно $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* не обязано релятивизировать (PCP использует аритметизацию).
- *Natural proofs:* неприменимо (это не схемные нижние оценки).
- *Algebrization:* не ясно; доказательство PCP не сводится к чистой алгебризации.

### 16.8. Исследовательский шаг: NP‑ и coNP‑полнота одного языка

**Вопрос («А что если…?»).** Может ли существовать язык $L$, который
NP‑полон и coNP‑полон (по $\le_m^p$)?

**Лемма 16.8.** Если существует язык, который одновременно NP‑полон и coNP‑полон
(по $\le_m^p$), то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $L$ — такой язык. Тогда $L\in\mathrm{NP}\cap\mathrm{coNP}$.
Для любого $A\in\mathrm{NP}$ существует полиномиальная редукция $f$ такая, что
$x\in A \iff f(x)\in L$. Тогда
$$x\in A^c \iff f(x)\in L^c.$$
Поскольку $L\in\mathrm{coNP}$, имеем $L^c\in\mathrm{NP}$, значит $A^c\in\mathrm{NP}$,
то есть $A\in\mathrm{coNP}$. Следовательно, $\mathrm{NP}\subseteq\mathrm{coNP}$.
Симметрично, из coNP‑полноты $L$ и того, что $L\in\mathrm{NP}$, получаем
$\mathrm{coNP}\subseteq\mathrm{NP}$. Итак, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.9. Исследовательский шаг: SAT ≤ UNSAT?

**Вопрос («А что если…?»).** Может ли SAT полиномиально сводиться к UNSAT?

**Лемма 16.9.** Если $\mathrm{SAT}\le_m^p\mathrm{UNSAT}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $f$ — редукция SAT к UNSAT.
Тогда SAT принадлежит coNP (coNP замкнут по $\le_m^p$‑редукциям).
Так как SAT NP‑полна, получаем $\mathrm{NP}\subseteq\mathrm{coNP}$.
Берём дополнения: $\mathrm{coNP}\subseteq\mathrm{NP}$. Следовательно, $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется для оракулов).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.


### 16.10. Исследовательский шаг: Unique-SAT и рандомизация

**Вопрос («А что если…?»).** Что если Unique-SAT решается за полиномиальное время — следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (Unique-SAT, promise).** Вход: CNF‑формула $\varphi$ над $n$ переменными.
YES: $\varphi$ имеет ровно одно удовлетворяющее присваивание.
NO: $\varphi$ не имеет удовлетворяющих присваиваний.
(Иные случаи не обязаны обрабатываться корректно.)

**Лемма 16.10 (Valiant-Vazirani).** Существует вероятностная полиномиальная редукция,
которая по формуле $\varphi$ строит CNF‑формулу $\varphi'$ такую, что:
- если $\varphi$ невыполнима, то $\varphi'$ невыполнима всегда;
- если $\varphi$ выполнима, то с вероятностью $\ge 1/(8n)$ $\varphi'$ имеет ровно одно решение.

В частности, если Unique-SAT $\in\mathrm{P}$, то $\mathrm{SAT}\in\mathrm{RP}$.

*Доказательство.* Пусть $S\subseteq\{0,1\}^n$ — множество решений $\varphi$, $s=|S|$.
Выбираем $m\in\{1,\dots,n{+}1\}$, случайную попарно независимую хэш‑функцию
$h:\{0,1\}^n\to\{0,1\}^m$ (например, $h(x)=Ax\oplus b$ над $\mathbb{F}_2$)
и случайный $t\in\{0,1\}^m$. Строим
$$\varphi' := \varphi\land (h(x)=t),$$
кодируя $m$ линейных уравнений в CNF с полиномиальным ростом (кодирование Тсейтина).
Если $\varphi$ невыполнима, то $\varphi'$ тоже.

Пусть $s\ge 1$. Существует $m$ такое, что $2^{m-2}< s\le 2^{m-1}$.
Положим $Z=|S\cap h^{-1}(t)|=\sum_{x\in S} I_x$, где $I_x=[h(x)=t]$.
Тогда $\mu=\mathbb{E}[Z]=s/2^m\in(1/4,1/2]$ и по попарной независимости
$$\mathbb{E}[Z(Z-1)]=\sum_{x\ne y}\Pr[I_x=I_y=1]=\frac{s(s-1)}{2^{2m}}\le \mu^2.$$
Так как при $Z\ge 2$ выполнено $Z(Z-1)\ge Z$, получаем
$$\Pr[Z=1]\ge \mu-\mathbb{E}[Z(Z-1)]\ge \mu-\mu^2\ge 3/16.$$
Следовательно, для «правильного» $m$ вероятность уникальности $\ge 3/16$.
При случайном $m$ получаем успех $\ge 1/(8n)$ (с запасом).
Повторением (усилением) получаем RP-алгоритм при наличии решателя Unique-SAT. $\square$

**Вывод/провал.** Unique-SAT $\in\mathrm{P}$ даёт лишь $\mathrm{SAT}\in\mathrm{RP}$.
Чтобы получить $\mathrm{P}=\mathrm{NP}$, нужна дерэндомизация (например, $\mathrm{RP}=\mathrm{P}$)
или детерминированная «изоляция» решений.

**Барьер‑чек.**
- *Релятивизация:* да (редукция комбинаторная и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо/неочевидно.

### 16.11. Исследовательский шаг: NP ⊆ BPP ⇒ коллапс PH

**Вопрос («А что если…?»).** Что если SAT (или весь NP) решается в BPP — следует ли коллапс полиномиальной иерархии?

**Определение (BPP).** Язык $L\in\mathrm{BPP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 2/3,\quad x\notin L\Rightarrow \Pr[A(x)=0]\ge 2/3.$$

**Лемма 16.11.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то $\mathrm{PH}\subseteq\mathrm{BPP}$.
(В частности, если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{PH}$ коллапсирует в BPP.)

*Доказательство.* Сначала покажем $\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}$.
Пусть $M^{O}$ — BPP‑машина, делающая не более $q(n)$ запросов к оракулу $O\in\mathrm{BPP}$.
Каждый запрос $y$ симулируем алгоритмом $A_O(y)$, усиливая его до ошибки
$\delta:=1/(10q(n))$ повторением $O(\log q(n))$ раз и мажоритарным голосованием.
По объединённой вероятности (union bound) шанс, что хоть один из ответов оракула
ошибочен, не превосходит $q(n)\cdot\delta\le 1/10$.
Условно на правильных ответах оракула $M$ ошибается с вероятностью $\le 1/10$.
Итого общая ошибка $\le 1/5<1/3$, а время остаётся полиномиальным.
Следовательно, $\mathrm{BPP}^{\mathrm{BPP}}\subseteq\mathrm{BPP}$;
обратное включение тривиально.

Теперь индукция по $k$ для $\Sigma_k^p$.
База: $\Sigma_1^p=\mathrm{NP}\subseteq\mathrm{BPP}$ по предположению.
Переход: если $\Sigma_k^p\subseteq\mathrm{BPP}$, то
$$\Sigma_{k+1}^p=\mathrm{NP}^{\Sigma_k^p}\subseteq\mathrm{BPP}^{\mathrm{BPP}}=\mathrm{BPP}.$$
Значит все уровни PH лежат в BPP, т.е. $\mathrm{PH}\subseteq\mathrm{BPP}$. $\square$

**Вывод/провал.** Предположение $\mathrm{SAT}\in\mathrm{BPP}$ не даёт $\mathrm{P}=\mathrm{NP}$,
а лишь коллапс PH в BPP. Для $\mathrm{P}=\mathrm{NP}$ нужна дерэндомизация
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер‑чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.12. Исследовательский шаг: BPP in Sigma2 cap Pi2 (Sipser-Gacs-Lautemann)

**Вопрос ("А что если...?").** Можно ли поместить BPP на втором уровне PH?

**Лемма 16.12 (Sipser-Gacs-Lautemann).** $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$. Существует вероятностная машина $R(x,r)$,
работающая за $\mathrm{poly}(|x|)$ и использующая $m$ случайных бит, такая что
ошибка $\le 1/3$. Усилим (повторением и большинством) до ошибки
$\varepsilon:=2^{-2n}$, где $n=|x|$; это даёт новое $m=\mathrm{poly}(n)$.
Положим $G_x:=\{r\in\{0,1\}^m:\ R(x,r)=1\}$.
Тогда
$$x\in L\Rightarrow |G_x|\ge (1-\varepsilon)2^m,\quad x\notin L\Rightarrow |G_x|\le \varepsilon 2^m.$$

Зафиксируем $k:=m+1$. Для $r_1,\dots,r_k\in\{0,1\}^m$ рассмотрим
$$U:=\bigcup_{i=1}^k (G_x\oplus r_i),$$
где $\oplus$ — поразрядное XOR.

(1) Пусть $x\in L$. Выберем $r_i$ равномерно и независимо. Для фиксированного $z$
$$\Pr[z\notin U]=(1-|G_x|/2^m)^k\le \varepsilon^k.$$
По объединённой вероятности
$$\Pr[U\ne\{0,1\}^m]\le 2^m\varepsilon^k\le 2^m\cdot 2^{-2n(m+1)}<1.$$
Следовательно, существует набор $r_1,\dots,r_k$ с $U=\{0,1\}^m$.

(2) Пусть $x\notin L$. Тогда для любых $r_1,\dots,r_k$ имеем
$|U|\le k|G_x|\le k\varepsilon 2^m<2^m$ (для всех достаточно больших $n$),
значит существует $z$ с $z\notin U$.

Итак,
$$x\in L\iff \exists r_1,\dots,r_k\ \forall z\ \exists i\ R(x,z\oplus r_i)=1,$$
что есть $\Sigma_2^p$-формула (так как $k,m=\mathrm{poly}(n)$).
Так как $\mathrm{BPP}$ замкнут по дополнению, получаем также
$L\in\Pi_2^p$. Значит $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$. $\square$

**Вывод/провал.** Лемма лишь помещает $\mathrm{BPP}$ во второй уровень PH;
сама по себе она не даёт $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный, переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.13. Исследовательский шаг: NP in BPP => PH = Sigma2^p

**Вопрос ("А что если...?").** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, коллапсирует ли PH на втором уровне?

**Лемма 16.13.** Если $\mathrm{NP}\subseteq\mathrm{BPP}$, то
$$\mathrm{PH}=\Sigma_2^p=\Pi_2^p.$$

*Доказательство.* По Лемме 16.11 получаем $\mathrm{PH}\subseteq\mathrm{BPP}$.
По Лемме 16.12 имеем $\mathrm{BPP}\subseteq\Sigma_2^p\cap\Pi_2^p$.
Следовательно,
$$\mathrm{PH}\subseteq\Sigma_2^p\cap\Pi_2^p\subseteq\Sigma_2^p.$$
Но $\Sigma_2^p\subseteq\mathrm{PH}$ по определению, значит
$\mathrm{PH}=\Sigma_2^p$. Аналогично $\mathrm{PH}=\Pi_2^p$.
Следовательно, $\Sigma_2^p=\Pi_2^p$. $\square$

**Вывод/провал.** Даже при $\mathrm{NP}\subseteq\mathrm{BPP}$ получаем лишь коллапс PH
на уровне 2; до $\mathrm{P}=\mathrm{NP}$ это не доводит без дерэндомизации
(например, $\mathrm{BPP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (используются релятивизирующие шаги 16.11 и 16.12).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.14. Исследовательский шаг: SAT в RP => NP = RP

**Вопрос ("А что если...?").** Что если SAT решается в RP — следует ли равенство $\mathrm{NP}=\mathrm{RP}$?

**Определение (RP).** Язык $L\in\mathrm{RP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]\ge 1/2,\quad x\notin L\Rightarrow \Pr[A(x)=1]=0.$$

**Лемма 16.14.** Если $\mathrm{SAT}\in\mathrm{RP}$, то $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* (1) $\mathrm{RP}\subseteq\mathrm{NP}$: пусть $A$ использует $m(n)$ случайных бит.
НМТ угадывает строку $r\in\{0,1\}^{m(n)}$ и принимает тогда и только тогда,
когда $A(x,r)=1$. Если $x\in L$, существует принимающий $r$;
если $x\notin L$, принимающих $r$ нет.

(2) $\mathrm{NP}\subseteq\mathrm{RP}$ при $\mathrm{SAT}\in\mathrm{RP}$:
пусть $L\in\mathrm{NP}$ и $f$ — полиномиальная many-one редукция $L\le_m^p\mathrm{SAT}$.
Алгоритм для $L$ вычисляет $y=f(x)$ и запускает RP-алгоритм для SAT на $y$.
Если $x\notin L$, то $y$ невыполним и RP-алгоритм всегда отвергает.
Если $x\in L$, то $y$ выполним и RP-алгоритм принимает с вероятностью $\ge 1/2$.
Значит $L\in\mathrm{RP}$.

Итак, $\mathrm{NP}=\mathrm{RP}$. $\square$

**Вывод/провал.** Даже если SAT в RP, получаем лишь $\mathrm{NP}=\mathrm{RP}$,
а не $\mathrm{P}=\mathrm{NP}$ без дерэндомизации (например, $\mathrm{RP}=\mathrm{P}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.15. Исследовательский шаг: P-uniform схемы для SAT

**Вопрос ("А что если...?").** Что если SAT имеет полиномиальные P-uniform схемы?

**Определение (P-uniform).** Семейство схем $\{C_n\}$ называется P-uniform, если
существует детерминированная полиномиальная машина $U$, которая по входу $1^n$
выводит описание схемы $C_n$.

**Лемма 16.15.** Если SAT имеет P-uniform семейство схем полиномиального размера,
то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $U$ строит $C_n$ за $\mathrm{poly}(n)$.
На входе формулы $\varphi$ длины $n$ вычисляем $C_n$ с помощью $U$ и затем
вычисляем $C_n(\varphi)$ за время $\mathrm{poly}(n)$ (размер схемы полиномиален).
Следовательно, $\mathrm{SAT}\in\mathrm{P}$, а значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить P-uniform на $\mathrm{P/poly}$.
Существует tally-язык $L\subseteq\{1\}^*$, не лежащий в $\mathrm{P}$
(диагонализация как в теореме иерархии по времени, Раздел 12).
Для каждого $n$ единственный вход длины $n$ - строка $1^n$, поэтому
константная схема размера $O(1)$ решает $L$ на длине $n$.
Следовательно, $L\in\mathrm{P/poly}$, но $L\notin\mathrm{P}$.

**Вывод/провал.** Полиномиальные неравномерные схемы не дают $\mathrm{P}=\mathrm{NP}$;
критична униформность построения.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - симуляция и диагонализация).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.16. Исследовательский шаг: P-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-immune язык?

**Определение (P-immune).** Бесконечный язык $L$ называется P-immune, если у него нет
бесконечного подмножества в $\mathrm{P}$.

**Лемма 16.16.** Если существует P-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Но тогда $L$ само является бесконечным подмножеством $L$, лежащим в $\mathrm{P}$,
что противоречит P-иммунности. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-immune. Например, SAT имеет
бесконечное подмножество в $\mathrm{P}$: формулы вида
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i)$$
всегда выполнимы и распознаются за полиномиальное время. Следовательно, SAT не P-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулами).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.17. Исследовательский шаг: P-bi-immune в NP

**Вопрос ("А что если...?").** Что если в NP существует P-bi-immune язык?

**Определение (P-bi-immune).** Бесконечный язык $L$ называется P-bi-immune, если
$L$ и $\overline{L}$ являются P-immune.

**Лемма 16.17.** Если существует P-bi-immune язык $L\in\mathrm{NP}$, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим противное: $\mathrm{P}=\mathrm{NP}$. Тогда $L\in\mathrm{P}$.
Так как $\mathrm{P}$ замкнут по дополнению, имеем $\overline{L}\in\mathrm{P}$.
Но тогда и $L$, и $\overline{L}$ содержат бесконечные подмножества в $\mathrm{P}$
(они сами), что противоречит P-immune. Следовательно, $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Контрпример к усилению.** NP-полнота не означает P-bi-immune. Для SAT есть
бесконечное подмножество в $\mathrm{P}$, например формулы
$$\bigwedge_{i=1}^m (x_i\lor\neg x_i),$$
а для $\overline{\mathrm{SAT}}$ есть бесконечное подмножество в $\mathrm{P}$, например
$$\bigwedge_{i=1}^m (x_i\land\neg x_i).$$
Следовательно, SAT не P-bi-immune.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.18. Исследовательский шаг: NP-hard P-selective

**Вопрос ("А что если...?").** Что если существует P-selective язык, NP-трудный по $\le_m^p$?

**Определение (P-selective).** Язык $S$ называется P-selective, если существует
детерминированная полиномиальная функция $s(x,y)$, возвращающая $x$ или $y$, такая что
если $x\in S$ или $y\in S$, то $s(x,y)\in S$.

**Лемма 16.18.** Если существует P-selective язык $S$ и $\mathrm{SAT}\le_m^p S$,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $f$ - полиномиальная редукция SAT к $S$ и $s$ - селектор для $S$.
Для формулы $\varphi$ последовательно фиксируем переменные. На шаге $i$ строим
$\varphi_0=\varphi\upharpoonright(x_i=0)$ и $\varphi_1=\varphi\upharpoonright(x_i=1)$,
вычисляем $f(\varphi_0), f(\varphi_1)$ и берём
$$w:=s(f(\varphi_0), f(\varphi_1)).$$
Если $w=f(\varphi_0)$, ставим $x_i:=0$, иначе $x_i:=1$ (если оба равны, выбор не важен).
Если $\varphi$ выполнима, то хотя бы одна из $\varphi_0,\varphi_1$ выполнима,
значит соответствующий образ лежит в $S$, и селектор выбирает выполнимую ветвь.
Индукцией после всех шагов получаем удовлетворяющее присваивание, которое проверяем.
Если $\varphi$ невыполнима, любая ветвь приведёт к ложному присваиванию, проверка отвергнет.
Время полиномиально. Значит $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** P-selective само по себе не означает трудность.
Например, язык $L=\{x: x_1=1\}$ находится в $\mathrm{P}$ и P-selective,
но не NP-труден (если $\mathrm{P}\ne\mathrm{NP}$).

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.19. Исследовательский шаг: SAT в coRP => NP = coNP

**Вопрос ("А что если...?").** Что если SAT решается в coRP - следует ли $\mathrm{NP}=\mathrm{coNP}$?

**Определение (coRP).** Язык $L\in\mathrm{coRP}$, если существует вероятностная
полиномиальная машина $A$, что для всех $x$:
$$x\in L\Rightarrow \Pr[A(x)=1]=1,\quad x\notin L\Rightarrow \Pr[A(x)=1]\le 1/2.$$

**Лемма 16.19.** Если $\mathrm{SAT}\in\mathrm{coRP}$, то $\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* (1) $\mathrm{coRP}\subseteq\mathrm{coNP}$: если $L\in\mathrm{coRP}$,
то $\overline{L}\in\mathrm{RP}$, а $\mathrm{RP}\subseteq\mathrm{NP}$ (угадать случайные биты).
Значит $L\in\mathrm{coNP}$.

(2) coRP замкнут по детерминированным $\le_m^p$-редукциям: если $L\le_m^p A$ и
$A\in\mathrm{coRP}$, то алгоритм для $A$ на входе $f(x)$ даёт корректную coRP
процедуру для $L$.

Так как SAT NP-полон, из $\mathrm{SAT}\in\mathrm{coRP}$ получаем
$\mathrm{NP}\subseteq\mathrm{coRP}\subseteq\mathrm{coNP}$, значит $\mathrm{NP}=\mathrm{coNP}$. $\square$

**Контрпример к усилению.** coRP само по себе не означает NP-трудность.
Например, язык $\Sigma^*$ лежит в $\mathrm{coRP}\cap\mathrm{P}$ и не может быть
NP-трудным по $\le_m^p$, иначе следовало бы $\mathrm{P}=\mathrm{NP}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.20. Исследовательский шаг: точный подсчет решений SAT

**Вопрос ("А что если...?").** Что если #SAT вычислима за полиномиальное время?

**Определение (#SAT).** Для CNF-формулы $\varphi$ функция $\#\mathrm{SAT}(\varphi)$
равна числу удовлетворяющих присваиваний.

**Лемма 16.20.** Если $\#\mathrm{SAT}$ вычислима за полиномиальное время,
то $\mathrm{SAT}\in\mathrm{P}$, следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* На входе формулы $\varphi$ вычисляем $\#\mathrm{SAT}(\varphi)$.
Если значение больше нуля, то $\varphi$ выполнима, иначе нет.
Это решает SAT за полиномиальное время, значит $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Нельзя заменить точный подсчет на подсчет по модулю 2.
Формула
$$\psi=(x_1\lor x_2)\land(\neg x_1\lor \neg x_2)$$
имеет ровно 2 решения (четность 0), а формула
$$\theta=(x_1\land\neg x_1)$$
имеет 0 решений (четность 0). Следовательно, знание $\#\mathrm{SAT}(\cdot)\bmod 2$
не позволяет решать SAT в общем случае.

**Барьер-чек.**
- *Релятивизация:* да (аргумент - прямое вычисление числа решений).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.21. Исследовательский шаг: FPRAS для #SAT

**Вопрос ("А что если...?").** Что если существует FPRAS для #SAT?

**Определение (FPRAS для #SAT).** Рандомизированный алгоритм $A$ — FPRAS для
$\#\mathrm{SAT}$, если для любой формулы $\varphi$, параметров $\varepsilon\in(0,1)$ и
$\delta\in(0,1)$ он работает за $\mathrm{poly}(|\varphi|,1/\varepsilon,\log(1/\delta))$ и
с вероятностью $\ge 1-\delta$ возвращает число $\widetilde{N}$, такое что
$$ (1-\varepsilon)\#\mathrm{SAT}(\varphi)\le \widetilde{N}\le (1+\varepsilon)\#\mathrm{SAT}(\varphi). $$

**Лемма 16.21.** Если для $\#\mathrm{SAT}$ существует FPRAS, то $\mathrm{SAT}\in\mathrm{RP}$,
следовательно $\mathrm{NP}=\mathrm{RP}$.

*Доказательство.* Используем саморедукцию поиска (шаг 16.3), заменив вызовы SAT
на FPRAS для $\#\mathrm{SAT}$.

Пусть $\varphi$ над $n$ переменными. Для $i=1..n$ рассмотрим
$\varphi_0:=\varphi\upharpoonright(x_i=0)$ и $\varphi_1:=\varphi\upharpoonright(x_i=1)$ и
запустим FPRAS на обеих формулах с $\varepsilon=1/2$ и $\delta:=1/(10n)$. Если обе оценки равны 0,
отвергаем; иначе выбираем ветвь с ненулевой оценкой и продолжаем. В конце получаем присваивание $a$
и детерминированно проверяем $\varphi(a)=1$; принимаем тогда и только тогда, когда проверка проходит.

Если $\varphi$ невыполнима, то проверка никогда не пройдёт, значит мы всегда отвергаем.
Если $\varphi$ выполнима, то при успешных вызовах FPRAS нулевая оценка появляется тогда и только тогда,
когда соответствующая ветвь имеет 0 решений, поэтому мы всегда можем выбрать ветвь с хотя бы одним решением
и дойти до удовлетворяющего $a$. По объединённой вероятности все $2n$ вызовов успешны с вероятностью
$\ge 1-2n\delta\ge 4/5$, значит принимаем с вероятностью $\ge 1/2$.
Итак, $\mathrm{SAT}\in\mathrm{RP}$, а по Лемме 16.14 $\mathrm{NP}=\mathrm{RP}$. $\square$

**Контрпример к усилению.** Знание $\#\mathrm{SAT}(\varphi)\bmod 2$ не решает SAT
(см. контрпример в шаге 16.20), значит «аппроксимация» без гарантии
мультипликативной точности может быть недостаточна.

**Барьер-чек.**
- *Релятивизация:* да (аргумент комбинаторный и переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.22. Исследовательский шаг: SAT в ZPP => NP = ZPP

**Вопрос ("А что если...?").** Что если SAT решается в ZPP - следует ли равенство $\mathrm{NP}=\mathrm{ZPP}$?

**Определение (ZPP).** $\mathrm{ZPP}=\mathrm{RP}\cap\mathrm{coRP}$; эквивалентно,
это класс языков, распознаваемых рандомизированными алгоритмами ожидаемого
полиномиального времени без ошибок (Las Vegas).

**Лемма 16.22.** Если $\mathrm{SAT}\in\mathrm{ZPP}$, то $\mathrm{NP}=\mathrm{ZPP}$.

*Доказательство.* Так как SAT NP-полна и ZPP замкнут по детерминированным
$\le_m^p$-редукциям, из $\mathrm{SAT}\in\mathrm{ZPP}$ следует
$\mathrm{NP}\subseteq\mathrm{ZPP}$. С другой стороны, $\mathrm{ZPP}\subseteq\mathrm{RP}\subseteq\mathrm{NP}$.
Следовательно, $\mathrm{NP}=\mathrm{ZPP}$. $\square$

**Вывод/провал.** Равенство $\mathrm{NP}=\mathrm{ZPP}$ само по себе не даёт
$\mathrm{P}=\mathrm{NP}$ без дерэндомизации $\mathrm{ZPP}=\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.23. Исследовательский шаг: SAT почти всюду в P

**Вопрос ("А что если...?").** Что если SAT решается за полиномиальное время на всех достаточно больших длинах входа?

**Определение (a.e.-P).** Язык $L$ называется *почти всюду* в $\mathrm{P}$, если
существует $n_0$ и полиномиальный алгоритм $A$, такой что для всех $x$ с $|x|\ge n_0$:
$A(x)$ решает принадлежность $x\in L$.

**Лемма 16.23.** Если SAT почти всюду в $\mathrm{P}$, то $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ корректен для всех длины $\ge n_0$.
Для длин $<n_0$ заранее вычислим ответы (это конечное множество строк) и
зашьем их в алгоритм. Тогда получаем полиномиальный алгоритм, решающий SAT на всех входах.
Следовательно, $\mathrm{SAT}\in\mathrm{P}$ и $\mathrm{P}=\mathrm{NP}$. $\square$

**Контрпример к усилению.** Условие "в $\mathrm{P}$ на бесконечном числе длин" недостаточно.
Пусть $H\in\mathrm{DTIME}(2^n)\setminus\mathrm{P}$ (существует по теореме иерархии по времени).
Определим
$$L:=\{z:\ |z|\ \text{четно}\}\ \cup\ \{1^{|x|}0x:\ x\in H\}.$$
Тогда $L$ тривиален на всех четных длинах (значит "легок" на бесконечно многих длинах),
но $H\le_m^p L$ по редукции $x\mapsto 1^{|x|}0x$ (длина $2|x|+1$), поэтому из $L\in\mathrm{P}$
следовало бы $H\in\mathrm{P}$ — противоречие. Значит условие "на бесконечно многих длинах" не даёт $\mathrm{P}$.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.24. Исследовательский шаг: SAT в RP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в RP, используя лишь $O(\log n)$ случайных бит?

**Определение (RP$_{\log}$).** Язык $L\in\mathrm{RP}_{\log}$, если существует RP-машина,
которая на входах длины $n$ использует не более $c\log n$ случайных битов.

**Лемма 16.24.** Если $\mathrm{SAT}\in\mathrm{RP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ - RP-алгоритм для SAT с $m(n)\le c\log n$ случайных битов.
Для входа $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$ случайные строки $r$ и
запустим $A(\varphi,r)$.
Если $\varphi$ невыполнима, то $A$ никогда не принимает, значит мы отвергаем.
Если $\varphi$ выполнима, существует хотя бы один $r$ с принятием, значит мы принимаем.
Время полиномиально. $\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
занимает $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий RP.
Следовательно, ограничение $O(\log n)$ существенно.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.25. Исследовательский шаг: NP-полный язык в io-P

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на бесконечно многих длинах входа, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (io-P).** Язык $L$ принадлежит io-P, если существует полиномиальный
алгоритм $A$ и бесконечное множество длин $N\subseteq\mathbb{N}$, такое что для всех
$n\in N$ и всех строк $x$ длины $n$ выполняется $A(x)=1\iff x\in L$.

**Лемма 16.25 (контрпример).** Существует NP-полный язык $L'$ такой, что $L'\in$ io-P.

*Доказательство.* Пусть $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$ 
Тогда любая строка из $L'$ имеет длину $n^2$. Редукция $x\mapsto x0^{n^2-n}$
полиномиальна, значит $L'$ NP-полон. Для любой длины $m$, не являющейся квадратом,
в $L'$ нет строк, поэтому алгоритм, всегда отвергающий на таких длинах,
решает $L'$ за полиномиальное время. Неквадратных длин бесконечно много, значит
$L'\in$ io-P. Следовательно, условие "NP-полный и легок на бесконечно многих длинах"
не влечет $\mathrm{P}=\mathrm{NP}$. $\square$

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.26. Исследовательский шаг: NP-полный язык легок на плотности 1 длин

**Вопрос ("А что если...?").** Если NP-полный язык решается за полиномиальное время
на множестве длин плотности 1, следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (плотность 1 по длинам).** Множество длин $N\subseteq\mathbb{N}$ имеет
плотность 1, если
$$\lim_{m\to\infty} \frac{|N\cap\{1,\dots,m\}|}{m}=1.$$
Язык $L$ называется *легким на длинах из $N$*, если существует полиномиальный
алгоритм $A$, корректный для всех строк $x$ с $|x|\in N$.

**Лемма 16.26 (контрпример).** Существует NP-полный язык $L'$ и множество длин $N$
плотности 1, такое что $L'$ легок на длинах из $N$.

*Доказательство.* Положим $p(n)=n^2$ и
$$L' = \{x0^{p(|x|)-|x|}: x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{n^2-n}$ полиномиальна, значит $L'$ NP-полон.
Любая строка из $L'$ имеет длину квадрат; на длинах, не являющихся квадратами,
$L'$ пуст, и алгоритм, всегда отвергающий, корректен. Пусть $N$ - множество
неквадратных длин. Тогда $|N\cap\{1,\dots,m\}|=m-\lfloor\sqrt{m}\rfloor$, поэтому
$N$ имеет плотность 1. Значит $L'$ легок на длинах из $N$. $\square$

**Вывод/провал.** Свойство "NP-полный язык легок на плотности 1 длин" слишком слабое:
оно уже достигается простой паддинг-конструкцией и не ведет к $\mathrm{P}=\mathrm{NP}$
без дополнительных идей.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.27. Исследовательский шаг: SAT в BPP => SAT в P/poly

**Вопрос ("А что если...?").** Если SAT решается в BPP, следует ли из этого
существование полиномиальных схем?

**Лемма 16.27 (Adleman).** Если $\mathrm{SAT}\in\mathrm{BPP}$, то $\mathrm{SAT}\in\mathrm{P/poly}$.

*Доказательство.* Пусть $A$ - BPP-алгоритм для SAT, использующий $m(n)$ случайных битов.
Усилим его повторением до ошибки $\varepsilon=2^{-2n}$, получив алгоритм $A'$
(время и число битов остаются полиномиальными).
Для фиксированной длины $n$ обозначим через $B_x$ множество случайных строк $r$
длины $m(n)$, на которых $A'(x,r)$ ошибается. Тогда $|B_x|\le \varepsilon 2^{m(n)}$.
Объединение по всем $x\in\{0,1\}^n$ имеет размер
$$\left|\bigcup_{x} B_x\right|\le 2^n\cdot \varepsilon 2^{m(n)}<2^{m(n)},$$
поэтому существует строка $r_n$, на которой $A'$ корректен для всех входов длины $n$.
Жестко зашив $r_n$ в схему, получаем семейство схем полиномиального размера,
решающее SAT на каждой длине $n$. Значит $\mathrm{SAT}\in\mathrm{P/poly}$. $\square$

**Вывод/провал.** Из SAT $\in\mathrm{BPP}$ следует лишь неравномерность
($\mathrm{SAT}\in\mathrm{P/poly}$) и, по Karp-Lipton, коллапс PH до $\Sigma_2^p$;
это не дает $\mathrm{P}=\mathrm{NP}$ без дополнительных идей о униформности.

**Барьер-чек.**
- *Релятивизация:* да (аргумент переносится на оракулы).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.28. Исследовательский шаг: NP ⊆ AC^0?

**Вопрос ("А что если...?").** Что если весь $\mathrm{NP}$ лежит в $\mathrm{AC}^0$?

**Лемма 16.28 (контрпример).** $\mathrm{NP}\not\subseteq\mathrm{AC}^0$.

*Доказательство.* Функция $\mathrm{PARITY}$ принадлежит $\mathrm{P}\subseteq\mathrm{NP}$.
По разделу 11.3, $\mathrm{PARITY}\notin\mathrm{AC}^0$.
Значит существует язык из $\mathrm{NP}$, не лежащий в $\mathrm{AC}^0$, то есть
$\mathrm{NP}\not\subseteq\mathrm{AC}^0$. $\square$

**Вывод/провал.** Утверждение $\mathrm{NP}\subseteq\mathrm{AC}^0$ слишком сильное:
оно уже опровергается классическими нижними оценками для $\mathrm{AC}^0$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о неравномерных схемах).
- *Natural proofs:* не препятствует; нижние оценки для $\mathrm{AC}^0$ известны.
- *Algebrization:* неприменимо.

### 16.29. Исследовательский шаг: средняя легкость NP-полного языка

**Вопрос ("А что если...?").** Если NP-полный язык решается полиномиально
на почти всех входах каждой длины (равномерно по $\{0,1\}^n$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (ошибка на длине $n$).** Алгоритм $A$ имеет ошибку $\varepsilon(n)$ на языке $L$,
если $\Pr_{x\in\{0,1\}^n}[A(x)\ne L(x)]\le \varepsilon(n)$.

**Лемма 16.29 (контрпример).** Существует NP-полный язык $L'$ и полиномиальный алгоритм $A$,
для которого ошибка на длине $n$ не превосходит $2^{-\Omega(n)}$.

*Доказательство.* Возьмем $p(m)=m^2$ и определим
$$L' = \{x0^{p(|x|)} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{p(|x|)}$ полиномиальна, значит $L'$ NP-полон.
Если длина $n$ имеет вид $n=m+p(m)=m+m^2$, то в $\{0,1\}^n$ не более $2^m$ строк из $L'$,
поэтому доля принимающих не превосходит $2^m/2^{m+m^2}=2^{-m^2}=2^{-\Theta(n)}$.
Если длина $n$ не такого вида, то $L'\cap\{0,1\}^n=\varnothing$.
Алгоритм $A$, всегда отвергающий, имеет ошибку не более $2^{-\Theta(n)}$ на каждой длине.
$\square$

**Вывод/провал.** Наличие NP-полного языка, легкого на почти всех входах каждой длины,
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается простым паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг и оценка доли сохраняются с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.30. Исследовательский шаг: NP-полный язык в субэкспоненциальном времени?

**Вопрос ("А что если...?").** Если существует NP-полный язык, решаемый за
время $2^{n^\varepsilon}$ (для некоторого $0<\varepsilon<1$), следует ли $\mathrm{P}=\mathrm{NP}$?

**Лемма 16.30 (контрпример).** Существует NP-полный язык $L'$ в
$\mathrm{DTIME}(2^{O(\sqrt{n})})$ (то есть за субэкспоненциальное время).

*Доказательство.* Определим
$$L' = \{x0^{|x|^2-|x|} : x\in\mathrm{SAT}\}.$$
Редукция $x\mapsto x0^{|x|^2-|x|}$ полиномиальна, значит $L'$ NP-полон.
Для входа длины $n$ проверим, является ли $n$ квадратом $m^2$ и что последние
$n-m$ битов нулевые; иначе отвергаем. Если $n=m^2$, берём первые $m$ битов как $x$
и решаем SAT полным перебором за $2^{O(m)}=2^{O(\sqrt{n})}$.
Следовательно, $L'\in\mathrm{DTIME}(2^{O(\sqrt{n})})$. $\square$

**Вывод/провал.** Наличие NP-полного языка в субэкспоненциальном времени
не влечет $\mathrm{P}=\mathrm{NP}$: это достигается паддингом.

**Барьер-чек.**
- *Релятивизация:* да (паддинг сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.31. Исследовательский шаг: p-bounded proof system?

**Вопрос ("А что если...?").** Что если существует полиномиально ограниченная
пропозициональная система доказательств?

**Определение (p-bounded).** Доказательная система $P$ (в смысле Cook-Reckhow)
p-bounded, если существует полином $p$, что каждая тавтология $\varphi$
имеет $P$-доказательство длины $\le p(|\varphi|)$.

**Лемма 16.31.** Если существует p-bounded доказательная система, то
$\mathrm{NP}=\mathrm{coNP}$.

*Доказательство.* Пусть $P$ p-bounded. НП-машина по входу $\varphi$
угадывает строку длины $\le p(|\varphi|)$ и проверяет, что это корректное
$P$-доказательство $\varphi$ (проверка полиномиальна по определению proof system).
Значит $\mathrm{TAUT}\in\mathrm{NP}$. Так как $\mathrm{TAUT}$ coNP-полна,
получаем $\mathrm{coNP}\subseteq\mathrm{NP}$, и следовательно
$\mathrm{NP}=\mathrm{coNP}$. $\square$

**Вывод/провал.** p-boundedness: чрезвычайно сильное требование:
оно сразу влечет коллапс $\mathrm{NP}$ и $\mathrm{coNP}$.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о proof systems).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.32. Исследовательский шаг: SAT в BPP с O(log n) случайных битов

**Вопрос ("А что если...?").** Что если SAT решается в BPP, используя лишь
$O(\log n)$ случайных битов?

**Определение (BPP$_{\log}$).** Язык $L\in\mathrm{BPP}_{\log}$, если существует
BPP-алгоритм, использующий не более $c\log n$ случайных битов на входах длины $n$.

**Лемма 16.32.** Если $\mathrm{SAT}\in\mathrm{BPP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть $A$ — BPP-алгоритм для SAT, использующий $m(n)\le c\log n$
случайных битов. Для формулы $\varphi$ длины $n$ переберем все $2^{m(n)}\le n^c$
случайные строки $r$ и вычислим долю принятий $A(\varphi,r)$.
Если $\varphi$ выполнима, эта доля $\ge 2/3$, иначе $\le 1/3$.
Сравнение с порогом $1/2$ дает детерминированное решение за полиномиальное время.
$\square$

**Контрпример к усилению.** При $m(n)=\Theta(n)$ полный перебор случайных строк
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий BPP.

**Барьер-чек.**
- *Релятивизация:* да (перебор случайных строк сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.33. Исследовательский шаг: SAT разрежен?

**Вопрос ("А что если...?").** Может ли SAT быть разреженным языком?

**Определение (sparse).** Язык $L$ разрежен, если существует полином $p$, что
$|L\cap\Sigma^{\le n}|\le p(n)$ для всех $n$.

**Лемма 16.33 (контрпример).** SAT не является разреженным языком.

*Доказательство.* Для каждого $m$ и каждого присваивания $a\in\{0,1\}^m$ рассмотрим формулу
$$\varphi_a:=\bigwedge_{i=1}^m \ell_i,$$
где $\ell_i=x_i$ при $a_i=1$ и $\ell_i=\neg x_i$ при $a_i=0$.
Каждая $\varphi_a$ выполнима (единственным образом) и имеет длину $\mathrm{poly}(m)$
(при любом стандартном кодировании входа).
Формулы $\varphi_a$ различны, поэтому среди строк длины $\le \mathrm{poly}(m)$ есть как минимум $2^m$
выполнимых формул. Так как $2^m$ перерастает любой полином от $\mathrm{poly}(m)$,
SAT не разрежен. $\square$

**Вывод/провал.** Попытка использовать разреженность SAT как путь к $\mathrm{P}\ne\mathrm{NP}$
обрывается на элементарном счете: SAT слишком плотен.

**Барьер-чек.**
- *Релятивизация:* неприменимо (утверждение о фиксированном языке).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.34. Исследовательский шаг: SAT с логарифмическими сертификатами

**Вопрос ("А что если...?").** Если SAT имеет сертификаты длины $O(\log n)$,
следует ли $\mathrm{P}=\mathrm{NP}$?

**Определение (NP$_{\log}$).** Язык $L\in\mathrm{NP}_{\log}$, если существует
полиномиальный верификатор $V(x,y)$ и константа $c$ такие, что для всех $x$:
$$x\in L\iff \exists y\in\{0,1\}^{\le c\log|x|}: V(x,y)=1.$$

**Лемма 16.34.** Если $\mathrm{SAT}\in\mathrm{NP}_{\log}$, то $\mathrm{SAT}\in\mathrm{P}$,
следовательно $\mathrm{P}=\mathrm{NP}$.

*Доказательство.* Пусть для SAT существует верификатор с сертификатом длины
не более $c\log n$. Тогда на входе длины $n$ можно перебрать все
$2^{c\log n}=n^c$ сертификатов $y$ и проверить $V(x,y)$.
Это детерминированное полиномиальное время. $\square$

**Контрпример к усилению.** При длине сертификата $\Theta(n)$ полный перебор
требует $2^{\Theta(n)}$ времени, поэтому аргумент не переносится на общий NP.

**Барьер-чек.**
- *Релятивизация:* да (перебор сертификатов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.35. Исследовательский шаг: односторонние функции

**Вопрос ("А что если...?").** Что если существуют односторонние функции?

**Определение (OWF).** Функция $f:\{0,1\}^*\to\{0,1\}^*$ односторонняя, если
она полиномиально вычислима и для любого полиномиального алгоритма $A$
вероятность $\Pr_{x\leftarrow\{0,1\}^n}[f(A(f(x)))=f(x)]$ пренебрежимо мала.

**Лемма 16.35.** Если существуют OWF, то $\mathrm{P}\ne\mathrm{NP}$.

*Доказательство.* Предположим, что $\mathrm{P}=\mathrm{NP}$. Зафиксируем
полиномиально вычислимую $f$. Для данного $y$ будем по битам восстанавливать
преобраз: на шаге $i$ проверяем, существует ли строка $x$ с заданным префиксом
длины $i$ такая, что $f(x)=y$. Это NP-вопрос, значит при $\mathrm{P}=\mathrm{NP}$
решается за полиномиальное время. После $O(|y|)$ шагов получаем $x$ с $f(x)=y$.
Следовательно, $f$ инвертируема в полиномиальное время на всех $y$ из образа,
противоречие односторонности. Значит существование OWF влечет $\mathrm{P}\ne\mathrm{NP}$. $\square$

**Вывод/провал.** Доказать существование OWF достаточно для $\mathrm{P}\ne\mathrm{NP}$,
но это не проще исходной задачи.

**Барьер-чек.**
- *Релятивизация:* да (аргумент сохраняется с оракулом).
- *Natural proofs:* неприменимо.
- *Algebrization:* неприменимо.

### 16.36. Исследовательский шаг: PRG с логарифмическим seed

**Вопрос ("А что если...?").** Что если существует PRG с seed длины $O(\log n)$,
который обманывает все BPP-алгоритмы?

**Определение (PRG для BPP).** Семейство $g_n:\{0,1\}^{s(n)}\to\{0,1\}^{m(n)}$
c $s(n)=O(\log n)$ и $m(n)=\mathrm{poly}(n)$, вычислимое за полиномиальное время,
такое что для любого полиномиального алгоритма $A$ и всех $n$:
$$\left|\Pr[A(g_n(U_{s(n)}))=1]-\Pr[A(U_{m(n)})=1]\right|\le 1/10.$$

**Лемма 16.36.** Если такой PRG существует, то $\mathrm{BPP}=\mathrm{P}$.

*Доказательство.* Пусть $L\in\mathrm{BPP}$ и $A$ — его вероятностный полиномиальный
алгоритм с $m(n)$ случайными битами и ошибкой $\le 1/3$.
Для входа $x$ длины $n$ переберем все $2^{s(n)}=\mathrm{poly}(n)$ seed'ы $r$,
посчитаем долю принятий $A(x,g_n(r))$ и сравним с порогом $1/2$.
Так как PRG сохраняет вероятность с точностью $1/10$, то при $x\in L$ среднее
$\ge 2/3-1/10>1/2$, а при $x\notin L$ среднее $\le 1/3+1/10<1/2$.
Получаем детерминированный полиномиальный алгоритм. $\square$

**Контрпример к усилению.** Если $s(n)=\Theta(n)$, то полный перебор seed'ов
занимает $2^{\Theta(n)}$ времени и доказательство не работает.

**Барьер-чек.**
- *Релятивизация:* да (перебор seed'ов сохраняется с оракулом).
- *Natural proofs:* неприменимо (не о схемных нижних оценках).
- *Algebrization:* неприменимо.

### 16.37. Исследовательский шаг: счётчик ошибок в tt‑формуле

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для любого $N=2^n$ и $T\in\{0,\dots,N\}$ существует булева схема
  размера $O(N\log N)$ и глубины $O(\log N)$, вычисляющая
  $\mathrm{Count}_{\ge T}(e_1,\dots,e_N)$; построение — двоичное дерево сумматоров
  и компаратор с $T$.
- `Toy‑тест:` $N=4$: складываем $(e_1,e_2)$ и $(e_3,e_4)$ 2‑битными сумматорами,
  затем 3‑битным сумматором получаем сумму $\in\{0,\dots,4\}$; компаратор на 3 битах
  проверяет $\ge T$. Размер и глубина соответствуют $O(N\log N)$ и $O(\log N)$.
- `Статус:` доказано (явная конструкция).
- `Барьер‑чек:` r — неприменимо (верхняя оценка), NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости зафиксировать в основном тексте конкретную
  реализацию (adder tree/Batcher) и кодирование $T$ длины $O(\log N)$.

### 16.38. Исследовательский шаг: Tseitin-кодирование $\mathrm{Eval}(C,x)$

- `Линза:` Эквивалентность.
- `Утверждение:` Для gate-list кодирования схемы $C$ размера $s$ (fan-in 2)
  существует CNF формула $\mathrm{Eval}_C(x,b)$ с $O(s)$ вспомогательными
  переменными и $O(s)$ клаузами, такая что для любого назначения входов $x$
  формула выполнима тогда и только тогда, когда выход схемы равен $b$.
- `Toy‑тест:` Схема: $g_1:=x_1\land x_2$, $g_2:=g_1\lor x_3$ (выход $g_2$).
  Tseitin-клаузы:
  $(\neg g_1\lor x_1)\land(\neg g_1\lor x_2)\land(g_1\lor\neg x_1\lor\neg x_2)$ и
  $(\neg g_2\lor g_1\lor x_3)\land(g_2\lor\neg g_1)\land(g_2\lor\neg x_3)$,
  плюс единичная клауза $(g_2)$ для $b=1$.
  При $x_1=x_2=1,x_3=0$ удовлетворяется с $g_1=g_2=1$; при $b=0$ невыполнима.
  На один гейт приходится $O(1)$ клауз, значит размер $O(s)$.
- `Статус:` доказано (стандартное Tseitin-кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` связать это кодирование с местом, где в тексте фиксируется
  $n=||x||$ при пропозициональном переводе в EF.

### 16.39. Исследовательский шаг: эквивалентность vs эквисатисфакция в CNF→3-CNF

- `Линза:` Эквивалентность.
- `Утверждение:` Стандартная редукция CNF→3-CNF порождает формулу $r(\varphi)$,
  логически эквивалентную $\varphi$ как формула над *всеми* переменными
  (исходными и новыми).
- `Toy‑тест:` Возьмём клаузу $\varphi=(x_1\lor x_2\lor x_3\lor x_4)$ и редукцию
  $r(\varphi)=(x_1\lor x_2\lor y)\land(\neg y\lor x_3\lor x_4)$.
  Присваивание $x_1=1,x_2=x_3=x_4=0,y=1$ делает $\varphi$ истинной, но
  $r(\varphi)$ ложной (вторая клауза ложна). Следовательно, полная эквивалентность
  неверна; верно лишь $\varphi\equiv \exists y\, r(\varphi)$.
- `Статус:` контрпример.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` использовать явную функцию $g$ (как в Лемме 15.7.3d),
  чтобы переносить истинность $\varphi$ на $r(\varphi)$ в EF.

### 16.40. Исследовательский шаг: порядок blow-up не влияет на барьер

- `Линза:` Трейд‑офф (размеры).
- `Утверждение:` Для барьера 15.7.4 достаточно любого полиномиального blow-up
  редукции $r$; явный порядок (линейный/квадратичный) не меняет вывода
  $\mathrm{P}=\mathrm{NP}$.
- `Toy‑тест:` Пусть $|r(\varphi)|\le |\varphi|^2$ и алгоритм $\mathcal A$
  строит ROABP размера $\le |\psi|^3$. Тогда композиция даёт ROABP
  размера $\le |\varphi|^6$, что остаётся полиномом. Следовательно, даже
  квадратичный blow-up не ломает аргумент.
- `Статус:` доказано (тривиальная оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости найти точный порядок blow-up в
  редукциях Лихтенштейна/Товея для библиографической аккуратности.

### 16.41. Исследовательский шаг: фиксация $n=||x||$ в масштабе LogLog

- `Линза:` Эквивалентность.
- `Утверждение:` Если в $LB_{tt}(h,s(n),t(n)2^n)$ подставить параметр
  $x:=2^{2^n}$, то $||x||=2^n+1$, и все ограничения вида $u<2^n$ становятся
  bounded (например, $u\le ||x||$). Поэтому формула остаётся $\Pi^b_1$,
  а её пропозициональный перевод имеет размер $\mathrm{poly}(2^n)$ и даёт
  стандартный $tt(h_n,s(n),t(n))$.
- `Toy‑тест:` $n=2$: берём $x=2^{2^2}=16$, получаем $||x||=5$, и любой
  квантор $u<2^n=4$ можно заменить на $u\le 5$ без изменения истинности.
  Это иллюстрирует, как «таблица истинности» длины $2^n$ укладывается
  в bounded‑кванторы по $x$.
- `Статус:` доказано (прямая оценка длины).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` указать в основном тексте конкретное место, где
  фиксируется подстановка $x=2^{2^n}$ (PS Sec. 2.4.1) и как это отражается
  в EF‑переводе.

### 16.42. Исследовательский шаг: $\mathrm{Count}_{\ge T}$ через сортировочную сеть

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть сеть сортирует биты $e_1,\dots,e_N$ по невозрастанию,
  выдавая $b_1\ge \cdots \ge b_N$. Тогда $\mathrm{Count}_{\ge T}(e)$ эквивалентно
  условию $b_T=1$. Бэтчерова сортировочная сеть имеет $O(N\log^2 N)$ компараторов,
  каждый компаратор реализуется $O(1)$ AND/OR‑гейтами, значит схема для
  $\mathrm{Count}_{\ge T}$ имеет размер $O(N\log^2 N)$.
- `Toy‑тест:` $N=4$ и сеть с компараторами $(1,2),(3,4),(1,3),(2,4),(2,3)$
  (выходы — $(\max,\min)$). На входе $(1,0,1,0)$ получаем
  $(1,1,0,0)$, поэтому $\mathrm{Count}_{\ge 3}$ ложно, а $\mathrm{Count}_{\ge 2}$
  истинно (проверка по $b_3$ и $b_2$).
- `Статус:` доказано (стандартная сеть).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` решить, какой из вариантов (adder tree vs sorting network)
  удобнее фиксировать в основном тексте около Леммы 15.7.1d.

### 16.43. Исследовательский шаг: размер компаратора и кодирование порога $T$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для $N=2^n$ и любого целого $T\in[0,N]$ длина двоичного кода $T$
  равна $O(\log N)=O(n)$. Компаратор, проверяющий $S\ge T$ для суммы $S\in[0,N]$
  (в двоичном виде), реализуется схемой размера $O(\log N)$. Поэтому добавление
  порога не меняет асимптотику конструкции $\mathrm{Count}_{\ge T}$.
- `Toy‑тест:` $N=8$, $T=5=0101_2$, сумма $S=s_3s_2s_1s_0$.
  Условие $S\ge 5$ эквивалентно $s_3\ \lor\ (s_2\land(s_1\lor s_0))$,
  что даёт константный компаратор; размер растёт как $O(\log N)$ в общем случае.
- `Статус:` доказано (стандартный компаратор по двоичному сравнению).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить короткую ремарку о размере компаратора
  рядом с Леммой 15.7.1d.

### 16.44. Исследовательский шаг: длина gate‑list и $\Delta^b_0$‑валидность

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для схемы размера $s$ с fan‑in 2 и $n$ входами gate‑list
  кодирование имеет длину $m(s,n)=O(s\log s+n\log s)$: на каждый гейт
  сохраняются тип (константа) и два индекса входов $<i$, каждый индекс
  занимает $O(\log s)$ бит. Предикат $\mathrm{Valid}_s(C)$ проверяется
  bounded‑кванторами по $i\le s$ и индексам $<i$, поэтому является $\Delta^b_0$.
- `Toy‑тест:` $s=3,n=2$: кодируем гейты
  $g_1=\mathrm{IN}(1)$, $g_2=\mathrm{IN}(2)$, $g_3=\mathrm{AND}(1,2)$.
  Каждый индекс $\le 3$ кодируется 2 битами, тип — константным числом бит.
  Проверка $\mathrm{Valid}_3$ требует лишь условий «индексы $<i$».
  Если заменить $g_3=\mathrm{AND}(3,2)$, то условие $3<i$ ложно — контрпример
  к валидности при тех же bounded‑кванторах.
- `Статус:` доказано (явная оценка и проверка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании сослаться на Лемму 15.7.2b в основном тексте
  и отметить, что при $n\le s$ можно брать $m(s)=O(s\log s)$.

### 16.45. Исследовательский шаг: корректность явного $g$ в CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для клаузы $(\ell_1\lor\cdots\lor\ell_k)$ и цепочки
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land\cdots\land
  (\neg y_{k-3}\lor\ell_{k-1}\lor\ell_k)$ выбор
  $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ удовлетворяет всем новым клаузам
  при любом истинном значении исходной клаузы.
- `Toy‑тест:` $k=5$, пусть $\ell_3$ истинна, а $\ell_1=\ell_2=\ell_4=\ell_5=0$.
  Тогда $y_1=\neg(\ell_1\lor\ell_2)=1$, $y_2=\neg(\ell_1\lor\ell_2\lor\ell_3)=0$.
  Проверка цепочки:
  $(\ell_1\lor\ell_2\lor y_1)=(0\lor 0\lor 1)=1$,
  $(\neg y_1\lor\ell_3\lor y_2)=(0\lor 1\lor 0)=1$,
  $(\neg y_2\lor\ell_4\lor\ell_5)=(1\lor 0\lor 0)=1$.
- `Статус:` доказано (инвариант «префикс ложен»).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку к Лемме 15.7.3d,
  поясняющую инвариант «префикс ложен» для выбора $g$.

### 16.46. Исследовательский шаг: $\mathrm{Eval}(C,x)$ уже в 3-CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для gate‑list схемы fan‑in 2 Tseitin‑кодирование
  $\mathrm{Eval}_C(x,b)$ состоит из клауз ширины $\le 3$ (формулы для AND/OR/NOT)
  и потому является 3‑CNF без дополнительного blow-up; число клауз $O(s)$.
- `Toy‑тест:` Гейт $g=a\land b$ кодируется тремя клаузами:
  $(\neg g\lor a)$, $(\neg g\lor b)$, $(g\lor\neg a\lor\neg b)$ — ширина $\le 3$.
  Аналогично для $g=a\lor b$ и $g=\neg a$ (ширина $\le 2$).
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте, что для fan‑in 2
  дополнительная редукция в 3‑CNF не нужна.

### 16.47. Исследовательский шаг: граф p‑time функции как $\Delta^b_0$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R(n,C)$ вычисляется за полиномиальное время и
  $|R(n,C)|\le p(n)$, то существует bounded‑формула
  $\mathrm{Graph}_R(n,C,y)$ (кванторы по времени/ячейкам $\le p(n)$),
  такая что $\mathrm{Graph}_R(n,C,y)\iff y=R(n,C)$. Следовательно,
  подстановка $y:=R(n,C)$ в $\mathrm{RedCorr}(n,C,y)$ сохраняет
  $\Pi^b_1$‑форму.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1\oplus C_2$ (первые два бита).
  Тогда $\mathrm{Graph}_R(n,C,y)$ можно записать как bounded‑формулу
  $y\leftrightarrow (C_1\oplus C_2)$. Для $C=10$ получаем $y=1$;
  при $y=0$ формула ложна.
- `Статус:` доказано (стандартная $\Delta^b_0$‑граф‑формализация).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании связать это с формулировкой (H2$_\Pi$),
  где используется $R(n,C)$ вместо $\exists y$.

### 16.48. Исследовательский шаг: устранение $\exists y$ через $\mathrm{Graph}_R$

- `Линза:` Эквивалентность.
- `Утверждение:` Если определить
  $\mathrm{RedCorr}(n,C,y):=\mathrm{Graph}_R(n,C,y)\wedge \mathrm{Err}_{t(n)}(C,y)$,
  то для тотальной p‑time функции $R$ имеем эквивалентность
  $$\forall n\,\forall C\,\exists y\,\mathrm{RedCorr}(n,C,y)\ \iff\
  \forall n\,\forall C\,\mathrm{Err}_{t(n)}(C,R(n,C)).$$
  Значит (H2$_\Pi$) можно писать как $\forall n\,\forall C\,\mathrm{RedCorr}(n,C,R(n,C))$
  без выхода за $\Pi^b_1$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает первый бит $C$, а
  $\mathrm{Err}_{t(n)}(C,y)$ := $(y=1)$.
  Тогда $\exists y\,\mathrm{RedCorr}$ истинно $\iff C_1=1$,
  и это эквивалентно $\mathrm{Err}_{t(n)}(C,R(n,C))$ (также $C_1=1$).
- `Статус:` доказано (подстановка по графу функции).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить это прямо рядом с (H2$_\Pi$)
  в основном тексте.

### 16.49. Исследовательский шаг: ошибка как счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $e_x:=C(x)\oplus g_n(x)$ для всех $x\in\{0,1\}^n$.
  Тогда формула $\mathrm{Err}_{t(n)}(C,g_n)$ эквивалентна условию
  $\sum_x e_x < t(n)2^n$, то есть $\neg\,\mathrm{Count}_{\ge T}(e)$ при
  $T:=\lceil t(n)2^n\rceil$. Множество $S$ из определения $\mathrm{Err}_{t(n)}$
  можно взять равным $\{x:e_x=1\}$.
- `Toy‑тест:` $n=2$, $g(x)=x_1\oplus x_2$, а $C$ ошибается ровно на одном входе.
  Тогда $\sum_x e_x=1$. При $t(n)=1/2$ имеем $T=2$ и $\mathrm{Count}_{\ge 2}(e)=0$,
  то есть ошибка $< t(n)$, как и по определению через множество $S$ размера 1.
- `Статус:` доказано (перепись определения).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте связь $\mathrm{Err}_{t(n)}$
  с $\mathrm{Count}_{\ge T}$ (как в $tt$‑формуле).

### 16.50. Исследовательский шаг: p‑time вычислимость $g$ для CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для каждой исходной клаузы $(\ell_1\lor\cdots\lor\ell_k)$
  значения $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ вычисляются за $O(k)$
  времени, поддерживая префиксное OR. Для всей формулы $g(p)$ вычисляется
  за $O(|\varphi|)$, значит $g$ — p‑time и PV‑функция (доступна в EF).
- `Toy‑тест:` Для $\ell=(0,1,0,0)$ имеем префиксы
  $p_2=\ell_1\lor\ell_2=1$, $p_3=1$, $p_4=1$,
  поэтому $y_1=\neg p_2=0$, $y_2=\neg p_3=0$.
  Вычисление требует одного прохода по клаузе.
- `Статус:` доказано (линейный проход).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить в основном тексте ремарку, что $g$
  p‑time/PV‑вычислима, поэтому EF может использовать её в 15.7.3d.

### 16.51. Исследовательский шаг: размер полинома $P_\varphi$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с $L$ литералами
  полином $P_\varphi(x)=\prod_j S_{C_j}(x)$, где
  $S_{C}(x)=1-\prod_{\ell\in C}(1-\llbracket \ell\rrbracket)$,
  имеет depth‑3 формулу размера $O(L)$ (по одному множителю на литерал
  плюс константы). Поэтому любой полиномиальный blow‑up редукции
  сохраняет условие «$P_\psi$ имеет размер $\mathrm{poly}(|\psi|)$» в Лемме 15.7.4.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge(x_2\lor x_3\lor x_4)$.
  Тогда $S_{C_1}=1-(1-x_1)(1-(1-x_2))$ и
  $S_{C_2}=1-(1-x_2)(1-x_3)(1-x_4)$, и
  $P_\varphi=S_{C_1}\cdot S_{C_2}$ — depth‑3 формула с числом множителей,
  линейным по числу литералов (5).
- `Статус:` доказано (прямой подсчёт).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.4,
  что размер $P_\varphi$ линеен по числу литералов и сохраняется при
  полиномиальном blow‑up редукций.

### 16.52. Исследовательский шаг: нуль на кубе ⇒ тождественный нуль

- `Линза:` Эквивалентность.
- `Утверждение:` Если multilinear‑полином $Q(x_1,\dots,x_n)$ над полем
  удовлетворяет $Q(a)=0$ для всех $a\in\{0,1\}^n$, то $Q\equiv 0$.
  (Значения на булевом кубе единственным образом задают multilinear‑полином.)
- `Toy‑тест:` $n=1$: $Q(x)=ax+b$. Из $Q(0)=b=0$ и $Q(1)=a+b=0$ следует $a=b=0$.
  $n=2$: $Q(x,y)=a xy+ b x + c y + d$. Нули на четырёх точках дают систему
  $d=0$, $b+d=0$, $c+d=0$, $a+b+c+d=0$, значит $a=b=c=d=0$.
- `Статус:` доказано (уникальность multilinear‑представления).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку рядом с санити‑чеком
  (разд. 15.7), что multilinear‑полином однозначно восстанавливается по
  значениям на $\{0,1\}^n$.

### 16.53. Исследовательский шаг: $P_\varphi$ как индикатор выполнимости

- `Линза:` Эквивалентность.
- `Утверждение:` Для булевого присваивания $a\in\{0,1\}^n$ и клаузы
  $C=(\ell_1\lor\cdots\lor\ell_k)$ полином
  $S_C(a)=1-\prod_{i=1}^k(1-\llbracket \ell_i\rrbracket)$ равен $1$
  тогда и только тогда, когда $C(a)=1$. Следовательно,
  $P_\varphi(a)=\prod_j S_{C_j}(a)=1$ тогда и только тогда, когда $\varphi(a)=1$,
  и $\varphi$ невыполнима $\iff P_\varphi$ нулевой на $\{0,1\}^n$.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge x_2$.
  При $a=(1,0)$ имеем $S_{x_1\lor\neg x_2}=1-(1-1)(1-(1-0))=1$,
  $S_{x_2}=1-(1-0)=0$, значит $P_\varphi(a)=0$ и $\varphi(a)=0$.
  При $a=(1,1)$ оба множителя равны $1$, и $\varphi(a)=1$.
- `Статус:` доказано (прямая проверка на булевом кубе).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку около санити‑чека,
  что $P_\varphi$ совпадает с индикатором выполнимости на $\{0,1\}^n$.

### 16.54. Исследовательский шаг: выбор «канонической» реализации счётчика

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для формулы $\mathrm{Count}_{\ge T}$ в $tt(f_n,s,t)$
  достаточно любой стандартной реализации размером $\mathrm{poly}(2^n)$.
  Adder‑tree даёт $O(N\log N)$, Batcher даёт $O(N\log^2 N)$, обе подходят
  для EF и масштаба $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $N=8$: adder‑tree складывает пары битов (4 сумматора),
  затем суммы (2 сумматора), затем финальная сумма (1 сумматор) и компаратор;
  всего $O(N\log N)$ элементов. Sorting‑network на $N=8$ имеет
  $O(N\log^2 N)$ компараторов. Оба дают булеву формулу размера poly.
- `Статус:` доказано (сравнение оценок).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` выбрать один вариант для фиксации в основном тексте рядом
  с Леммой 15.7.1d.

### 16.55. Исследовательский шаг: $m(s)$ полиномиально от $|x|$ при LogLog

- `Линза:` Сжатие/канонизация.
- `Утверждение:` При подстановке $x=2^{2^n}$ имеем $|x|=2^n+1$ и
  $s=2^{n/4}$. Тогда длина кода схемы $m(s)=O(s\log s)=2^{O(n)}$
  удовлетворяет $m(s)\le |x|^{O(1)}$. Значит ограничение $C\le m(s)$
  в (H1$_\Pi$) является bounded‑квантором в масштабе $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $n=4$: $x=2^{16}$, $|x|=17$, $s=2^{1}=2$ и
  $m(s)=O(2\log 2)=O(2)\le |x|$.
- `Статус:` доказано (прямая оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H1$_\Pi$),
  что $m(2^{n/4})$ полиномиально от $|x|$ при LogLog‑масштабе.

### 16.56. Исследовательский шаг: тотальность $R$ в $\mathrm{S}^1_2$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R$ — p‑time редукция, то её тотальность выражается
  $\Sigma^b_1$‑формулой $\forall n\,\forall C\le m(n)\,\exists y\le p(n)\,
  \mathrm{Graph}_R(n,C,y)$ и доказывается в $\mathrm{S}^1_2$ (PV‑вычислимость).
  Это обеспечивает переход от (H2$_\Pi$) к $\forall\exists$‑форме с $y$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1$. Тогда $\mathrm{Graph}_R(n,C,y)$
  — bounded‑формула $y\leftrightarrow C_1$. Очевидно,
  $\forall C\,\exists y\le 1\,\mathrm{Graph}_R(n,C,y)$ истинно.
- `Статус:` доказано (стандартная тотальность PV‑функций).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H2$_\Pi$),
  что тотальность $R$ доказуема в $\mathrm{S}^1_2$.

### 16.57. Исследовательский шаг: кодирование множества ошибок $S$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` В $\mathrm{Err}_{t(n)}$ множество $S\subseteq\{0,1\}^n$
  можно кодировать битовой маской длины $2^n$, то есть числом
  $S<2^{2^n}$. При LogLog‑подстановке $x=2^{2^n}$ имеем $S\le x$,
  поэтому квантор $\exists S$ является bounded, и $\mathrm{Err}_{t(n)}$
  остаётся $\Delta^b_0$‑формулой.
- `Toy‑тест:` $n=2$: $x=2^{2^2}=16$. Любое $S\subseteq\{0,1\}^2$ кодируется
  4‑битной маской $<2^4=16=x$ (например, $S=\{00,11\}$ соответствует $1001_2$).
- `Статус:` доказано (явное кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить рядом с $\mathrm{Err}_{t(n)}$ в L2,
  что квантор по $S$ bounded через $x=2^{2^n}$.

### 16.58. Исследовательский шаг: membership $x\in S$ как бит‑доступ

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Если $S<2^{2^n}$ кодирует подмножество $\{0,1\}^n$ битовой
  маской длины $2^n$, то предикат $x\in S$ эквивалентен $\mathrm{Bit}(S,x)=1$.
  Функция $\mathrm{Bit}$ PV‑вычислима, поэтому условие $x\in S$ является
  $\Delta^b_0$‑формулой при bounded‑кванторах $x<2^n$ и $S<2^{2^n}$.
- `Toy‑тест:` $n=2$, $S=1001_2$ кодирует $\{00,11\}$.
  Тогда $\mathrm{Bit}(S,0)=1$, $\mathrm{Bit}(S,3)=1$, а $\mathrm{Bit}(S,1)=0$.
- `Статус:` доказано (бит‑доступ).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании уточнить в L2, что проверка $x\notin S$
  реализуется через $\mathrm{Bit}(S,x)=0$.

### 16.59. Исследовательский шаг: размер $|S|$ через счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Если $S$ задано битовой маской длины $2^n$, то условие
  $|S|<T$ эквивалентно $\neg\mathrm{Count}_{\ge T}(S)$, где счётчик
  применяется к битам маски. При LogLog‑подстановке $x=2^{2^n}$ порог
  $T\le 2^n\le |x|$, поэтому проверка $|S|<T$ остаётся bounded и $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $S=1011_2$ имеет $|S|=3$. При $T=3$
  $\mathrm{Count}_{\ge 3}(S)=1$, значит $|S|<T$ ложно; при $T=4$
  $\mathrm{Count}_{\ge 4}(S)=0$, значит $|S|<T$ истинно.
- `Статус:` доказано (перепись через счётчик).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что условие $|S|<t(n)2^n$
  можно выразить через $\mathrm{Count}_{\ge T}$ на маске $S$.

### 16.62. Исследовательский шаг: $\mathrm{Err}_{t(n)}$ как $\Delta^b_0$‑формула

- `Линза:` Эквивалентность.
- `Утверждение:` В LogLog‑масштабе $\mathrm{Err}_{t(n)}(C,y)$ можно переписать
  как bounded‑формулу:
  $$\exists S\le 2^{2^n}\ \bigl(\neg\mathrm{Count}_{\ge T}(S)\ \wedge\
  \forall x<2^n\ (\mathrm{Bit}(S,x)=0\to \mathrm{Eval}(C,x)=y(x))\bigr),$$
  где $T=\lceil t(n)2^n\rceil$. Все кванторы bounded (через $x=2^{2^n}$),
  а $\mathrm{Bit}$ и $\mathrm{Eval}$ — PV‑вычислимы, значит
  $\mathrm{Err}_{t(n)}$ является $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $C=y$ (ошибок нет). Берём $S=0000_2$,
  $\mathrm{Count}_{\ge 1}(S)=0$, и для любого $x$ имеем
  $\mathrm{Bit}(S,x)=0\Rightarrow C(x)=y(x)$. Формула истинна.
  Если $C$ ошибается ровно на $x=3$, то берём $S=1000_2$;
  при $t(n)=1/2$ получаем $T=2$ и $\neg\mathrm{Count}_{\ge 2}(S)$ истинно.
- `Статус:` доказано (сведение к бит‑маске и счётчику).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что $\mathrm{Err}_{t(n)}$
  переписывается в явную bounded‑форму через $\mathrm{Bit}$ и счётчик.

### 16.63. Исследовательский шаг: линейный blow‑up в CNF→3‑CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для клаузы длины $k\ge 3$ стандартная цепочная редукция
  $(\ell_1\lor\cdots\lor\ell_k)\mapsto$ цепочку из $k-2$ 3‑клауз
  вводит $k-3$ новых переменных и $3(k-2)$ литералов. Следовательно, если
  $\varphi$ имеет суммарно $L$ литералов, то $r(\varphi)$ имеет размер $O(L)$
  (линейный blow‑up).
- `Toy‑тест:` $k=5$:
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land(\neg y_2\lor\ell_4\lor\ell_5)$.
  Здесь 3 клаузы, 2 новых переменных, 9 литералов, что равно $3(k-2)$.
- `Статус:` доказано (подсчёт по клауза‑в‑клаузу).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.3c
  с явным подсчётом числа клауз/литералов.

### 16.64. Исследовательский шаг: multilinearization не меняет значения на кубе

- `Линза:` Эквивалентность.
- `Утверждение:` Для любого многочлена $P$ над полем и его multilinearization
  $\mathrm{ML}(P)$ (редукция по правилам $x_i^2\mapsto x_i$) выполняется
  $\mathrm{ML}(P)(a)=P(a)$ для всех $a\in\{0,1\}^n$. Следовательно, $P$ и
  $\mathrm{ML}(P)$ совпадают на булевом кубе, и проверка нулевости на кубе
  эквивалентна.
- `Toy‑тест:` $P(x)=x^2+x$. На $x\in\{0,1\}$ имеем $x^2=x$, значит
  $P(x)=2x$. После редукции $\mathrm{ML}(P)=x+x=2x$, значения совпадают.
- `Статус:` доказано (так как $x_i^2=x_i$ на $\{0,1\}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что $\mathrm{ML}(P_\varphi)$ совпадает с $P_\varphi$ на $\{0,1\}^n$.

### 16.65. Исследовательский шаг: $\mathrm{ML}(P_\varphi)$ вычислима depth‑3 формулой

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Поскольку $P_\varphi=\prod_j S_{C_j}$ уже является
  depth‑3 формулой (произведение дизъюнктов, каждый — $1-\prod(1-\ell)$),
  а multilinearization заменяет степени $x_i^2$ на $x_i$ без увеличения
  структуры, то $\mathrm{ML}(P_\varphi)$ также вычислима depth‑3 формулой
  размера $O(L)$, где $L$ — число литералов в $\varphi$.
- `Toy‑тест:` Для $\varphi=(x_1\lor\neg x_2)$ имеем
  $P_\varphi=1-(1-x_1)(1-(1-x_2))$ — depth‑3. В $P_\varphi$ нет степеней $>1$,
  поэтому $\mathrm{ML}(P_\varphi)=P_\varphi$, и глубина/размер сохраняются.
- `Статус:` доказано (структура не усложняется).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.4, что
  $\mathrm{ML}(P_\varphi)$ остаётся depth‑3 формулой размера $O(L)$.

### 16.66. Исследовательский шаг: корректность ограничения «$C\le m(s)$»

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Ограничение $C\le m(s)$ в $tt(f_n,s,t)$ и (H1$_\Pi$)
  корректно: оно лишь фиксирует длину кода схемы $C$ и не исключает
  ни одной схемы размера $\le s$, поскольку любое такое $C$ имеет
  код длины $m(s)$ (паддинг нулями). Следовательно, квантор по $C\le m(s)$
  эквивалентен квантору по всем схемам размера $\le s$.
- `Toy‑тест:` $s=2$, схема из одного гейта AND имеет код длины $m(2)$.
  Если код короче, дополняем нулями; валидность $\mathrm{Valid}_2(C)$
  остаётся истинной. Значит ограничение $C\le m(2)$ не теряет схем.
- `Статус:` доказано (паддинг).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к (H1$_\Pi$)/(H2$_\Pi$),
  что ограничение $C\le m(s)$ — это лишь фиксирование длины кода.

### 16.67. Исследовательский шаг: $P_\varphi$ может быть не‑multilinear

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Полином $P_\varphi=\prod_j S_{C_j}$ может содержать степени
  $x_i^2$ из‑за повторных вхождений переменной в разных клауза, поэтому
  multilinearization действительно нужна в барьере 15.7.4.
- `Toy‑тест:` $\varphi=(x)\wedge(x\lor y)$. Тогда
  $P_\varphi=x\cdot(1-(1-x)(1-y))=x(x+y-xy)=x^2+xy-x^2y$ — не multilinear.
  На булевом кубе $x^2=x$, и $\mathrm{ML}(P_\varphi)=x$.
- `Статус:` доказано (явный пример).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что ML нужен, поскольку $P_\varphi$ может содержать $x_i^2$ при повторных
  вхождениях переменной.

### 16.68. Исследовательский шаг: CNF‑кодирование компаратора

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для $k$‑битных чисел $S$ и константы $T$ сравнение
  $S\ge T$ кодируется CNF размером $O(k)$ с $O(k)$ вспомогательными
  переменными (через префикс‑равенство и «первое превышение»).
  Поэтому перевод компаратора в CNF не меняет асимптотику
  $\mathrm{Count}_{\ge T}$.
- `Toy‑тест:` $k=2$, $S=s_1s_0$, $T=t_1t_0$. Пусть
  $e_i\leftrightarrow(s_i\leftrightarrow t_i)$ и
  $g_i\leftrightarrow(s_i\land\neg t_i)$.
  Тогда $S\ge T \iff g_1\lor(e_1\land g_0)\lor(e_1\land e_0)$.
  Каждый $e_i,g_i$ и комбинирование кодируются $O(1)$ клаузами.
- `Статус:` доказано (Tseitin‑кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1d,
  что компаратор имеет CNF‑кодирование размера $O(\log N)$.

### 16.69. Исследовательский шаг: $t(n)$ и $T(n)$ действительно целые

- `Линза:` Эквивалентность.
- `Утверждение:` Для $t(n)=1/2-1/2^{n/4}$ и $n$ кратного 4 порог
  $T(n)=t(n)2^n$ является целым, а именно
  $T(n)=2^{n-1}-2^{3n/4}$. Поэтому в этом случае $\lceil t(n)2^n\rceil$
  не требуется, и $\mathrm{Count}_{\ge T}$ задаётся целым порогом.
- `Toy‑тест:` $n=4$: $t(n)=1/2-1/2=0$, значит $T(4)=0$.
  Формула $\mathrm{Count}_{\ge 0}$ тривиально истинна; это согласуется
  с формулой $2^{n-1}-2^{3n/4}=8-8=0$.
- `Статус:` доказано (подстановка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1c,
  что при $4\mid n$ порог целый и округление не нужно.

### 16.70. Исследовательский шаг: «почти половина» для $t(n)$

- `Линза:` Инвариант.
- `Утверждение:` Для $t(n)=1/2-1/2^{n/4}$ имеем
  $$\tfrac12 - t(n)=2^{-n/4},\qquad T(n)=t(n)2^n=2^{n-1}-2^{3n/4}.$$
  Поэтому допустимая корреляция с функцией уменьшается как $2^{-n/4}$,
  т.е. требование — «почти половина» ошибок.
- `Toy‑тест:` $n=8$: $t(n)=1/2-1/2^{2}=1/2-1/4=1/4$,
  $T(n)=2^{7}-2^{6}=128-64=64$. Ошибка должна быть хотя бы на 64 входах
  из 256.
- `Статус:` доказано (подстановка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что $1/2-t(n)=2^{-n/4}$ и как это соотносится с «almost balanced».

### 16.71. Исследовательский шаг: Tseitin‑кодирование счётчика

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Если $\mathrm{Count}_{\ge T}$ вычисляется булевой схемой
  размера $S$ (adder‑tree/Batcher), то её Tseitin‑кодирование даёт CNF
  с $O(S)$ вспомогательными переменными и $O(S)$ клаузами, эквисатисфакционную
  исходной схеме. Следовательно, формула $\mathrm{Count}_{\ge T}$ может быть
  задана пропозиционально размера $\mathrm{poly}(2^n)$.
- `Toy‑тест:` Полусумматор: $s=a\oplus b$, $c=a\land b$.
  $c\leftrightarrow(a\land b)$ кодируется 3 клаузаами,
  $s\leftrightarrow(a\oplus b)$ — 4 клаузаами. Итого $O(1)$ клауз на гейт,
  значит общий размер $O(S)$.
- `Статус:` доказано (стандартное Tseitin‑кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1d,
  что $\mathrm{Count}_{\ge T}$ можно переводить в CNF с линейным оверхедом.

### 16.72. Исследовательский шаг: «почти половина» даёт большой порог

- `Линза:` Инвариант.
- `Утверждение:` При $t(n)=1/2-1/2^{n/4}$ порог $T(n)=t(n)2^n$ удовлетворяет
  $$2^{n-2}\ <\ T(n)\ <\ 2^{n-1}$$
  для всех достаточно больших $n$. Значит порог асимптотически пропорционален
  $2^n$ и «почти половина» ошибок — действительно большая доля.
- `Toy‑тест:` $n=8$: $T(8)=2^{7}-2^{6}=128-64=64$, и
  $2^{6}=64 < T(8)=64 < 2^{7}=128$ (граница достигается на малом $n$).
- `Статус:` доказано (оценка $2^{n-1}-2^{3n/4}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что порог $T(n)$ всегда линейный по $2^n$ (почти половина).

### 16.73. Исследовательский шаг: $t(n)$ монотонно растёт к $1/2$

- `Линза:` Инвариант.
- `Утверждение:` Функция $t(n)=1/2-2^{-n/4}$ монотонно возрастает по $n$ и
  $\lim_{n\to\infty} t(n)=1/2$. Следовательно, требование средней ошибки
  становится всё строже при росте $n$.
- `Toy‑тест:` $n=4$: $t=0$; $n=8$: $t=1/4$; $n=12$: $t=1/2-2^{-3}=3/8$.
  Значения растут и приближаются к $1/2$.
- `Статус:` доказано (монотонность $2^{-n/4}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что оно монотонно и стремится к $1/2$.

### 16.74. Исследовательский шаг: $\varphi$ невыполнима $\Leftrightarrow \mathrm{ML}(P_\varphi)\equiv 0$

- `Линза:` Эквивалентность.
- `Утверждение:` Для CNF $\varphi$ верно
  $$\varphi\ \text{невыполнима}\ \iff\ \mathrm{ML}(P_\varphi)\equiv 0.$$
  Доказательство: по шагам 16.53 и 16.64, $P_\varphi$ и $\mathrm{ML}(P_\varphi)$
  совпадают с индикатором выполнимости на $\{0,1\}^n$, а по 16.52 нулевой
  на кубе multilinear‑полином тождественно нулевой.
- `Toy‑тест:` $\varphi=(x)\wedge(\neg x)$ невыполнима. Тогда
  $P_\varphi=x(1-x)=x-x^2$, $\mathrm{ML}(P_\varphi)=x-x=0$.
  Для $\varphi=(x)$ имеем $P_\varphi=x$, $\mathrm{ML}(P_\varphi)=x\not\equiv 0$.
- `Статус:` доказано (сведение к предыдущим шагам).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что эквивалентность следует из шагов 16.52/16.53/16.64.

### 16.75. Исследовательский шаг: мелкость редукции не влияет на PIT

- `Линза:` Трейд‑офф.
- `Утверждение:` В барьере 15.7.4 детерминированный PIT для ROABP
  применяется к $\mathrm{ML}(P_\psi)$, где $|\psi|\le \mathrm{poly}(|\varphi|)$.
  Любой полиномиальный blow‑up редукции лишь меняет полином в степени
  размера/степени ROABP, поэтому время PIT остаётся полиномиальным.
- `Toy‑тест:` Если $|\psi|\le |\varphi|^2$ и PIT работает за $O(|\psi|^3)$,
  то общий runtime $O(|\varphi|^6)$ — всё ещё полином.
- `Статус:` доказано (оценка композиции).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.4c,
  что полиномиальный blow‑up не влияет на асимптотику PIT.

### 16.76. Исследовательский шаг: bounded‑occurrence 3‑SAT с линейным blow‑up

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из 3‑SAT в 3‑SAT, где каждая
  переменная встречается не более 9 раз, а размер растёт линейно.
  Конструкция: для переменной $x$ с $k$ вхождениями вводим $x_1,\dots,x_k$,
  заменяем каждое вхождение на свой $x_i$, и добавляем цепочку равенств
  $x_i\leftrightarrow x_{i+1}$ для $i=1..k-1$. Каждое равенство
  $(x_i\lor\neg x_{i+1})\land(\neg x_i\lor x_{i+1})$ превращаем в 3‑CNF
  через $(a\lor b)\equiv(a\lor b\lor y)\land(a\lor b\lor\neg y)$.
  Тогда для каждого $x_i$ получаем не более $1+2\cdot 4=9$ вхождений,
  а общее число новых клауз/переменных пропорционально сумме вхождений.
- `Toy‑тест:` $x$ встречается 3 раза. Вводим $x_1,x_2,x_3$ и клаузы
  $x_1\leftrightarrow x_2$, $x_2\leftrightarrow x_3$.
  Если $x=1$ в удовлетворяющем присваивании, то берём $x_1=x_2=x_3=1$,
  и все равенства истинны; обратно, равенства заставляют все $x_i$ совпадать,
  значит присваивание сжимается к значению $x$.
- `Статус:` доказано (явная редукция).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` при желании ужесточить константу до 4 (Tovey) или оценить
  blow‑up в планарной редукции Лихтенштейна.

### 16.77. Исследовательский шаг: счётчик $\mathrm{Count}_{\ge T}$ размера $O(N\log N)$

- `Линза:` Трейд‑офф.
- `Утверждение:` Для $N$ входных битов существует булева схема размера
  $O(N\log N)$ и глубины $O(\log N)$, вычисляющая
  $\mathrm{Count}_{\ge T}(b_1,\dots,b_N)$: построим двоичное дерево сумматоров,
  получая $k=\lceil\log_2 N\rceil$‑битную сумму $S$, затем сравним $S\ge T$
  компаратором размера $O(k)$. Для $N=2^n$ получаем размер $O(2^n n)$, т.е.
  $\mathrm{poly}(2^n)$, как требуется в масштабах LogLog.
- `Toy‑тест:` $N=4$, $T=3$. Складываем пары $(b_1,b_2)$ и $(b_3,b_4)$
  полусумматорами, затем суммируем два 2‑битных числа полным сумматором;
  компаратор проверяет $S\ge 3$ (двоично $11$).
- `Статус:` доказано (явная конструкция).
- `Барьер‑чек:` r — неприменимо (синтаксическая схема), NP — неприменимо
  (нет нижних оценок), alg — неприменимо (нет арифметизации).
- `Следующий шаг:` при желании связать с Леммой 15.7.1d: указать явный
  размер счётчика $O(2^n n)$ и затем применить 16.71 для CNF‑кодирования.

### 16.78. Исследовательский шаг: явный линейный счёт для CNF→3‑CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Пусть CNF $\varphi$ имеет клаузы длины $k_1,\dots,k_m$ и суммарно
  $L=\sum_j k_j$ литералов. Определим редукцию $r$: клаузы длины $\le 3$
  оставляем, а клаузу длины $k>3$ заменяем цепочкой из $k-2$ 3‑клауз с
  $k-3$ новыми переменными. Тогда
  $$\#\mathrm{clauses}(r(\varphi))\le \sum_{k_j\le 3}1+\sum_{k_j>3}(k_j-2)\le \sum_j k_j=L,$$
  и потому $\#\mathrm{lits}(r(\varphi))\le 3L$.
  Следовательно, редукция CNF→3‑CNF имеет линейный blow‑up по $L$.
- `Toy‑тест:` Клауза длины $4$ даёт $k-2=2$ клаузы и $k-3=1$ новую переменную,
  т.е. 6 литералов вместо 4; оценка $6\le 3\cdot 4$ выполняется.
- `Статус:` доказано (подсчёт по клаузам).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` при желании зафиксировать это как числовую ремарку
  в Лемме 15.7.3c (PIT ⇒ IPS/EF).

### 16.79. Исследовательский шаг: квантор по кодам схем и паддинг

- `Линза:` Эквивалентность.
- `Утверждение:` Зафиксируем gate-list кодирование булевых схем размера $\le s$
  битстроками длины $m(s)$, а также предикат $\mathrm{Valid}_s(C)$, который
  проверяет корректность кода. Тогда квантор «для всех схем размера $\le s$»
  эквивалентно выражается как
  $$\forall C<2^{m(s)}\ \bigl(\mathrm{Valid}_s(C)\to P(C)\bigr),$$
  где $P(C)$ — любое утверждение, зависящее только от декодированной схемы.
  В частности, ограничение $C\le m(s)$ в (H1$_\Pi$)/(H2$_\Pi$) фиксирует лишь
  длину кода (bounded‑квантор) и не исключает ни одной схемы размера $\le s$:
  короткий код можно дополнить нулями до длины $m(s)$ (не меняя декодированную
  схему), а $\mathrm{Valid}_s$ отсекает не‑коды.
- `Toy‑тест:` $s=2$. Схема из одного AND‑гейта имеет код длины $\le m(2)$.
  Дополнение до длины $m(2)$ нулями не меняет список гейтов (пустой «хвост»
  читается как фиктивные гейты/константы), поэтому $\mathrm{Valid}_2(C)=1$
  и все свойства схемы (выход на $x$) сохраняются.
- `Статус:` доказано (паддинг фиксирует длину).
- `Барьер‑чек:` r — неприменимо (синтаксический трюк), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` зафиксировать эту эквивалентность как ремарку рядом с
  Леммой 15.7.2b в основном тексте (закрыть Q2a).

### 16.80. Исследовательский шаг: 3‑CNF для $\mathrm{Count}_{\ge T}$ размера $O(N\log N)$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Пусть $N=2^n$ и $T\in\{0,\dots,N\}$. Тогда существует 3‑CNF
  формула $\mathrm{Count}_{\ge T}^{\mathrm{CNF}}(e,z)$ размера $O(N\log N)$
  (по числу клауз/литералов), такая что для любого присваивания $e\in\{0,1\}^N$
  выполнено:
  $$\exists z\ \mathrm{Count}_{\ge T}^{\mathrm{CNF}}(e,z)\quad\Longleftrightarrow\quad \sum_{i=1}^N e_i\ge T.$$
  Доказательство: по 16.77 есть схема размера $S=O(N\log N)$ для
  $\mathrm{Count}_{\ge T}$ (adder‑tree + компаратор), а по 16.71 Tseitin‑кодирование
  любой схемы размера $S$ даёт CNF (и даже 3‑CNF) с $O(S)$ вспомогательными
  переменными и $O(S)$ клаузами.
- `Toy‑тест:` $N=4$, $T=3$: схема вычисляет сумму $S\in\{0,\dots,4\}$ и проверяет
  $S\ge 3$. Tseitin‑кодирование добавляет константное число клауз на гейт,
  поэтому размер остаётся $O(4\log 4)$.
- `Статус:` доказано (композиция 16.77 + 16.71).
- `Барьер‑чек:` r — неприменимо (синтаксическая конструкция), NP — неприменимо
  (нет нижних оценок), alg — неприменимо.
- `Следующий шаг:` зафиксировать как ремарку рядом с Леммой 15.7.1d (закрыть Q1a).

### 16.81. Исследовательский шаг: Tovey‑splitting даёт (O3, $L\le 3$)-SAT с линейным blow‑up

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из 3‑SAT в CNF, где каждая
  переменная встречается не более 3 раз, а длины клауз $\le 3$ (разрешены 2‑клаузы),
  причём размер растёт линейно. Конструкция (Tovey; см. Theorem 3 в Berman–Karpinski–Scott):
  если переменная $x$ встречается $d>3$ раз, вводим $x_1,\dots,x_d$,
  заменяем $d$ вхождений $x$ на $x_1,\dots,x_d$ и добавляем цикл 2‑клауз
  $$x_1\vee\neg x_2,\ x_2\vee\neg x_3,\ \dots,\ x_{d-1}\vee\neg x_d,\ x_d\vee\neg x_1.$$
  Эти клаузы эквивалентны $x_1=\cdots=x_d$, поэтому (не)выполнимость сохраняется.
  Каждый $x_i$ встречается ровно в одной исходной клаузе и в двух 2‑клаузах,
  то есть не более 3 раз; добавлено $d$ клауз и $d$ переменных, так что суммарный
  blow‑up $O(L)$ по числу литералов $L$ исходной формулы.
- `Toy‑тест:` $d=4$. Цикл
  $x_1\vee\neg x_2,\ x_2\vee\neg x_3,\ x_3\vee\neg x_4,\ x_4\vee\neg x_1$
  задаёт импликации $x_2\to x_1\to x_4\to x_3\to x_2$, значит все $x_i$ равны.
  Тогда удовлетворяющее присваивание переносится между исходной формулой и новой,
  полагая $x:=x_1$ и $x_i:=x$.
- `Статус:` доказано (явная редукция + подсчёт).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` найти/зафиксировать гаджет, устраняющий 2‑клаузы и дающий
  3‑CNF с ограничением ≤4 вхождения (Tovey‑вариант), либо оценить blow‑up
  в планарной редукции Лихтенштейна.

### 16.82. Исследовательский шаг: устранение 2‑клауз ⇒ 3‑CNF с ограничением ≤4 вхождения

- `Линза:` Эквивалентность.
- `Утверждение:` Существует p‑time редукция $R$ из 3‑SAT в 3‑SAT, такая что в
  $R(\varphi)$ каждая переменная встречается не более 4 раз, а размер растёт
  линейно по числу литералов. Достаточно улучшить конструкцию 16.81:
  все 2‑клаузы вида $(x_i\vee\neg x_{i+1})$ заменить на 3‑клаузы
  $$(x_i\vee x_i\vee\neg x_{i+1}).$$
  Эта замена эквивалентна (добавляет дубликат литерала), поэтому (не)выполнимость
  сохраняется. Если $x_i$ — копия переменной из 16.81, то она встречается
  1 раз в «исходной» 3‑клаузе и ещё 3 раза в цикле (дважды как $x_i$ в своей
  клаузе и один раз как $\neg x_i$ в предыдущей), итого ≤4.
- `Toy‑тест:` цикл для $d=4$:
  $(x_1\vee x_1\vee\neg x_2)\wedge(x_2\vee x_2\vee\neg x_3)\wedge
  (x_3\vee x_3\vee\neg x_4)\wedge(x_4\vee x_4\vee\neg x_1)$
  эквивалентен циклу 2‑клауз из 16.81 и потому задаёт $x_1=\cdots=x_4$.
  Подсчёт: $x_2$ встречается дважды в своей клаузе, один раз как $\neg x_2$
  в первой и (ровно) один раз в исходной 3‑клаузе, где она заменила одно
  вхождение переменной $x$.
- `Статус:` доказано (2→3‑padding + подсчёт вхождений).
- `Барьер‑чек:` r — применимо (чистая редукция, релятивизируется),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` в основном тексте рядом с Леммой 15.7.4d указать, что
  NP‑трудность 3‑SAT с ограничением «каждая переменная ≤4 вхождения» следует
  из 16.81–16.82 (без внешних фактов, кроме NP‑полноты 3‑SAT).

### 16.83. Исследовательский шаг: blow‑up редукции 3‑SAT → Planar 3‑SAT (Lichtenstein)

- `Линза:` Трейд‑офф.
- `Утверждение:` Пусть $\varphi$ — 3‑CNF с $m$ клаузами и $n$ переменными.
  В редукции Лихтенштейна (1982) граф $G(\varphi)$ рисуется на решётке
  $3m\times 3n$, а каждое пересечение двух дуг устраняется фиксированным
  crossover‑гаджетом, добавляющим $O(1)$ новых переменных/клауз. Поэтому
  итоговая Planar‑3‑CNF $\varphi'$ имеет размер $|\varphi'|=O(mn)$ и, в частности,
  $|\varphi'|=O(|\varphi|^2)$ (так как $n\le 3m\le O(|\varphi|)$).
- `Toy‑тест:` $m=n=2$: решётка $6\times 6$ имеет 36 потенциальных точек пересечения,
  значит даже грубая оценка даёт $|\varphi'|=O(1+36)$.
- `Статус:` доказано (оценка blow‑up из описания конструкции).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо
  (это NP‑полнота, не нижняя оценка), alg — неприменимо.
- `Следующий шаг:` сослаться на эту оценку рядом с Леммой 15.7.4d (закрыть Q5).

### 16.84. Исследовательский шаг: Planar‑3‑SAT ≤p Planar‑3‑SAT(≤4‑occ)

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из Planar‑3‑SAT в Planar‑3‑SAT, где
  каждая переменная встречается не более 4 раз. Пусть $\varphi$ — planar 3‑CNF и
  переменная $x$ встречается $d$ раз. Вводим копии $x_1,\dots,x_d$, заменяем $j$‑е
  вхождение $x$ на $x_j$ и добавляем цикл 3‑клауз
  $$(x_1\vee x_1\vee\neg x_2)\wedge(x_2\vee x_2\vee\neg x_3)\wedge\cdots\wedge(x_d\vee x_d\vee\neg x_1).$$
  Эти клаузы эквивалентны циклу импликаций $x_2\to x_1\to\cdots\to x_d\to x_2$,
  значит форсят $x_1=\cdots=x_d$; удовлетворимость сохраняется. Каждая $x_i$
  встречается дважды в своей клаузе цикла, один раз как $\neg x_i$ в предыдущей
  и ровно один раз в исходной 3‑клаузе ⇒ ≤4. Планарность сохраняется: в planar
  вложении инцидентного графа $\varphi$ заменяем вершину $x$ на planar‑гаджет‑цикл,
  присоединяя внешние рёбра (к исходным клаузам) к вершинам $x_i$ в том же
  циклическом порядке; локальная замена в диске не создаёт пересечений.
- `Toy‑тест:` $d=5$. Из клауз цикла следует $x_2\to x_1\to x_5\to x_4\to x_3\to x_2$,
  значит все $x_i$ равны. Подсчёт: у $x_3$ 2 вхождения в $(x_3\vee x_3\vee\neg x_4)$,
  1 вхождение как $\neg x_3$ в $(x_2\vee x_2\vee\neg x_3)$ и 1 вхождение в «своей»
  исходной клаузе.
- `Статус:` доказано (локальный split + planar‑замена вершины).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` добавить 1 строку в Лемму 15.7.4d: Planar‑3‑SAT(≤4‑occ)
  NP‑полон (Лихтенштейн + 16.84).

### 16.85. Исследовательский шаг: Tseitin($G,\chi$) и паритетный сертификат невыполнимости

- `Линза:` Инвариант.
- `Определение:` Пусть $G=(V,E)$ — неориентированный граф и $\chi:V\to\{0,1\}$
  («заряды»). Каждому ребру $e\in E$ сопоставим булеву переменную $x_e$.
  XOR‑система Tseitin задаётся уравнениями по модулю 2:
  $$\bigoplus_{e\ni v} x_e\ =\ \chi(v)\qquad\text{для всех }v\in V.$$
- `Утверждение:` Если для некоторой связной компоненты $H\subseteq G$ выполнено
  $\bigoplus_{v\in V(H)}\chi(v)=1$, то система (а значит и любая CNF/3‑CNF
  кодировка этих XOR‑ограничений) невыполнима.
- `Доказательство:` Возьмём XOR по всем вершинам $v\in V(H)$ от левых частей.
  Каждая переменная $x_e$ (для ребра $e$ внутри $H$) входит ровно дважды — по
  концам ребра — и потому сокращается: $\bigoplus_{v\in V(H)}\bigoplus_{e\ni v}x_e=0$.
  Тогда из уравнений следует $0=\bigoplus_{v\in V(H)}\chi(v)=1$, противоречие.
- `3‑CNF кодировка для 3‑регулярного $G$:` если $\deg(v)=3$ и инцидентные ребра
  имеют переменные $a,b,c$, то ограничение $a\oplus b\oplus c=\chi(v)$ эквивалентно
  3‑CNF из 4 клауз (запрещаем 4 несовпадающих по паритету тройки). Поэтому при
  3‑регулярном $G$ получаем 3‑CNF размера $4|V|$, и каждая переменная $x_e$ входит
  ровно в $8$ клауз (по $4$ у каждого конца ребра).
- `Toy‑тест:` одно ребро $e=\{u,v\}$ и $\chi(u)=1,\chi(v)=0$ даёт систему
  $x_e=1$ и $x_e=0$ (явная невыполнимость); паритетный аргумент выше ровно это
  фиксирует как $\chi(u)\oplus\chi(v)=1$.
- `Статус:` доказано (паритетный инвариант) + явная 3‑CNF для $\Delta=3$.
- `Барьер‑чек:` r — применимо (тривиально релятивизируется), NP — неприменимо
  (нет «natural property»), alg — неприменимо.
- `Следующий шаг:` зафиксировать в основном тексте, что это даёт семейство
  невыполнимых 3‑CNF с bounded‑occ на 3‑регулярных экспандерах, и привязать
  к известным резолюционным нижним оценкам (через экспансию/ширину).

### 16.86. Исследовательский шаг: экспансия ⇒ ширина/размер резолюции для Tseitin на bounded‑degree графах

- `Линза:` Трейд‑офф.
- `Утверждение:` Пусть $G=(V,E)$ — связный граф максимальной степени $\le k$, а
  $e(G):=\min_{A\subseteq V,\ |V|/3\le |A|\le 2|V|/3}|E(A,\bar A)|$ — его экспансия
  (Itsykson–Oparin 2013, Def. 2). Если Tseitin($G,\chi$) невыполнима, то ширина
  резолюционного опровержения удовлетворяет $W(\mathrm{Tseitin}(G,\chi)\vdash 0)\ge e(G)-1$
  (Itsykson–Oparin 2013, Cor. 1). Тогда по trade‑off “width ⇒ size”
  (Ben‑Sasson–Wigderson 2001; также сформулировано как Thm. 1 в Itsykson–Oparin 2013)
  получаем для числа переменных $n:=|E|$:
  $$S(\mathrm{Tseitin}(G,\chi))\ \ge\ \exp\!\left(\frac{(e(G)-k-1)^2}{n}\right),\qquad
    ST(\mathrm{Tseitin}(G,\chi))\ \ge\ 2^{\,e(G)-k-1}.$$
  В частности, для семейства графов степени $O(1)$ с $e(G)=\Omega(|V|)$ (экспандеры)
  имеем $n=\Theta(|V|)$ и потому $S\ge \exp(\Omega(|V|))$.
- `Toy‑тест:` цикл $C_n$ имеет $e(C_n)=2$, значит оценка даёт лишь константную
  нижнюю границу на ширину/размер; это согласуется с тем, что “плохая” экспансия
  не должна давать сильных нижних оценок.
- `Статус:` доказано (цитата Cor. 1 + стандартный width–size trade‑off).
- `Барьер‑чек:` r — неприменимо (модель‑специфическая нижняя оценка),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` применить к 3‑регулярным экспандерам и 3‑CNF кодировке из §16.85,
  чтобы получить явное семейство bounded‑occ 3‑CNF с экспоненциальной резолюцией.

### 16.87. Исследовательский шаг: явное bounded‑occ Tseitin‑семейство на 3‑регулярных экспандерах

- `Линза:` Эквивалентность.
- `Утверждение:` Существует сильно‑явное семейство 3‑регулярных экспандеров
  $\{G_n\}$ с $\lambda(G_n)\le \lambda_0<1$ (например, семейство Ramanujan‑графов;
  см. обсуждение в `../resources/downloads/arora_barak.pdf`, §16.3, Remark 16.10).
  Тогда по связи спектральной и комбинаторной экспансии (Arora–Barak, Thm. 16.18)
  имеем $|E(A,\bar A)|\ge \rho d|A|$ для всех $|A|\le |V|/2$ и некоторой константы
  $\rho>0$, откуда $e(G_n)=\Omega(|V_n|)$ в смысле Def. 2 из Itsykson–Oparin.
  Пусть $\chi_n$
  имеет нечётную сумму зарядов, и $F_n$ — 3‑CNF кодировка Tseitin($G_n,\chi_n$) из §16.85.
  Тогда:
  (i) $F_n$ невыполнима; (ii) $|F_n|=\Theta(|V_n|)$; (iii) bounded‑occ = 8;
  (iv) размер резолюционного опровержения $S(F_n)=\exp(\Omega(|V_n|))$ (по §16.86).
- `Toy‑тест:` если $G$ — цикл, то $e(G)=2$ и §16.86 даёт лишь константные границы;
  на экспандере $e(G)=\Omega(|V|)$ и при $|E|=\Theta(|V|)$ получаем экспоненту
  $\Omega(|V|)$ в нижней оценке на $S(F)$.
- `Статус:` доказано (композиция 16.85 + 16.86 + существование expander family).
- `Барьер‑чек:` r — неприменимо (модель‑специфическая нижняя оценка),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` уточнить/зафиксировать конкретную ссылку на выбранную явную
  3‑регулярную expander family (по необходимости) и отметить, какие системы
  доказательств (PC/EF) остаются открытыми на этих формулах.

### 16.88. Исследовательский шаг: Tseitin легко в EF; PC зависит от поля/базиса

- `Линза:` Алгебраизация.
- `Утверждение:` Пусть $G$ связен и $\bigoplus_{v\in V}\chi(v)=1$. Тогда 3‑CNF
  кодировка $F=\mathrm{TseitinCNF}(G,\chi)$ из §16.85 имеет полиномиальное
  опровержение в Extended Frege (EF), так как
  противоречие даёт суммирование XOR‑уравнений по модулю 2. Для Polynomial
  Calculus: над полем характеристики 2 соответствующая линейная система
  опровергается в степени 1; над $\mathrm{char}(F)\ne 2$ в Fourier‑базисе известны
  линейные degree‑нижние оценки (Beame–Sabharwal 2000, Thm. 2.18).
- `Доказательство (EF‑каркас):`
  Обозначим $a\oplus b := (a\wedge\neg b)\vee(\neg a\wedge b)$.
  Тождества ассоциативности/коммутативности и сокращения
  $a\oplus(a\oplus b)\leftrightarrow b$, $a\oplus a\leftrightarrow 0$
  имеют константный размер (3 переменные) ⇒ константные Frege‑выводы.
  Для каждой вершины $v$ степени 3, с инцидентными рёбрами $e_1,e_2,e_3$,
  4 клаузы из §16.85 эквивалентны формуле
  $$(x_{e_1}\oplus x_{e_2}\oplus x_{e_3})\leftrightarrow \chi(v)$$
  (проверка 8 значений; константный вывод).
  В EF введём extension‑переменные $p_v\leftrightarrow (x_{e_1}\oplus x_{e_2}\oplus x_{e_3})$
  и $P\leftrightarrow\bigoplus_{v\in V} p_v$ (цепочка/дерево XOR, размер $O(|V|)$).
  Из предыдущего получаем $P\leftrightarrow\bigoplus_v\chi(v)$, а значит $P$.
  С другой стороны, подставляя определения $p_v$ и используя локальные
  перестановки/скобки XOR (полиномиально много шагов), получаем
  $$P\leftrightarrow\bigoplus_{v\in V}\ \bigoplus_{e\ni v} x_e\ \leftrightarrow\ \bigoplus_{e\in E}(x_e\oplus x_e)\ \leftrightarrow\ 0,$$
  противоречие.
- `Ссылка (EF ⊢ XOR/Gauss):` отмечено, что EF «легко симулирует Gaussian elimination»
  (и потому полиномиально доказывает линейно‑алгебраические утверждения),
  см. Bonet–Buss–Pitassi 2002, `../resources/downloads/bonet_buss_pitassi_2002_hard_examples_frege.pdf` (p. 7).
- `PC‑заметка:` Если рассматривать Tseitin как линейную систему над $\mathbb F_2$,
  $$\sum_{e\ni v} x_e = \chi(v)\quad(\bmod 2),$$
  то в PC над $\mathbb F_2$ опровержение получается в степени 1: суммируем
  уравнения по $v\in V$, получаем $0=\bigoplus_v\chi(v)=1$.
- `Известный факт (PC, $\mathrm{char}(F)\ne 2$):` для любой последовательности bounded‑degree
  графов $\{G_n\}$ с $c(G_n)=\Omega(1)$ (экспандеры) любая PC‑рефутация
  $\mathrm{Tseitin}(G_n)$ над полем нечётной или нулевой характеристики имеет степень
  $\Omega(|V_n|)$, а по связи degree→size также размер $\exp(\Omega(|V_n|))$
  (Razborov 2023, Thm. 6.8 + абзац после Thm. 6.9).
- `Toy‑тест:` $G=C_3$ и $\chi\equiv 1$. Сумма трёх уравнений даёт
  $(x_{12}\oplus x_{12})\oplus(x_{23}\oplus x_{23})\oplus(x_{31}\oplus x_{31})=1$,
  то есть $0=1$.
- `Статус:` EF‑верхняя оценка — доказано как схема; для PC над $\mathbb F_2$ — доказано;
  для $\mathrm{char}(F)\ne 2$ степень и размер — известные нижние оценки (см. факт выше).
- `Барьер‑чек:` r — неприменимо (утверждение про конкретные proof‑системы),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` см. §16.89 (клаузная форма TseitinCNF легко в PC над $\mathbb F_2$);
  дальше — понять, переносится ли (и как) degree‑LB для $\mathrm{char}(F)\ne 2$ с XOR‑системы
  на 3‑CNF кодировку.

### 16.89. Исследовательский шаг: TseitinCNF легко в PC над $\mathbb F_2$ (степень 3)

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $G$ — 3‑регулярный граф, $\chi:V\to\{0,1\}$ и
  $\bigoplus_{v\in V}\chi(v)=1$. Пусть $F=\mathrm{TseitinCNF}(G,\chi)$ — 3‑CNF из §16.85.
  Тогда над полем $\mathbb F_2$ существует Polynomial Calculus‑рефутация $F$ степени $\le 3$
  и размера $O(|V|)$.
- `Доказательство (локальная линейная форма):`
  Переводим клаузу $(\ell_1\vee \ell_2\vee \ell_3)$ в полиномиальное уравнение
  $$(1-\ell_1)(1-\ell_2)(1-\ell_3)=0,$$
  где литерал $\neg x$ интерпретируется как $1-x$ (булевы аксиомы $x^2-x=0$ не нужны).
  Зафиксируем вершину $v$ степени 3 с инцидентными рёбрами $e_1,e_2,e_3$ и обозначим
  $x_i:=x_{e_i}$.
  - Если $\chi(v)=1$, то 4 клаузы из §16.85 дают 4 аксиомы:
    $$(1-x_1)(1-x_2)(1-x_3)=0,\ (1-x_1)x_2x_3=0,\ x_1(1-x_2)x_3=0,\ x_1x_2(1-x_3)=0.$$
    Складывая их в $\mathbb F_2$, получаем $1+x_1+x_2+x_3=0$, то есть $x_1+x_2+x_3+\chi(v)=0$.
  - Если $\chi(v)=0$, то аналогично из 4 клауз получаем аксиомы:
    $$(1-x_1)(1-x_2)x_3=0,\ (1-x_1)x_2(1-x_3)=0,\ x_1(1-x_2)(1-x_3)=0,\ x_1x_2x_3=0,$$
    и их сумма равна $x_1+x_2+x_3=0$, то есть снова $x_1+x_2+x_3+\chi(v)=0$.

  Итак, для каждого $v$ выводится линейное уравнение
  $$\sum_{e\ni v} x_e\ +\ \chi(v)\ =\ 0\quad(\text{в }\mathbb F_2).$$
  Складывая эти уравнения по всем $v\in V$, получаем
  $$\sum_{v\in V}\sum_{e\ni v}x_e\ +\ \sum_{v\in V}\chi(v)=0.$$
  Каждая переменная $x_e$ входит в левую часть ровно дважды (по концам ребра), значит
  в $\mathbb F_2$ сокращается, и остаётся $\sum_v\chi(v)=0$, то есть $1=0$ — противоречие.
  Степень доказательства $\le 3$ (все клаузные аксиомы степени 3), число строк $O(|V|)$.
- `Toy‑тест:` $G=C_3$ и $\chi\equiv 1$. Для каждой вершины выводится линейное уравнение
  по трём рёбрам, сумма трёх уравнений даёт $1=0$.
- `Статус:` доказано (явный локальный вывод + суммирование по графу).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` сформулировать такой же «локальный перевод» для $\mathrm{char}(F)\ne 2$
  (или найти ссылку), чтобы связать TseitinCNF с известными degree‑LB для PC.

### 16.90. Исследовательский шаг: TseitinCNF $\leftrightarrow$ биномиальная Tseitin в PC при $\mathrm{char}(F)\ne 2$

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $F$ — поле, $\mathrm{char}(F)\ne 2$, и $v$ — вершина степени 3
  с инцидентными переменными $x_1,x_2,x_3\in\{0,1\}$ и зарядом $\chi\in\{0,1\}$.
  Пусть 4 клаузы TseitinCNF($v$) — стандартная 3‑CNF кодировка ограничения
  $x_1\oplus x_2\oplus x_3=\chi$ (как в §16.85), переведённая в PC‑аксиомы вида
  $(1-\ell_1)(1-\ell_2)(1-\ell_3)=0$. Тогда:
  1) из этих 4 клауз в PC выводится одно уравнение степени 3
     $$X(x_1,x_2,x_3)-\chi=0,$$
     где
     $$X(x_1,x_2,x_3):=x_1+x_2+x_3-2(x_1x_2+x_1x_3+x_2x_3)+4x_1x_2x_3;$$
  2) при линейной замене $y_i:=1-2x_i$ это эквивалентно биномиальному уравнению
     $$y_1y_2y_3-(1-2\chi)=0\quad(\text{и }y_i^2-1=0);$$
  3) наоборот, из $X-\chi=0$ в PC выводятся все 4 клаузные аксиомы с константной
     потерей степени (≤6). Следовательно, для 3‑регулярных графов TseitinCNF и
     «биномиальная» Tseitin (Fourier/±1‑база) p‑эквивалентны по степени в PC.
     В частности, degree/size‑нижние оценки для биномиальной Tseitin при $\mathrm{char}(F)\ne 2$
     (Razborov 2023, Thm. 6.8; см. также Beame–Sabharwal 2000, Thm. 2.18) переносятся на TseitinCNF.

- `Доказательство (1, локально):`
  В $\mathbb F[x_1,x_2,x_3]/(x_i^2-x_i)$ каждая клаузная аксиома для вершины степени 3 —
  это индикатор запрещённого присваивания (моном степени 3 в литералах $x_i$ и $(1-x_i)$).
  Для $\chi=0$ запрещены 4 нечётные тройки, и сумма 4 индикаторов равна ровно $X$.
  Для $\chi=1$ запрещены 4 чётные тройки, и сумма индикаторов равна $1-X$.
  В обоих случаях из 4 равенств “индикатор = 0” выводится $X-\chi=0$
  (для $\chi=1$ умножением на $-1$).

- `Доказательство (2):`
  Раскрывая скобки,
  $$(1-2x_1)(1-2x_2)(1-2x_3)=1-2X(x_1,x_2,x_3).$$
  Поэтому
  $$y_1y_2y_3-(1-2\chi)=(1-2X)-(1-2\chi)=-2(X-\chi),$$
  то есть уравнения отличаются на ненулевой скаляр.

- `Доказательство (3, локально):`
  Пусть $m_{a_1a_2a_3}:=\prod_i (x_i)^{a_i}(1-x_i)^{1-a_i}$ — индикатор присваивания $(a_1,a_2,a_3)$.
  Если $(a_1\oplus a_2\oplus a_3)\ne\chi$, то на этом присваивании $X-\chi=\pm 1$, а на остальных
  $m_{a_1a_2a_3}=0$, значит в фактор‑алгебре тождественно
  $$(X-\chi)\,m_{a_1a_2a_3}=\pm m_{a_1a_2a_3}.$$
  Из $X-\chi=0$ по правилу умножения получаем $(X-\chi)m_{a_1a_2a_3}=0$, откуда $m_{a_1a_2a_3}=0$.
  Это ровно одна из 4 клауз TseitinCNF($v$). Степень: $\deg(X-\chi)\le 3$, $\deg(m)\le 3$, итого ≤6.

- `Toy‑тест:` $\chi=1$. Сумма 4 «чётных» индикаторов (000,011,101,110) равна $1-X$,
  значит из них следует $X-1=0$, а затем и $y_1y_2y_3+1=0$.
- `Статус:` доказано (локальная p‑эквивалентность по степени при $\mathrm{char}(F)\ne 2$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` если нужно для основного текста, добавить 1‑строчную ремарку в 15.x:
  «при $\mathrm{char}(F)\ne 2$ TseitinCNF наследует PC degree/size‑LB через 16.90».

### 16.91. Исследовательский шаг: Tseitin имеет полиномиальные Frege‑опровержения (Urquhart 1987)

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $G$ связен и $\bigoplus_{v\in V}\chi(v)=1$; пусть $\mathrm{TseitinCNF}(G,\chi)$ — клаузная
  форма уравнений по модулю 2 (как в §16.85 для $\deg(G)=3$, или в общем виде через $2^{\deg(v)-1}$ клауз на вершину).
  Тогда $\mathrm{TseitinCNF}(G,\chi)$ имеет полиномиальное опровержение в обычном Frege (в частности,
  в «Kleene’s axiomatic system», т.е. Hilbert‑style propositional calculus): Urquhart (1987) даёт
  явный вывод длины $O(n^4)$ (где $n=\Theta(|V|)$ при bounded‑degree).
- `Доказательство (идея из Urquhart 1987, Lemma 6.1):`
  1) для каждой вершины $v$ из клаузы‑кодировки восстанавливается соответствующее XOR‑уравнение
     (у Urquhart — «biconditional»/эквивалентность, фиксирующая чётность литералов у вершины);
  2) эти эквивалентности «склеиваются» в одно большое выражение; затем с помощью
     ассоциативности/коммутативности «всплывают» парные вхождения переменных и сокращаются;
  3) остаётся противоречие, так как левая часть сокращается в $0$, а правая даёт
     $\bigoplus_v\chi(v)=1$.
  Подробности: Urquhart 1987, §6, Lemma 6.1, `../resources/downloads/urquhart_1987_hard_examples_resolution.pdf`.
- `Toy‑тест:` $G=C_3$, $\chi\equiv 1$: три локальные XOR‑уравнения суммируются в $0=1$
  (см. также toy‑тест в §16.88).
- `Статус:` доказано (верхняя оценка/ссылка).
- `Барьер‑чек:` r — неприменимо (это верхняя оценка в фиксированной модели доказательств),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` уточнить «минимальную глубину» полиномиальных Frege‑опровержений Tseitin:
  зафиксировать лучшую известную depth‑vs‑size оценку (ссылка на работу уровня Håstad’17/18 и/или последующие усиления).

### 16.92. Исследовательский шаг: depth‑vs‑size для Tseitin(Grid) в bounded‑depth Frege (Håstad 2020)

- `Линза:` Трейд‑офф.
- `Утверждение:` Рассмотрим Tseitin‑противоречие на $n\times n$ решётке (grid).
  Если $d\le \frac{\log n}{59\log\log n}$, то любая depth‑$d$ Frege‑рефутация имеет размер
  $\exp(\Omega(n^{1/(58(d+1))}))$ (Håstad 2020, Thm. 6.5; `../resources/downloads/hastad_2020_small_depth_frege_tseitin_grids.pdf`).
  В частности, любая полиномиальная
  по $n$ (а значит и по числу переменных $N=\Theta(n^2)$) Frege‑рефутация требует формул глубины
  $\Omega(\log n/\log\log n)$ (Håstad 2020, Cor. 6.6).
- `Toy‑тест:` при константной глубине $d=O(1)$ получаем superpolynomial нижнюю оценку
  $\exp(\Omega(n^{\Omega(1)}))=\exp(\Omega(N^{\Omega(1)}))$ для Tseitin(Grid$_{n,n}$).
- `Статус:` известный факт (точная ссылка).
- `Барьер‑чек:` r — неприменимо (нижняя оценка для ограниченной модели доказательств),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` сопоставить с «верхней» оценкой $O(\log n)$ глубины для poly‑size Frege‑рефутаций Tseitin
  (Buss‑style счёт/паритет) и зафиксировать, насколько tight остаётся разрыв $O(\log\log n)$.

### 16.93. Исследовательский шаг: верхняя оценка $O(\log n)$ глубины для poly‑size Frege на Tseitin (bounded‑degree)

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для Tseitin‑противоречия на любом bounded‑degree графе (клаузная форма паритетных уравнений)
  существует полиномиальный по $n$ Frege‑вывод, использующий формулы глубины $O(\log n)$.
  Точная ссылка: Håstad 2020 прямо отмечает, что по методам Buss’87 (poly‑size $O(\log n)$‑depth Frege для PHP)
  «similar proofs can be constructed … for the Tseitin contradiction for any constant-degree graph»,
  см. `../resources/downloads/hastad_2020_small_depth_frege_tseitin_grids.pdf`, p. 2.
- `Toy‑тест:` на цикле можно выписать balanced‑формулу для XOR всех уравнений и сократить парные вхождения рёбер,
  получая $0=1$ при нечётной сумме зарядов.
- `Статус:` известный факт (точная ссылка; конструкция не развёрнута в этом ноутбуке).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` найти/зафиксировать источник с явной конструкцией (или написать самодостаточный вывод)
  и попытаться закрыть разрыв между $\Omega(\log n/\log\log n)$ (16.92) и $O(\log n)$.

### 16.94. Исследовательский шаг: балансовка формул ⇒ можно требовать глубину $O(\log n)$ в Frege

- `Линза:` Трейд‑офф.
- `Утверждение:` Любая булева формула размера $m$ эквивалентна формуле глубины $O(\log m)$
  (Brent/Spira restructuring). Точная ссылка: Bonet–Buss (2002), Theorem 2 (Spira),
  `../resources/downloads/bonet_buss_2002_size_depth_tradeoffs_boolean_formulae.pdf`.
  Следовательно, если $\mathrm{TseitinCNF}(G,\chi)$ имеет polynomial‑size Frege‑рефутацию
  (16.91, Urquhart 1987), то можно считать, что все большие промежуточные формулы
  в этой рефутации сбалансированы до глубины $O(\log n)$ (с полиномиальным blow‑up),
  т.е. верхняя оценка $O(\log n)$ по глубине не требует отдельной «счётной» конструкции.
- `Toy‑тест:` длинная цепочка дизъюнкций/биимпликаций длины $m$ имеет глубину $\Theta(m)$,
  но после балансировки становится глубины $O(\log m)$.
- `Статус:` частично (фиксирована точная ссылка на формульную балансировку; преобразование всей Frege‑рефутации
  в log‑depth оставлено как стандартная техника «замены линий на эквивалентные»).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` если нужно закрыть «техническую» часть, выписать явную схему:
  как из линии $A$ и доказанного $A\leftrightarrow A'$ (balanced) получать корректный log‑depth Frege‑вывод.

### 16.95. Исследовательский шаг: Urquhart‑Tseitin + Spira‑перевод ⇒ $O(\log n)$‑depth Frege (строго)

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть есть Frege‑опровержение формулы $\Phi$ в языке $L_\infty$, где в частности разрешены
  $\{\wedge,\oplus,\neg\}$ или $\{\equiv,\oplus\}$ (как в Urquhart 1987 для «biconditionals»).
  Тогда существует полиномиально по размеру доказательства Frege‑опровержение $\Phi'$ в стандартном языке
  $L_\in=\{\wedge,\vee,\neg\}$, причём перевод $\phi\mapsto\phi'$ устроен так, что:
  (i) $\phi'$ эквивалентна $\phi$ (по смыслу); (ii) глубина $\phi'$ равна $O(\log|\phi|)$ (Spira‑rebalancing);
  (iii) размер $\phi'$ полиномиален в $|\phi|$. Ссылка: Buss (1997), Theorem 3 + доказательство‑эскиз
  «indirect translation via Spira», `../resources/downloads/buss_1997_proof_complexity_intro.pdf`.
  Следствие: для bounded‑degree $\mathrm{TseitinCNF}(G,\chi)$ (нечётная сумма зарядов) существует
  polynomial‑size Frege‑опровержение, использующее формулы глубины $O(\log n)$: берём
  Urquhart (1987) (16.91) и применяем перевод Buss’97/Spira.
- `Toy‑тест:` если делать «прямой перевод» $\phi_1\oplus\phi_2\mapsto(\phi_1\wedge\neg\phi_2)\vee(\neg\phi_1\wedge\phi_2)$
  рекурсивно по линейной глубине, то размер может стать экспоненциальным; Spira‑перевод
  «ре‑балансирует» дерево и держит размер полиномиальным (Buss’97, Proof sketch к Thm. 3).
- `Статус:` известный факт (закрыта техническая часть для 16.94/вопроса Q14).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` использовать это как «чистое» обоснование верхней оценки $O(\log n)$ по глубине и
  дальше улучшать нижние оценки (сужать разрыв с 16.92).

### 16.96. Исследовательский шаг: Tseitin на экспандерах — depth‑vs‑size (Pitassi–Rossman–Servedio–Tan 2016)

- `Линза:` Трейд‑офф.
- `Утверждение:` Существует линейного размера 3‑CNF‑противоречие $\mathrm{Tseitin}(G_n[\alpha])$
  на 3‑регулярном $n$‑вершинном экспандере, такое что для любого $d$ любая depth‑$d$ Frege‑рефутация
  имеет размер $n^{\Omega((\log n)/d^2)}$ (Pitassi–Rossman–Servedio–Tan 2016, Thm. 1,
  `../resources/downloads/pitassi_rossman_servedio_tan_2016_expander_switching_lemma.pdf`).
  Следовательно, любая polynomial‑size Frege‑рефутация требует глубины $d=\Omega(\sqrt{\log n})$.
- `Toy‑тест:` если $d=O(1)$, то нижняя оценка даёт размер $\exp(\Omega((\log n)^2))=n^{\Omega(\log n)}$ (quasi‑poly),
  а если $d=\Theta(\sqrt{\log n})$, то показатель $(\log n)/d^2=\Theta(1)$ и оценка перестаёт быть superpolynomial.
- `Статус:` известный факт (точная ссылка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` сопоставить 16.96 (экспандер: $\sqrt{\log n}$) с 16.92 (grid: $\log n/\log\log n$)
  и понять, где именно “теряется” $\sqrt{\log n}\to\log n/\log\log n$ в технике ограничений.

### 16.97. Исследовательский шаг: treewidth даёт tight depth‑vs‑size для Tseitin в bounded‑depth Frege (Galesi–Itsykson–Riazanov–Sofronova 2019)

- `Линза:` Трейд‑офф.
- `Утверждение:` Пусть $G$ — связный неориентированный граф на $n$ вершинах, $t=\mathrm{tw}(G)$, и $\mathrm{Tseitin}(G,f)$ невыполнима.
  Тогда существуют константы $K,C>0$ такие, что для любого $d\le K\log n/\log\log n - C$ любая depth‑$d$ Frege‑рефутация
  имеет размер $\ge 2^{t^{\Omega(1/d)}}$ (Galesi–Itsykson–Riazanov–Sofronova 2019, Thm. 18,
  `../resources/downloads/galesi_itsykson_riazanov_sofronova_2019_bounded_depth_frege_tseitin_all_graphs.pdf`).
  Более того, для всех достаточно больших $d$ существует depth‑$d$ Frege‑рефутация размера $\le 2^{t^{O(1/d)}}\cdot\mathrm{poly}(|\mathrm{Tseitin}(G,f)|)$
  (там же, Thm. 19).
- `Toy‑тест:` если $\mathrm{tw}(G)=\Omega(n)$ (в частности, для bounded‑degree экспандеров, как отмечено в той же работе),
  то polynomial‑size ($n^{O(1)}$) возможно только при $d=\Omega(\log n/\log\log n)$; при $d=\Theta(\log n/\log\log n)$ верхняя оценка Thm. 19
  даёт размер $2^{n^{O(\log\log n/\log n)}}=2^{O(\log n)}=n^{O(1)}$, т.е. порог по глубине на экспандерах совпадает с grid‑случаем (16.92)
  и усиливает PRST’16 (16.96).
- `Статус:` известный факт (точная ссылка; закрывает «усиление для экспандеров/всех графов» из Q15).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` если понадобится связать с «поиском доказательств», извлечь Cor. 34 из той же работы:
  bounded‑depth Frege размера $S$ ⇒ tree‑like Resolution размера $2^{\mathrm{poly}(\log S)}$.

### 16.98. Исследовательский шаг: bounded‑depth Frege ⇒ tree‑like Resolution (quasi‑poly) для Tseitin (GIRS 2019, Cor. 34)

- `Линза:` Эквивалентность.
- `Утверждение:` Для любой невыполнимой Tseitin‑CNF $\mathrm{Tseitin}(G,f)$: если она имеет доказательство размера $S$
  в bounded‑depth Frege (в смысле статьи; ниже упоминается «constant‑depth Frege»), то она имеет tree‑like Resolution‑опровержение
  размера $\le 2^{\mathrm{poly}(\log S)}$ (Galesi–Itsykson–Riazanov–Sofronova 2019, Cor. 34,
  `../resources/downloads/galesi_itsykson_riazanov_sofronova_2019_bounded_depth_frege_tseitin_all_graphs.pdf`).
- `Доказательство (эскиз из §5 той же работы):` там используется (i) верхняя оценка на tree‑like Resolution через ширину:
  $\mathrm{size}_{\mathrm{TL\text{-}Res}}(\mathrm{Tseitin}(G,f))\le n^{O(w(G))}=2^{O(\mathrm{tw}(G)\,\Delta(G)\,\log n)}$
  (см. обсуждение перед Cor. 34); (ii) нижняя оценка из главной теоремы для bounded‑depth Frege: $S\ge 2^{\mathrm{tw}(G)^{\varepsilon}}$
  для некоторой константы $\varepsilon>0$ (глубина фиксирована); (iii) тривиально $S\ge|\mathrm{Tseitin}(G,f)|\ge 2^{\Delta(G)-1}$ и $S\ge n$.
  Отсюда $\mathrm{tw}(G)\le (\log S)^{1/\varepsilon}$, $\Delta(G)\le O(\log S)$ и $\log n\le O(\log S)$, и подстановка в (i)
  даёт $2^{O((\log S)^{1/\varepsilon+2})}=2^{\mathrm{poly}(\log S)}$.
- `Toy‑тест:` если $S=n^{O(1)}$, то получаем tree‑like Resolution размера $\le 2^{\mathrm{poly}(\log n)}=n^{\mathrm{polylog}\,n}$ (quasi‑poly).
- `Статус:` известный факт (точная формулировка + минимальный вывод «откуда берётся» $2^{\mathrm{poly}(\log S)}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` внешний факт для tree‑like upper bound фиксирован в §16.99 (Beame–Beck–Impagliazzo 2016, Lemma 61);
  осталось согласовать/зафиксировать параметры $w(G)$ в цепочке Cor. 34 (см. §16.100–16.101 и Q20).

### 16.99. Исследовательский шаг: tree‑like Resolution‑upper bound для Tseitin через carving width (Beame–Beck–Impagliazzo 2016)

- `Линза:` Трейд‑офф.
- `Утверждение:` Пусть $G$ — граф на $n$ вершинах с carving width $W$ (Definition 58). Тогда соответствующая
  Tseitin‑таутология $\tau(G)$ имеет tree‑like resolution‑рефутацию ранга $\le W\log_{3/2} n$; в частности,
  существует tree‑like resolution‑рефутация размера $\le n^{W(\log 3-1)}$ и clause space $\le W\log_{3/2} n+1$
  (Beame–Beck–Impagliazzo 2016, Lemma 61,
  `../resources/downloads/beame_beck_impagliazzo_2016_time_space_tradeoffs_resolution.pdf`).
- `Toy‑тест:` при $W=O(1)$ получаем polynomial‑size tree‑like resolution для $\tau(G)$ (и глубину дерева $O(\log n)$);
  при каждом рекурсивном разрезе по (1/3,2/3)-лемме ранг увеличивается на $\le W$, а высота рекурсии равна $\log_{3/2} n$.
- `Статус:` известный факт (точная ссылка; закрывает «где именно берётся» tree‑like upper bound, т.е. компонент [3] в GIRS’19 Cor. 34).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` связать параметр $W$ (carving width) с $w(G)$ из GIRS’19 (минимальная resolution‑width для Tseitin)
  и выписать минимальную цепочку неравенств, нужную для $n^{O(w(G))}$.

### 16.100. Исследовательский шаг: carving width $\le \mathrm{tw}(L(G))+1$ (и значит $n^{O(W)}=n^{O(w(G))}$)

- `Линза:` Эквивалентность.
- `Утверждение:` Для любого графа $G$ выполнено $\mathrm{cw}(G)\le \mathrm{tw}(L(G))+1$, где $\mathrm{cw}$ — carving width,
  а $L(G)$ — line graph. Следовательно, используя формулу для Tseitin‑width
  $w(G)=\max\{\Delta(G),\mathrm{tw}(L(G))\}-1$ (Galesi–Talebanfard–Torán 2018, Cor. 8+16,
  `../resources/downloads/galesi_talebanfard_toran_2018_cops_robber_tseitin.pdf`), получаем $\mathrm{cw}(G)\le w(G)+2$, и верхняя оценка
  из §16.99 вида $n^{O(\mathrm{cw}(G))}$ эквивалентна $n^{O(w(G))}$.
- `Доказательство:` Пусть $(T,\{B_t\})$ — tree decomposition графа $L(G)$ ширины $k=\mathrm{tw}(L(G))$,
  т.е. $|B_t|\le k+1$.
  Для вершины $v\in V(G)$ множество рёбер $E(v)$ образует клику в $L(G)$, значит (по свойству Helly для поддеревьев в $T$)
  существует узел $t_v\in V(T)$ такой, что $E(v)\subseteq B_{t_v}$.
  Добавим к $T$ лист $\ell_v$ с ребром $\ell_v t_v$ и положим $\chi(\ell_v)=v$; получаем carving‑дерево
  (при необходимости его можно сделать бинарным стандартным «раздвоением» узлов копиями того же bag — ширина не растёт).
  Рассмотрим ребро $xy$ этого дерева и индуцированный разрез $V(G)=A\sqcup B$ по листьям.
  Если $xy=\ell_v t_v$, то $|E(A,B)|=\deg(v)\le |B_{t_v}|\le k+1$.
  Иначе $xy$ соединяет два bag‑узла: если $uv\in E(A,B)$, то в $L(G)$ вершина $e=\{u,v\}$ лежит и в $B_{t_u}$, и в $B_{t_v}$,
  значит её множество появлений в tree decomposition — связное поддерево, содержащее путь $t_u\leadsto t_v$ и, в частности, ребро $xy$.
  Следовательно, $e\in B_x\cap B_y$, то есть $E(A,B)\subseteq B_x\cap B_y$ и $|E(A,B)|\le |B_x\cap B_y|\le k+1$.
  Значит ширина построенной carving‑декомпозиции $\le k+1$, т.е. $\mathrm{cw}(G)\le \mathrm{tw}(L(G))+1$.
- `Toy‑тест:` для цикла $C_n$: $\mathrm{tw}(L(C_n))=2$, поэтому $\mathrm{cw}(C_n)\le 3$ (на деле $\mathrm{cw}(C_n)=2$);
  для звезды $K_{1,n}$: $\mathrm{tw}(L)=n-1$ и $\mathrm{cw}(K_{1,n})=n=\mathrm{tw}(L)+1$.
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` теперь, когда первоисточник $w(G)=\max\{\Delta(G),\mathrm{tw}(L(G))\}-1$ зафиксирован (16.101),
  обновить цепочку в §16.98/Cor. 34: tree‑like upper bound $n^{O(\mathrm{cw}(G))}$ можно заменить на $n^{O(w(G))}$ без ссылочных дыр.

### 16.101. Исследовательский шаг: точная ссылка на $w(G)=\max\{\\Delta(G),\\mathrm{tw}(L(G))\\}-1$ для Tseitin‑width

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $G$ — связный граф, а $\\varphi$ — нечётная разметка (odd marking), так что Tseitin‑CNF $T(G,\\varphi)$ невыполнима.
  Тогда минимальная ширина резолюционного опровержения удовлетворяет
  $$W(T(G,\\varphi)\\vdash\\bot)=\\max\\{\\Delta(G),\\mathrm{tw}(L(G))\\},$$
  где $\\Delta(G)$ — максимальная степень, $L(G)$ — line graph. В обозначениях GIRS’19 (Cor. 33),
  где $w(G)=W(T(G,\\varphi)\\vdash\\bot)-1$, получаем
  $$w(G)=\\max\\{\\Delta(G),\\mathrm{tw}(L(G))\\}-1.$$
- `Доказательство (по источнику):` Galesi–Talebanfard–Torán (2018) доказывают (i) Cor. 8:
  $W(T(G,\\varphi)\\vdash\\bot)=\\max\\{\\Delta(G),\\mathrm{ec}(G)-1\\}$, и (ii) Cor. 16:
  $\\mathrm{ec}(G)=\\mathrm{tw}(L(G))+1$; подстановка даёт требуемую формулу.
  См. `../resources/downloads/galesi_talebanfard_toran_2018_cops_robber_tseitin.pdf`.
- `Toy‑тест:` для звезды $K_{1,n}$ имеем $\\Delta=n$ и $L(G)=K_n$ с $\\mathrm{tw}(K_n)=n-1$,
  значит $W=\\max\\{n,n-1\\}=n$ (и $w=n-1$), что согласуется с тем, что начальные клаузы имеют ширину $n$.
  Для цикла $C_n$: $\\Delta=2$ и $L(C_n)=C_n$ с $\\mathrm{tw}=2$, поэтому $W=2$ (и $w=1$).
- `Статус:` известный факт (точная ссылка; закрывает Q19).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` использовать эту формулу, чтобы убрать «фольклорность» $n^{O(w(G))}$ в §16.98/Cor. 34 и при необходимости
  привести $n^{O(w(G))}$ к $2^{O(\\mathrm{tw}(G)\\,\\Delta(G)\\log n)}$ через оценки на $\\mathrm{tw}(L(G))$ (Harvey–Wood 2018; см. GIRS’19 Cor. 33).

### 16.60. Исследовательский шаг: степень $P_\varphi$ полиномиальна

- `Линза:` Инвариант.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с суммарным числом
  литералов $L$ полином $P_\varphi=\prod_j S_{C_j}$ имеет степень
  $\deg(P_\varphi)=\sum_j |C_j|\le L$. После multilinearization степень
  не увеличивается. Следовательно, степень $P_\varphi$ и $\mathrm{ML}(P_\varphi)$
  полиномиальна в $|\varphi|$, что согласуется с требованиями PIT для ROABP.
- `Toy‑тест:` $\varphi=(x_1\lor x_2)\wedge(\neg x_2\lor x_3\lor x_4)$:
  $\deg S_{C_1}=2$, $\deg S_{C_2}=3$, значит $\deg P_\varphi=5$ (полиномиально).
- `Статус:` доказано (прямой подсчёт степени).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку возле Леммы 15.7.4,
  что степень $\mathrm{ML}(P_\varphi)$ ограничена $O(|\varphi|)$.

### 16.61. Исследовательский шаг: $r(\varphi)$ логически усиливает $\varphi$

- `Линза:` Инвариант.
- `Утверждение:` Для стандартной редукции CNF→3‑CNF формула $r(\varphi)$
  логически влечёт $\varphi$ по исходным переменным: для каждой клаузы
  $(\ell_1\lor\cdots\lor\ell_k)$ цепочка 3‑клауз в $r(\varphi)$
  удовлетворима только если исходная клауза истинна. Следовательно,
  $r(\varphi)\to \varphi$ (но обратное неверно).
- `Toy‑тест:` Клауза $(\ell_1\lor\ell_2\lor\ell_3\lor\ell_4)$ заменяется на
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor\ell_4)$.
  Если все $\ell_i=0$, то первая клауза требует $y_1=1$, а вторая даёт
  $(\neg y_1\lor 0\lor 0)=0$, противоречие. Значит $r(\varphi)$ возможно
  только при истинной исходной клаузе.
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.3c,
  что $r(\varphi)\Rightarrow \varphi$, а для обратного направления нужен $g$.
