import Paperproof

/-!

# Идеи из chat_export.jsonl (черновик)

Короткие “идея‑карты”, извлечённые из `resources/chat_export.jsonl`.
Это **не доказанные результаты**: перед переносом в основной текст нужны формализация и/или точные ссылки.
Нумерация `CE-*` — для быстрых ссылок; строки источника — приблизительные.

## CE-1: Локальный детерминированный верификатор ⇒ экспоненциальный перебор
- Источник: `chat_export.jsonl`, ~стр. 8.
- Суть: если NP‑верификатор читает ≤ q(n) бит свидетеля (адаптивно), то язык лежит в `DTIME(2^q · poly(n))` (развёртка дерева запросов).
- Зачем: даёт формальный барьер для “детерминированного PCP‑подобного” локального чтения; любая сильная компрессия ведёт к быстрому детерминированному алгоритму.
- Следующий шаг: оформить как короткую лемму и проверить, что она применима к выбранным моделям “сжатой проверки”.

## CE-2: Глобальная несогласованность требует полного покрытия локальных связок
- Источник: ~стр. 10–12.
- Суть: цепочка эквивалентностей `z_i ↔ z_{i+1}` с противоречащими концами даёт UNSAT, но любое удаление звена делает формулу SAT.
- Зачем: toy‑пример того, что глобальный конфликт не выявляется локальными проверками, если есть “дырка”.
- Следующий шаг: использовать как минимальный гаджет для формализации “splicing” в табло‑CNF.

## CE-3: Splicing‑лемма для табло: пропуск окна ⇒ SAT
- Источник: ~стр. 14–18.
- Суть: для детерминированного процесса с абсорбирующим accept любая временная “дырка” в локальных ограничениях позволяет склеить корректный префикс и фальшивый суффикс; это разрушает soundness.
- Зачем: превращает аргумент “нужно покрыть все окна” в строгую лемму; даёт нижнюю оценку на число локальных проверок (≈ площадь табло) при фиксированной локальности.
- Следующий шаг: уточнить модель (TM/tiling) и вывести аккуратную оценку `Ω(s·T)` с минимальной локальностью.

## CE-4: Адресация/point‑chasing как минимальный универсальный примитив
- Источник: ~стр. 54–56.
- Суть: если “узкий” класс полиномов умеет реализовать адресацию (READ/WRITE) и замкнут под итерацией, то он становится универсальным; hitting set для него ⇒ общий PIT (Kabanets–Impagliazzo‑тип барьер).
- Зачем: объясняет, почему даже минимальная адресация взрывает сложность или ведёт к сильным следствиям.
- Следующий шаг: выбрать конкретный класс (ROABP/OBDD/read‑k ABP) и формально показать, что двухуровневый pointer‑chasing не помещается без blow‑up.

## CE-5: “Узкий сертификат” как read‑k / k‑pass ABP
- Источник: ~стр. 58–60.
- Суть: модель “короткого алгебраического сертификата” естественно выражается как read‑k oblivious ABP; для неё известны PIT‑алгоритмы, и это задаёт жёсткую цену проверки.
- Зачем: превращает “сертификат короткий и проверка дешевая” в формализуемый trade‑off.
- Следующий шаг: зафиксировать точный класс (k‑pass / read‑k) и выписать явный барьер “либо размер, либо PIT”.

## CE-6: Anti‑functional/weak‑cut барьер для детерминированных “монеток”
- Источник: ~стр. 20, 266–270, 282–284.
- Суть: если на сбалансированном разрезе отношение `R_{X|Y}(S)` имеет малую степень/покрытие графами, то существует Cauchy‑ошибка `D≠0`, зануляющаяся на всех точках `S` (детерминированная проверка на `S` слепа).
- Зачем: формализует требования к детерминированным наборам точек и связывает их с disperser/extractor‑геометрией.
- Следующий шаг: выписать чёткий параметр `κ` и условия, при которых Cauchy‑ловушка гарантированно возникает (с последующей проверкой на малых примерах).

## CE-7: Комбинаторный предел на `κ` через размер `|S|`
- Источник: ~стр. 284.
- Суть: утверждается, что для любого `S` существует разрез с `κ_X(R_{X|Y}(S)) ≤ O(√|S|)`.
- Зачем: даёт “информационный потолок” для детерминированных наборов точек малого размера.
- Следующий шаг: проверить формулировку/доказательство на небольших `S`, уточнить константы и условия (баланс разреза, размер проекций).

## CE-8: Мульти‑пасс logspace / read‑q BP ⇒ порог `Ω(log log N)`
- Источник: ~стр. 280 и 286.
- Суть: при малом числе проходов `q` матричный ранг на большом подмножестве координат ограничен `W^{O(q)}`; на dummy‑matching Cauchy‑ранг экспоненциален ⇒ требуется `q ≥ Ω(log log N)` для детерминированной проверки такого типа.
- Зачем: даёт конкретный “геометрический” барьер для целого класса детерминированных self‑verification‑скелетов.
- Следующий шаг: привести аргумент в аккуратный вид (ранговая лемма + многомерный Erdős–Szekeres + Cauchy‑ранг).

-/
