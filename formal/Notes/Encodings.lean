import Paperproof

/-!
NOTE: This file is the Lean-first mirror of `docs/research/16_encodings.md` (migrated from docs).
It is treated as research notes (not necessarily compiled as part of the core library).

# P vs NP — исследовательские шаги 16.37–16.84

См. `formal/Notes/Index.lean` (индекс заметок).
Главный индекс: `P_vs_NP.md`.

### 16.37. Исследовательский шаг: счётчик ошибок в tt‑формуле

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для любого $N=2^n$ и $T\in\{0,\dots,N\}$ существует булева схема
  размера $O(N\log N)$, вычисляющая $\mathrm{Count}_{\ge T}(e_1,\dots,e_N)$;
  построение — суммирование $N$ битов и компаратор с $T$.
  Для «простого» дерева ripple‑carry‑сумматоров глубина $O(\log^2 N)$ (высота дерева
  $O(\log N)$ и ширина суммы $O(\log N)$); глубину можно улучшить до $O(\log N)$
  (carry‑save/Wallace‑tree + финальное сложение), но в LogLog‑масштабе нам важен
  только размер $O(N\log N)=\mathrm{poly}(2^n)$.
- `Toy‑тест:` $N=4$: складываем $(e_1,e_2)$ и $(e_3,e_4)$ 2‑битными сумматорами,
  затем 3‑битным сумматором получаем сумму $\in\{0,\dots,4\}$; компаратор на 3 битах
  проверяет $\ge T$. Размер $O(N\log N)$; для $N=4$ глубина константна (а в общем случае см. утверждение).
- `Статус:` доказано (явная конструкция).
- `Барьер‑чек:` r — неприменимо (верхняя оценка), NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости зафиксировать в основном тексте конкретную
  реализацию (adder tree/Batcher) и кодирование $T$ длины $O(\log N)$.

### 16.38. Исследовательский шаг: Tseitin-кодирование $\mathrm{Eval}(C,x)$

- `Линза:` Эквивалентность.
- `Утверждение:` Для gate-list кодирования схемы $C$ размера $s$ (fan-in 2)
  существует CNF формула $\mathrm{Eval}_C(x,b)$ с $O(s)$ вспомогательными
  переменными и $O(s)$ клаузами, такая что для любого назначения входов $x$
  формула выполнима тогда и только тогда, когда выход схемы равен $b$.
- `Toy‑тест:` Схема: $g_1:=x_1\land x_2$, $g_2:=g_1\lor x_3$ (выход $g_2$).
  Tseitin-клаузы:
  $(\neg g_1\lor x_1)\land(\neg g_1\lor x_2)\land(g_1\lor\neg x_1\lor\neg x_2)$ и
  $(\neg g_2\lor g_1\lor x_3)\land(g_2\lor\neg g_1)\land(g_2\lor\neg x_3)$,
  плюс единичная клауза $(g_2)$ для $b=1$.
  При $x_1=x_2=1,x_3=0$ удовлетворяется с $g_1=g_2=1$; при $b=0$ невыполнима.
  На один гейт приходится $O(1)$ клауз, значит размер $O(s)$.
- `Статус:` доказано (стандартное Tseitin-кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` связать это кодирование с местом, где в тексте фиксируется
  $n=||x||$ при пропозициональном переводе в EF.

### 16.39. Исследовательский шаг: эквивалентность vs эквисатисфакция в CNF→3-CNF

- `Линза:` Эквивалентность.
- `Утверждение:` Стандартная редукция CNF→3-CNF порождает формулу $r(\varphi)$,
  логически эквивалентную $\varphi$ как формула над *всеми* переменными
  (исходными и новыми).
- `Toy‑тест:` Возьмём клаузу $\varphi=(x_1\lor x_2\lor x_3\lor x_4)$ и редукцию
  $r(\varphi)=(x_1\lor x_2\lor y)\land(\neg y\lor x_3\lor x_4)$.
  Присваивание $x_1=1,x_2=x_3=x_4=0,y=1$ делает $\varphi$ истинной, но
  $r(\varphi)$ ложной (вторая клауза ложна). Следовательно, полная эквивалентность
  неверна; верно лишь $\varphi\equiv \exists y\, r(\varphi)$.
- `Статус:` контрпример.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` использовать явную функцию $g$ (как в Лемме 15.7.3d),
  чтобы переносить истинность $\varphi$ на $r(\varphi)$ в EF.

### 16.40. Исследовательский шаг: порядок blow-up не влияет на барьер

- `Линза:` Трейд‑офф (размеры).
- `Утверждение:` Для барьера 15.7.4 достаточно любого полиномиального blow-up
  редукции $r$; явный порядок (линейный/квадратичный) не меняет вывода
  $\mathrm{P}=\mathrm{NP}$.
- `Toy‑тест:` Пусть $|r(\varphi)|\le |\varphi|^2$ и алгоритм $\mathcal A$
  строит ROABP размера $\le |\psi|^3$. Тогда композиция даёт ROABP
  размера $\le |\varphi|^6$, что остаётся полиномом. Следовательно, даже
  квадратичный blow-up не ломает аргумент.
- `Статус:` доказано (тривиальная оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при необходимости найти точный порядок blow-up в
  редукциях Лихтенштейна/Товея для библиографической аккуратности.

### 16.41. Исследовательский шаг: фиксация $n=||x||$ в масштабе LogLog

- `Линза:` Эквивалентность.
- `Утверждение:` Если в $LB_{tt}(h,s(n),t(n)2^n)$ подставить параметр
  $x:=2^{2^n}$, то $||x||=2^n+1$, и ограничения вида $u<2^n$ можно переписать
  bounded‑эквивалентно как $u+1<||x||$ (то есть $u<||x||-1$). Поэтому формула остаётся $\Pi^b_1$,
  а её пропозициональный перевод имеет размер $\mathrm{poly}(2^n)$ и даёт
  стандартный $tt(h_n,s(n),t(n))$.
- `Toy‑тест:` $n=2$: берём $x=2^{2^2}=16$, получаем $||x||=5$, и любой
  квантор $u<2^n=4$ эквивалентен $u+1<5$ (и это переписывание не меняет
  истинность ни для $\forall u$, ни для $\exists u$).
  Это иллюстрирует, как «таблица истинности» длины $2^n$ укладывается
  в bounded‑кванторы по $x$.
- `Статус:` доказано (прямая оценка длины).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` указать в основном тексте конкретное место, где
  фиксируется подстановка $x=2^{2^n}$ (PS Sec. 2.4.1) и как это отражается
  в EF‑переводе.

### 16.42. Исследовательский шаг: $\mathrm{Count}_{\ge T}$ через сортировочную сеть

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть сеть сортирует биты $e_1,\dots,e_N$ по невозрастанию,
  выдавая $b_1\ge \cdots \ge b_N$. Тогда $\mathrm{Count}_{\ge T}(e)$ эквивалентно
  условию $b_T=1$. Бэтчерова сортировочная сеть имеет $O(N\log^2 N)$ компараторов,
  каждый компаратор реализуется $O(1)$ AND/OR‑гейтами, значит схема для
  $\mathrm{Count}_{\ge T}$ имеет размер $O(N\log^2 N)$.
- `Toy‑тест:` $N=4$ и сеть с компараторами $(1,2),(3,4),(1,3),(2,4),(2,3)$
  (выходы — $(\max,\min)$). На входе $(1,0,1,0)$ получаем
  $(1,1,0,0)$, поэтому $\mathrm{Count}_{\ge 3}$ ложно, а $\mathrm{Count}_{\ge 2}$
  истинно (проверка по $b_3$ и $b_2$).
- `Статус:` доказано (стандартная сеть).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` решить, какой из вариантов (adder tree vs sorting network)
  удобнее фиксировать в основном тексте около Леммы 15.7.1d.

### 16.43. Исследовательский шаг: размер компаратора и кодирование порога $T$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для $N=2^n$ и любого целого $T\in[0,N]$ длина двоичного кода $T$
  равна $O(\log N)=O(n)$. Компаратор, проверяющий $S\ge T$ для суммы $S\in[0,N]$
  (в двоичном виде), реализуется схемой размера $O(\log N)$. Поэтому добавление
  порога не меняет асимптотику конструкции $\mathrm{Count}_{\ge T}$.
- `Toy‑тест:` $N=8$, $T=5=0101_2$, сумма $S=s_3s_2s_1s_0$.
  Условие $S\ge 5$ эквивалентно $s_3\ \lor\ (s_2\land(s_1\lor s_0))$,
  что даёт константный компаратор; размер растёт как $O(\log N)$ в общем случае.
- `Статус:` доказано (стандартный компаратор по двоичному сравнению).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить короткую ремарку о размере компаратора
  рядом с Леммой 15.7.1d.

### 16.44. Исследовательский шаг: длина gate‑list и $\Delta^b_0$‑валидность

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для схемы размера $s$ с fan‑in 2 и $n$ входами gate‑list
  кодирование имеет длину $m(s,n)=O(s\log s+n\log s)$: на каждый гейт
  сохраняются тип (константа) и два индекса входов $<i$, каждый индекс
  занимает $O(\log s)$ бит. Предикат $\mathrm{Valid}_s(C)$ проверяется
  bounded‑кванторами по $i\le s$ и индексам $<i$, поэтому является $\Delta^b_0$.
- `Toy‑тест:` $s=3,n=2$: кодируем гейты
  $g_1=\mathrm{IN}(1)$, $g_2=\mathrm{IN}(2)$, $g_3=\mathrm{AND}(1,2)$.
  Каждый индекс $\le 3$ кодируется 2 битами, тип — константным числом бит.
  Проверка $\mathrm{Valid}_3$ требует лишь условий «индексы $<i$».
  Если заменить $g_3=\mathrm{AND}(3,2)$, то условие $3<i$ ложно — контрпример
  к валидности при тех же bounded‑кванторах.
- `Статус:` доказано (явная оценка и проверка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании сослаться на Лемму 15.7.2b в основном тексте
  и отметить, что при $n\le s$ можно брать $m(s)=O(s\log s)$.

### 16.45. Исследовательский шаг: корректность явного $g$ в CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для клаузы $(\ell_1\lor\cdots\lor\ell_k)$ и цепочки
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land\cdots\land
  (\neg y_{k-3}\lor\ell_{k-1}\lor\ell_k)$ выбор
  $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ удовлетворяет всем новым клаузам
  при любом истинном значении исходной клаузы.
- `Toy‑тест:` $k=5$, пусть $\ell_3$ истинна, а $\ell_1=\ell_2=\ell_4=\ell_5=0$.
  Тогда $y_1=\neg(\ell_1\lor\ell_2)=1$, $y_2=\neg(\ell_1\lor\ell_2\lor\ell_3)=0$.
  Проверка цепочки:
  $(\ell_1\lor\ell_2\lor y_1)=(0\lor 0\lor 1)=1$,
  $(\neg y_1\lor\ell_3\lor y_2)=(0\lor 1\lor 0)=1$,
  $(\neg y_2\lor\ell_4\lor\ell_5)=(1\lor 0\lor 0)=1$.
- `Статус:` доказано (инвариант «префикс ложен»).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку к Лемме 15.7.3d,
  поясняющую инвариант «префикс ложен» для выбора $g$.

### 16.46. Исследовательский шаг: $\mathrm{Eval}(C,x)$ уже в 3-CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для gate‑list схемы fan‑in 2 Tseitin‑кодирование
  $\mathrm{Eval}_C(x,b)$ состоит из клауз ширины $\le 3$ (формулы для AND/OR/NOT)
  и потому является 3‑CNF без дополнительного blow-up; число клауз $O(s)$.
- `Toy‑тест:` Гейт $g=a\land b$ кодируется тремя клаузами:
  $(\neg g\lor a)$, $(\neg g\lor b)$, $(g\lor\neg a\lor\neg b)$ — ширина $\le 3$.
  Аналогично для $g=a\lor b$ и $g=\neg a$ (ширина $\le 2$).
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте, что для fan‑in 2
  дополнительная редукция в 3‑CNF не нужна.

### 16.47. Исследовательский шаг: граф p‑time функции как $\Delta^b_0$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R(n,C)$ вычисляется за полиномиальное время и
  $|R(n,C)|\le p(n)$, то существует bounded‑формула
  $\mathrm{Graph}_R(n,C,y)$ (кванторы по времени/ячейкам $\le p(n)$),
  такая что $\mathrm{Graph}_R(n,C,y)\iff y=R(n,C)$. Следовательно,
  подстановка $y:=R(n,C)$ в $\mathrm{RedCorr}(n,C,y)$ сохраняет
  $\Pi^b_1$‑форму.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1\oplus C_2$ (первые два бита).
  Тогда $\mathrm{Graph}_R(n,C,y)$ можно записать как bounded‑формулу
  $y\leftrightarrow (C_1\oplus C_2)$. Для $C=10$ получаем $y=1$;
  при $y=0$ формула ложна.
- `Статус:` доказано (стандартная $\Delta^b_0$‑граф‑формализация).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании связать это с формулировкой (H2$_\Pi$),
  где используется $R(n,C)$ вместо $\exists y$.

### 16.48. Исследовательский шаг: устранение $\exists y$ через $\mathrm{Graph}_R$

- `Линза:` Эквивалентность.
- `Утверждение:` Если определить
  $\mathrm{RedCorr}(n,C,y):=\mathrm{Graph}_R(n,C,y)\wedge \mathrm{Err}_{t(n)}(C,y)$,
  то для тотальной p‑time функции $R$ имеем эквивалентность
  $$\forall n\,\forall C\,\exists y\,\mathrm{RedCorr}(n,C,y)\ \iff\
  \forall n\,\forall C\,\mathrm{Err}_{t(n)}(C,R(n,C)).$$
  Значит (H2$_\Pi$) можно писать как $\forall n\,\forall C\,\mathrm{RedCorr}(n,C,R(n,C))$
  без выхода за $\Pi^b_1$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает первый бит $C$, а
  $\mathrm{Err}_{t(n)}(C,y)$ := $(y=1)$.
  Тогда $\exists y\,\mathrm{RedCorr}$ истинно $\iff C_1=1$,
  и это эквивалентно $\mathrm{Err}_{t(n)}(C,R(n,C))$ (также $C_1=1$).
- `Статус:` доказано (подстановка по графу функции).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить это прямо рядом с (H2$_\Pi$)
  в основном тексте.

### 16.49. Исследовательский шаг: ошибка как счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Пусть $e_x:=C(x)\oplus g_n(x)$ для всех $x\in\{0,1\}^n$.
  Тогда формула $\mathrm{Err}_{t(n)}(C,g_n)$ эквивалентна условию
  $\sum_x e_x < t(n)2^n$, то есть $\neg\,\mathrm{Count}_{\ge T}(e)$ при
  $T:=\lceil t(n)2^n\rceil$. Множество $S$ из определения $\mathrm{Err}_{t(n)}$
  можно взять равным $\{x:e_x=1\}$.
- `Toy‑тест:` $n=2$, $g(x)=x_1\oplus x_2$, а $C$ ошибается ровно на одном входе.
  Тогда $\sum_x e_x=1$. При $t(n)=1/2$ имеем $T=2$ и $\mathrm{Count}_{\ge 2}(e)=0$,
  то есть ошибка $< t(n)$, как и по определению через множество $S$ размера 1.
- `Статус:` доказано (перепись определения).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в основном тексте связь $\mathrm{Err}_{t(n)}$
  с $\mathrm{Count}_{\ge T}$ (как в $tt$‑формуле).

### 16.50. Исследовательский шаг: p‑time вычислимость $g$ для CNF→3-CNF

- `Линза:` Инвариант.
- `Утверждение:` Для каждой исходной клаузы $(\ell_1\lor\cdots\lor\ell_k)$
  значения $y_i:=\neg(\ell_1\lor\cdots\lor\ell_{i+1})$ вычисляются за $O(k)$
  времени, поддерживая префиксное OR. Для всей формулы $g(p)$ вычисляется
  за $O(|\varphi|)$, значит $g$ — p‑time и PV‑функция (доступна в EF).
- `Toy‑тест:` Для $\ell=(0,1,0,0)$ имеем префиксы
  $p_2=\ell_1\lor\ell_2=1$, $p_3=1$, $p_4=1$,
  поэтому $y_1=\neg p_2=0$, $y_2=\neg p_3=0$.
  Вычисление требует одного прохода по клаузе.
- `Статус:` доказано (линейный проход).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить в основном тексте ремарку, что $g$
  p‑time/PV‑вычислима, поэтому EF может использовать её в 15.7.3d.

### 16.51. Исследовательский шаг: размер полинома $P_\varphi$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с $L$ литералами
  полином $P_\varphi(x)=\prod_j S_{C_j}(x)$, где
  $S_{C}(x)=1-\prod_{\ell\in C}(1-\llbracket \ell\rrbracket)$,
  имеет depth‑3 формулу размера $O(L)$ (по одному множителю на литерал
  плюс константы). Поэтому любой полиномиальный blow‑up редукции
  сохраняет условие «$P_\psi$ имеет размер $\mathrm{poly}(|\psi|)$» в Лемме 15.7.4.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge(x_2\lor x_3\lor x_4)$.
  Тогда $S_{C_1}=1-(1-x_1)(1-(1-x_2))$ и
  $S_{C_2}=1-(1-x_2)(1-x_3)(1-x_4)$, и
  $P_\varphi=S_{C_1}\cdot S_{C_2}$ — depth‑3 формула с числом множителей,
  линейным по числу литералов (5).
- `Статус:` доказано (прямой подсчёт).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.4,
  что размер $P_\varphi$ линеен по числу литералов и сохраняется при
  полиномиальном blow‑up редукций.

### 16.52. Исследовательский шаг: нуль на кубе ⇒ тождественный нуль

- `Линза:` Эквивалентность.
- `Утверждение:` Если multilinear‑полином $Q(x_1,\dots,x_n)$ над полем
  удовлетворяет $Q(a)=0$ для всех $a\in\{0,1\}^n$, то $Q\equiv 0$.
  (Значения на булевом кубе единственным образом задают multilinear‑полином.)
- `Toy‑тест:` $n=1$: $Q(x)=ax+b$. Из $Q(0)=b=0$ и $Q(1)=a+b=0$ следует $a=b=0$.
  $n=2$: $Q(x,y)=a xy+ b x + c y + d$. Нули на четырёх точках дают систему
  $d=0$, $b+d=0$, $c+d=0$, $a+b+c+d=0$, значит $a=b=c=d=0$.
- `Статус:` доказано (уникальность multilinear‑представления).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить краткую ремарку рядом с санити‑чеком
  (разд. 15.7), что multilinear‑полином однозначно восстанавливается по
  значениям на $\{0,1\}^n$.

### 16.53. Исследовательский шаг: $P_\varphi$ как индикатор выполнимости

- `Линза:` Эквивалентность.
- `Утверждение:` Для булевого присваивания $a\in\{0,1\}^n$ и клаузы
  $C=(\ell_1\lor\cdots\lor\ell_k)$ полином
  $S_C(a)=1-\prod_{i=1}^k(1-\llbracket \ell_i\rrbracket)$ равен $1$
  тогда и только тогда, когда $C(a)=1$. Следовательно,
  $P_\varphi(a)=\prod_j S_{C_j}(a)=1$ тогда и только тогда, когда $\varphi(a)=1$,
  и $\varphi$ невыполнима $\iff P_\varphi$ нулевой на $\{0,1\}^n$.
- `Toy‑тест:` $\varphi=(x_1\lor\neg x_2)\wedge x_2$.
  При $a=(1,0)$ имеем $S_{x_1\lor\neg x_2}=1-(1-1)(1-(1-0))=1$,
  $S_{x_2}=1-(1-0)=0$, значит $P_\varphi(a)=0$ и $\varphi(a)=0$.
  При $a=(1,1)$ оба множителя равны $1$, и $\varphi(a)=1$.
- `Статус:` доказано (прямая проверка на булевом кубе).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку около санити‑чека,
  что $P_\varphi$ совпадает с индикатором выполнимости на $\{0,1\}^n$.

### 16.54. Исследовательский шаг: выбор «канонической» реализации счётчика

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для формулы $\mathrm{Count}_{\ge T}$ в $tt(f_n,s,t)$
  достаточно любой стандартной реализации размером $\mathrm{poly}(2^n)$.
  Adder‑tree даёт $O(N\log N)$, Batcher даёт $O(N\log^2 N)$, обе подходят
  для EF и масштаба $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $N=8$: adder‑tree складывает пары битов (4 сумматора),
  затем суммы (2 сумматора), затем финальная сумма (1 сумматор) и компаратор;
  всего $O(N\log N)$ элементов. Sorting‑network на $N=8$ имеет
  $O(N\log^2 N)$ компараторов. Оба дают булеву формулу размера poly.
- `Статус:` доказано (сравнение оценок).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` выбрать один вариант для фиксации в основном тексте рядом
  с Леммой 15.7.1d.

### 16.55. Исследовательский шаг: $m(s)$ полиномиально от $|x|$ при LogLog

- `Линза:` Сжатие/канонизация.
- `Утверждение:` При подстановке $x=2^{2^n}$ имеем $|x|=2^n+1$ и
  $s=2^{n/4}$. Тогда длина кода схемы $m(s)=O(s\log s)=2^{O(n)}$
  удовлетворяет $m(s)\le |x|^{O(1)}$. Значит ограничение на код схемы
  $|C|\le m(s)$ (эквивалентно $C<2^{m(s)}$) в (H1$_\Pi$) является bounded‑квантором в масштабе $n\in\mathrm{LogLog}$.
- `Toy‑тест:` $n=4$: $x=2^{16}$, $|x|=17$, $s=2^{1}=2$ и
  $m(s)=O(2\log 2)=O(2)\le |x|$.
- `Статус:` доказано (прямая оценка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H1$_\Pi$),
  что $m(2^{n/4})$ полиномиально от $|x|$ при LogLog‑масштабе.

### 16.56. Исследовательский шаг: тотальность $R$ в $\mathrm{S}^1_2$

- `Линза:` Эквивалентность.
- `Утверждение:` Если $R$ — p‑time редукция, то её тотальность выражается
  $\Sigma^b_1$‑формулой $\forall n\,\forall C<2^{m(n)}\,\exists y\le p(n)\,
  \mathrm{Graph}_R(n,C,y)$ и доказывается в $\mathrm{S}^1_2$ (PV‑вычислимость).
  Это обеспечивает переход от (H2$_\Pi$) к $\forall\exists$‑форме с $y$.
- `Toy‑тест:` Пусть $R(n,C)$ возвращает $C_1$. Тогда $\mathrm{Graph}_R(n,C,y)$
  — bounded‑формула $y\leftrightarrow C_1$. Очевидно,
  $\forall C\,\exists y\le 1\,\mathrm{Graph}_R(n,C,y)$ истинно.
- `Статус:` доказано (стандартная тотальность PV‑функций).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с (H2$_\Pi$),
  что тотальность $R$ доказуема в $\mathrm{S}^1_2$.

### 16.57. Исследовательский шаг: кодирование множества ошибок $S$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` В $\mathrm{Err}_{t(n)}$ множество $S\subseteq\{0,1\}^n$
  можно кодировать битовой маской длины $2^n$, то есть числом
  $S<2^{2^n}$. При LogLog‑подстановке $x=2^{2^n}$ имеем $S\le x$,
  поэтому квантор $\exists S$ является bounded, и $\mathrm{Err}_{t(n)}$
  остаётся $\Delta^b_0$‑формулой.
- `Toy‑тест:` $n=2$: $x=2^{2^2}=16$. Любое $S\subseteq\{0,1\}^2$ кодируется
  4‑битной маской $<2^4=16=x$ (например, $S=\{00,11\}$ соответствует $1001_2$).
- `Статус:` доказано (явное кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить рядом с $\mathrm{Err}_{t(n)}$ в L2,
  что квантор по $S$ bounded через $x=2^{2^n}$.

### 16.58. Исследовательский шаг: membership $x\in S$ как бит‑доступ

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Если $S<2^{2^n}$ кодирует подмножество $\{0,1\}^n$ битовой
  маской длины $2^n$, то предикат $x\in S$ эквивалентен $\mathrm{Bit}(S,x)=1$.
  Функция $\mathrm{Bit}$ PV‑вычислима, поэтому условие $x\in S$ является
  $\Delta^b_0$‑формулой при bounded‑кванторах $x<2^n$ и $S<2^{2^n}$.
- `Toy‑тест:` $n=2$, $S=1001_2$ кодирует $\{00,11\}$.
  Тогда $\mathrm{Bit}(S,0)=1$, $\mathrm{Bit}(S,3)=1$, а $\mathrm{Bit}(S,1)=0$.
- `Статус:` доказано (бит‑доступ).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании уточнить в L2, что проверка $x\notin S$
  реализуется через $\mathrm{Bit}(S,x)=0$.

### 16.59. Исследовательский шаг: размер $|S|$ через счётчик

- `Линза:` Эквивалентность.
- `Утверждение:` Если $S$ задано битовой маской длины $2^n$, то условие
  $|S|<T$ эквивалентно $\neg\mathrm{Count}_{\ge T}(S)$, где счётчик
  применяется к битам маски. При LogLog‑подстановке $x=2^{2^n}$ порог
  $T\le 2^n\le |x|$, поэтому проверка $|S|<T$ остаётся bounded и $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $S=1011_2$ имеет $|S|=3$. При $T=3$
  $\mathrm{Count}_{\ge 3}(S)=1$, значит $|S|<T$ ложно; при $T=4$
  $\mathrm{Count}_{\ge 4}(S)=0$, значит $|S|<T$ истинно.
- `Статус:` доказано (перепись через счётчик).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что условие $|S|<t(n)2^n$
  можно выразить через $\mathrm{Count}_{\ge T}$ на маске $S$.

### 16.60. Исследовательский шаг: степень $P_\varphi$ полиномиальна

- `Линза:` Инвариант.
- `Утверждение:` Для CNF $\varphi=\bigwedge_{j=1}^m C_j$ с суммарным числом
  литералов $L$ полином $P_\varphi=\prod_j S_{C_j}$ имеет степень
  $\deg(P_\varphi)=\sum_j |C_j|\le L$. После multilinearization степень
  не увеличивается. Следовательно, степень $P_\varphi$ и $\mathrm{ML}(P_\varphi)$
  полиномиальна в $|\varphi|$, что согласуется с требованиями PIT для ROABP.
- `Toy‑тест:` $\varphi=(x_1\lor x_2)\wedge(\neg x_2\lor x_3\lor x_4)$:
  $\deg S_{C_1}=2$, $\deg S_{C_2}=3$, значит $\deg P_\varphi=5$ (полиномиально).
- `Статус:` доказано (прямой подсчёт степени).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку возле Леммы 15.7.4,
  что степень $\mathrm{ML}(P_\varphi)$ ограничена $O(|\varphi|)$.

### 16.61. Исследовательский шаг: $r(\varphi)$ логически усиливает $\varphi$

- `Линза:` Инвариант.
- `Утверждение:` Для стандартной редукции CNF→3‑CNF формула $r(\varphi)$
  логически влечёт $\varphi$ по исходным переменным: для каждой клаузы
  $(\ell_1\lor\cdots\lor\ell_k)$ цепочка 3‑клауз в $r(\varphi)$
  удовлетворима только если исходная клауза истинна. Следовательно,
  $r(\varphi)\to \varphi$ (но обратное неверно).
- `Toy‑тест:` Клауза $(\ell_1\lor\ell_2\lor\ell_3\lor\ell_4)$ заменяется на
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor\ell_4)$.
  Если все $\ell_i=0$, то первая клауза требует $y_1=1$, а вторая даёт
  $(\neg y_1\lor 0\lor 0)=0$, противоречие. Значит $r(\varphi)$ возможно
  только при истинной исходной клаузе.
- `Статус:` доказано.
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.3c,
  что $r(\varphi)\Rightarrow \varphi$, а для обратного направления нужен $g$.

### 16.62. Исследовательский шаг: $\mathrm{Err}_{t(n)}$ как $\Delta^b_0$‑формула

- `Линза:` Эквивалентность.
- `Утверждение:` В LogLog‑масштабе $\mathrm{Err}_{t(n)}(C,y)$ можно переписать
  как bounded‑формулу:
  $$\exists S\le 2^{2^n}\ \bigl(\neg\mathrm{Count}_{\ge T}(S)\ \wedge\
  \forall x<2^n\ (\mathrm{Bit}(S,x)=0\to \mathrm{Eval}(C,x)=y(x))\bigr),$$
  где $T=\lceil t(n)2^n\rceil$. Все кванторы bounded (через $x=2^{2^n}$),
  а $\mathrm{Bit}$ и $\mathrm{Eval}$ — PV‑вычислимы, значит
  $\mathrm{Err}_{t(n)}$ является $\Delta^b_0$.
- `Toy‑тест:` $n=2$, $C=y$ (ошибок нет). Берём $S=0000_2$,
  $\mathrm{Count}_{\ge 1}(S)=0$, и для любого $x$ имеем
  $\mathrm{Bit}(S,x)=0\Rightarrow C(x)=y(x)$. Формула истинна.
  Если $C$ ошибается ровно на $x=3$, то берём $S=1000_2$;
  при $t(n)=1/2$ получаем $T=2$ и $\neg\mathrm{Count}_{\ge 2}(S)$ истинно.
- `Статус:` доказано (сведение к бит‑маске и счётчику).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании отметить в L2, что $\mathrm{Err}_{t(n)}$
  переписывается в явную bounded‑форму через $\mathrm{Bit}$ и счётчик.

### 16.63. Исследовательский шаг: линейный blow‑up в CNF→3‑CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для клаузы длины $k\ge 3$ стандартная цепочная редукция
  $(\ell_1\lor\cdots\lor\ell_k)\mapsto$ цепочку из $k-2$ 3‑клауз
  вводит $k-3$ новых переменных и $3(k-2)$ литералов. Следовательно, если
  $\varphi$ имеет суммарно $L$ литералов, то $r(\varphi)$ имеет размер $O(L)$
  (линейный blow‑up).
- `Toy‑тест:` $k=5$:
  $(\ell_1\lor\ell_2\lor y_1)\land(\neg y_1\lor\ell_3\lor y_2)\land(\neg y_2\lor\ell_4\lor\ell_5)$.
  Здесь 3 клаузы, 2 новых переменных, 9 литералов, что равно $3(k-2)$.
- `Статус:` доказано (подсчёт по клауза‑в‑клаузу).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.3c
  с явным подсчётом числа клауз/литералов.

### 16.64. Исследовательский шаг: multilinearization не меняет значения на кубе

- `Линза:` Эквивалентность.
- `Утверждение:` Для любого многочлена $P$ над полем и его multilinearization
  $\mathrm{ML}(P)$ (редукция по правилам $x_i^2\mapsto x_i$) выполняется
  $\mathrm{ML}(P)(a)=P(a)$ для всех $a\in\{0,1\}^n$. Следовательно, $P$ и
  $\mathrm{ML}(P)$ совпадают на булевом кубе, и проверка нулевости на кубе
  эквивалентна.
- `Toy‑тест:` $P(x)=x^2+x$. На $x\in\{0,1\}$ имеем $x^2=x$, значит
  $P(x)=2x$. После редукции $\mathrm{ML}(P)=x+x=2x$, значения совпадают.
- `Статус:` доказано (так как $x_i^2=x_i$ на $\{0,1\}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что $\mathrm{ML}(P_\varphi)$ совпадает с $P_\varphi$ на $\{0,1\}^n$.

### 16.65. Исследовательский шаг: $\mathrm{ML}(P_\varphi)$ вычислима depth‑3 формулой

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Поскольку $P_\varphi=\prod_j S_{C_j}$ уже является
  depth‑3 формулой (произведение дизъюнктов, каждый — $1-\prod(1-\ell)$),
  а multilinearization заменяет степени $x_i^2$ на $x_i$ без увеличения
  структуры, то $\mathrm{ML}(P_\varphi)$ также вычислима depth‑3 формулой
  размера $O(L)$, где $L$ — число литералов в $\varphi$.
- `Toy‑тест:` Для $\varphi=(x_1\lor\neg x_2)$ имеем
  $P_\varphi=1-(1-x_1)(1-(1-x_2))$ — depth‑3. В $P_\varphi$ нет степеней $>1$,
  поэтому $\mathrm{ML}(P_\varphi)=P_\varphi$, и глубина/размер сохраняются.
- `Статус:` доказано (структура не усложняется).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к Лемме 15.7.4, что
  $\mathrm{ML}(P_\varphi)$ остаётся depth‑3 формулой размера $O(L)$.

### 16.66. Исследовательский шаг: корректность ограничения «$|C|\le m(s)$» (или $C<2^{m(s)}$)

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Ограничение на код схемы вида $|C|\le m(s)$ (эквивалентно
  числовому $C<2^{m(s)}$) в $tt(f_n,s,t)$ и (H1$_\Pi$) корректно: оно лишь фиксирует
  длину кода схемы $C$ и не исключает ни одной схемы размера $\le s$, поскольку
  любой такой код можно дополнить нулями до длины $m(s)$ (паддинг). Следовательно,
  квантор по $C<2^{m(s)}$ эквивалентен квантору по всем схемам размера $\le s$
  (при наличии фильтра $\mathrm{Valid}_s(C)$).
- `Toy‑тест:` $s=2$, схема из одного гейта AND имеет код длины $m(2)$.
  Если код короче, дополняем нулями; валидность $\mathrm{Valid}_2(C)$
  остаётся истинной. Значит ограничение $|C|\le m(2)$ (или $C<2^{m(2)}$) не теряет схем.
- `Статус:` доказано (паддинг).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку к (H1$_\Pi$)/(H2$_\Pi$),
  что ограничение $|C|\le m(s)$ — это лишь фиксирование длины кода.

### 16.67. Исследовательский шаг: $P_\varphi$ может быть не‑multilinear

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Полином $P_\varphi=\prod_j S_{C_j}$ может содержать степени
  $x_i^2$ из‑за повторных вхождений переменной в разных клауза, поэтому
  multilinearization действительно нужна в барьере 15.7.4.
- `Toy‑тест:` $\varphi=(x)\wedge(x\lor y)$. Тогда
  $P_\varphi=x\cdot(1-(1-x)(1-y))=x(x+y-xy)=x^2+xy-x^2y$ — не multilinear.
  На булевом кубе $x^2=x$, и $\mathrm{ML}(P_\varphi)=x$.
- `Статус:` доказано (явный пример).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что ML нужен, поскольку $P_\varphi$ может содержать $x_i^2$ при повторных
  вхождениях переменной.

### 16.68. Исследовательский шаг: CNF‑кодирование компаратора

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Для $k$‑битных чисел $S$ и константы $T$ сравнение
  $S\ge T$ кодируется CNF размером $O(k)$ с $O(k)$ вспомогательными
  переменными (через префикс‑равенство и «первое превышение»).
  Поэтому перевод компаратора в CNF не меняет асимптотику
  $\mathrm{Count}_{\ge T}$.
- `Toy‑тест:` $k=2$, $S=s_1s_0$, $T=t_1t_0$. Пусть
  $e_i\leftrightarrow(s_i\leftrightarrow t_i)$ и
  $g_i\leftrightarrow(s_i\land\neg t_i)$.
  Тогда $S\ge T \iff g_1\lor(e_1\land g_0)\lor(e_1\land e_0)$.
  Каждый $e_i,g_i$ и комбинирование кодируются $O(1)$ клаузами.
- `Статус:` доказано (Tseitin‑кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1d,
  что компаратор имеет CNF‑кодирование размера $O(\log N)$.

### 16.69. Исследовательский шаг: $t(n)$ и $T(n)$ действительно целые

- `Линза:` Эквивалентность.
- `Утверждение:` Для $t(n)=1/2-1/2^{n/4}$ и $n$ кратного 4 порог
  $T(n)=t(n)2^n$ является целым, а именно
  $T(n)=2^{n-1}-2^{3n/4}$. Поэтому в этом случае $\lceil t(n)2^n\rceil$
  не требуется, и $\mathrm{Count}_{\ge T}$ задаётся целым порогом.
- `Toy‑тест:` $n=4$: $t(n)=1/2-1/2=0$, значит $T(4)=0$.
  Формула $\mathrm{Count}_{\ge 0}$ тривиально истинна; это согласуется
  с формулой $2^{n-1}-2^{3n/4}=8-8=0$.
- `Статус:` доказано (подстановка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1c,
  что при $4\mid n$ порог целый и округление не нужно.

### 16.70. Исследовательский шаг: «почти половина» для $t(n)$

- `Линза:` Инвариант.
- `Утверждение:` Для $t(n)=1/2-1/2^{n/4}$ имеем
  $$\tfrac12 - t(n)=2^{-n/4},\qquad T(n)=t(n)2^n=2^{n-1}-2^{3n/4}.$$
  Поэтому допустимая корреляция с функцией уменьшается как $2^{-n/4}$,
  т.е. требование — «почти половина» ошибок.
- `Toy‑тест:` $n=8$: $t(n)=1/2-1/2^{2}=1/2-1/4=1/4$,
  $T(n)=2^{7}-2^{6}=128-64=64$. Ошибка должна быть хотя бы на 64 входах
  из 256.
- `Статус:` доказано (подстановка).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что $1/2-t(n)=2^{-n/4}$ и как это соотносится с «almost balanced».

### 16.71. Исследовательский шаг: Tseitin‑кодирование счётчика

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Если $\mathrm{Count}_{\ge T}$ вычисляется булевой схемой
  размера $S$ (adder‑tree/Batcher), то её Tseitin‑кодирование даёт CNF
  с $O(S)$ вспомогательными переменными и $O(S)$ клаузами, эквисатисфакционную
  исходной схеме. Следовательно, формула $\mathrm{Count}_{\ge T}$ может быть
  задана пропозиционально размера $\mathrm{poly}(2^n)$.
- `Toy‑тест:` Полусумматор: $s=a\oplus b$, $c=a\land b$.
  $c\leftrightarrow(a\land b)$ кодируется 3 клаузаами,
  $s\leftrightarrow(a\oplus b)$ — 4 клаузаами. Итого $O(1)$ клауз на гейт,
  значит общий размер $O(S)$.
- `Статус:` доказано (стандартное Tseitin‑кодирование).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.1d,
  что $\mathrm{Count}_{\ge T}$ можно переводить в CNF с линейным оверхедом.

### 16.72. Исследовательский шаг: «почти половина» даёт большой порог

- `Линза:` Инвариант.
- `Утверждение:` При $t(n)=1/2-1/2^{n/4}$ порог $T(n)=t(n)2^n$ удовлетворяет
  $$2^{n-2}\ <\ T(n)\ <\ 2^{n-1}$$
  для всех достаточно больших $n$. Значит порог асимптотически пропорционален
  $2^n$ и «почти половина» ошибок — действительно большая доля.
- `Toy‑тест:` $n=8$: $T(8)=2^{7}-2^{6}=128-64=64$, и
  $2^{6}=64 < T(8)=64 < 2^{7}=128$ (граница достигается на малом $n$).
- `Статус:` доказано (оценка $2^{n-1}-2^{3n/4}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что порог $T(n)$ всегда линейный по $2^n$ (почти половина).

### 16.73. Исследовательский шаг: $t(n)$ монотонно растёт к $1/2$

- `Линза:` Инвариант.
- `Утверждение:` Функция $t(n)=1/2-2^{-n/4}$ монотонно возрастает по $n$ и
  $\lim_{n\to\infty} t(n)=1/2$. Следовательно, требование средней ошибки
  становится всё строже при росте $n$.
- `Toy‑тест:` $n=4$: $t=0$; $n=8$: $t=1/4$; $n=12$: $t=1/2-2^{-3}=3/8$.
  Значения растут и приближаются к $1/2$.
- `Статус:` доказано (монотонность $2^{-n/4}$).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с определением $t(n)$,
  что оно монотонно и стремится к $1/2$.

### 16.74. Исследовательский шаг: $\varphi$ невыполнима $\Leftrightarrow \mathrm{ML}(P_\varphi)\equiv 0$

- `Линза:` Эквивалентность.
- `Утверждение:` Для CNF $\varphi$ верно
  $$\varphi\ \text{невыполнима}\ \iff\ \mathrm{ML}(P_\varphi)\equiv 0.$$
  Доказательство: по шагам 16.53 и 16.64, $P_\varphi$ и $\mathrm{ML}(P_\varphi)$
  совпадают с индикатором выполнимости на $\{0,1\}^n$, а по 16.52 нулевой
  на кубе multilinear‑полином тождественно нулевой.
- `Toy‑тест:` $\varphi=(x)\wedge(\neg x)$ невыполнима. Тогда
  $P_\varphi=x(1-x)=x-x^2$, $\mathrm{ML}(P_\varphi)=x-x=0$.
  Для $\varphi=(x)$ имеем $P_\varphi=x$, $\mathrm{ML}(P_\varphi)=x\not\equiv 0$.
- `Статус:` доказано (сведение к предыдущим шагам).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с санити‑чеком,
  что эквивалентность следует из шагов 16.52/16.53/16.64.

### 16.75. Исследовательский шаг: мелкость редукции не влияет на PIT

- `Линза:` Трейд‑офф.
- `Утверждение:` В барьере 15.7.4 детерминированный PIT для ROABP
  применяется к $\mathrm{ML}(P_\psi)$, где $|\psi|\le \mathrm{poly}(|\varphi|)$.
  Любой полиномиальный blow‑up редукции лишь меняет полином в степени
  размера/степени ROABP, поэтому время PIT остаётся полиномиальным.
- `Toy‑тест:` Если $|\psi|\le |\varphi|^2$ и PIT работает за $O(|\psi|^3)$,
  то общий runtime $O(|\varphi|^6)$ — всё ещё полином.
- `Статус:` доказано (оценка композиции).
- `Барьер‑чек:` r — неприменимо, NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` при желании добавить ремарку рядом с Леммой 15.7.4c,
  что полиномиальный blow‑up не влияет на асимптотику PIT.

### 16.76. Исследовательский шаг: bounded‑occurrence 3‑SAT с линейным blow‑up

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из 3‑SAT в 3‑SAT, где каждая
  переменная встречается не более 9 раз, а размер растёт линейно.
  Конструкция: для переменной $x$ с $k$ вхождениями вводим $x_1,\dots,x_k$,
  заменяем каждое вхождение на свой $x_i$, и добавляем цепочку равенств
  $x_i\leftrightarrow x_{i+1}$ для $i=1..k-1$. Каждое равенство
  $(x_i\lor\neg x_{i+1})\land(\neg x_i\lor x_{i+1})$ превращаем в 3‑CNF
  через $(a\lor b)\equiv(a\lor b\lor y)\land(a\lor b\lor\neg y)$.
  Тогда для каждого $x_i$ получаем не более $1+2\cdot 4=9$ вхождений,
  а общее число новых клауз/переменных пропорционально сумме вхождений.
- `Toy‑тест:` $x$ встречается 3 раза. Вводим $x_1,x_2,x_3$ и клаузы
  $x_1\leftrightarrow x_2$, $x_2\leftrightarrow x_3$.
  Если $x=1$ в удовлетворяющем присваивании, то берём $x_1=x_2=x_3=1$,
  и все равенства истинны; обратно, равенства заставляют все $x_i$ совпадать,
  значит присваивание сжимается к значению $x$.
- `Статус:` доказано (явная редукция).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` при желании ужесточить константу до 4 (Tovey) или оценить
  blow‑up в планарной редукции Лихтенштейна.

### 16.77. Исследовательский шаг: счётчик $\mathrm{Count}_{\ge T}$ размера $O(N\log N)$

- `Линза:` Трейд‑офф.
- `Утверждение:` Для $N$ входных битов существует булева схема размера
  $O(N\log N)$, вычисляющая $\mathrm{Count}_{\ge T}(b_1,\dots,b_N)$:
  построим двоичное дерево сумматоров, получая $k=\lceil\log_2 N\rceil$‑битную сумму $S$,
  затем сравним $S\ge T$ компаратором размера $O(k)$.
  Для «простого» дерева ripple‑carry‑сумматоров глубина $O(\log^2 N)$; глубину можно
  улучшить до $O(\log N)$, но для LogLog нам достаточно размера $O(2^n n)=\mathrm{poly}(2^n)$.
- `Toy‑тест:` $N=4$, $T=3$. Складываем пары $(b_1,b_2)$ и $(b_3,b_4)$
  полусумматорами, затем суммируем два 2‑битных числа полным сумматором;
  компаратор проверяет $S\ge 3$ (двоично $11$).
- `Статус:` доказано (явная конструкция).
- `Барьер‑чек:` r — неприменимо (синтаксическая схема), NP — неприменимо
  (нет нижних оценок), alg — неприменимо (нет арифметизации).
- `Следующий шаг:` при желании связать с Леммой 15.7.1d: указать явный
  размер счётчика $O(2^n n)$ и затем применить 16.71 для CNF‑кодирования.

### 16.78. Исследовательский шаг: явный линейный счёт для CNF→3‑CNF

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Пусть CNF $\varphi$ имеет клаузы длины $k_1,\dots,k_m$ и суммарно
  $L=\sum_j k_j$ литералов. Определим редукцию $r$: клаузы длины $\le 3$
  оставляем, а клаузу длины $k>3$ заменяем цепочкой из $k-2$ 3‑клауз с
  $k-3$ новыми переменными. Тогда
  $$\#\mathrm{clauses}(r(\varphi))\le \sum_{k_j\le 3}1+\sum_{k_j>3}(k_j-2)\le \sum_j k_j=L,$$
  и потому $\#\mathrm{lits}(r(\varphi))\le 3L$.
  Следовательно, редукция CNF→3‑CNF имеет линейный blow‑up по $L$.
- `Toy‑тест:` Клауза длины $4$ даёт $k-2=2$ клаузы и $k-3=1$ новую переменную,
  т.е. 6 литералов вместо 4; оценка $6\le 3\cdot 4$ выполняется.
- `Статус:` доказано (подсчёт по клаузам).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` при желании зафиксировать это как числовую ремарку
  в Лемме 15.7.3c (PIT ⇒ IPS/EF).

### 16.79. Исследовательский шаг: квантор по кодам схем и паддинг

- `Линза:` Эквивалентность.
- `Утверждение:` Зафиксируем gate-list кодирование булевых схем размера $\le s$
  битстроками длины $m(s)$, а также предикат $\mathrm{Valid}_s(C)$, который
  проверяет корректность кода. Тогда квантор «для всех схем размера $\le s$»
  эквивалентно выражается как
  $$\forall C<2^{m(s)}\ \bigl(\mathrm{Valid}_s(C)\to P(C)\bigr),$$
  где $P(C)$ — любое утверждение, зависящее только от декодированной схемы.
  В частности, bounded‑ограничение $C<2^{m(s)}$ (эквивалентно $|C|\le m(s)$) в (H1$_\Pi$)/(H2$_\Pi$) фиксирует лишь
  длину кода (bounded‑квантор) и не исключает ни одной схемы размера $\le s$:
  короткий код можно дополнить нулями до длины $m(s)$ (не меняя декодированную
  схему), а $\mathrm{Valid}_s$ отсекает не‑коды.
- `Toy‑тест:` $s=2$. Схема из одного AND‑гейта имеет код длины $\le m(2)$.
  Дополнение до длины $m(2)$ нулями не меняет список гейтов (пустой «хвост»
  читается как фиктивные гейты/константы), поэтому $\mathrm{Valid}_2(C)=1$
  и все свойства схемы (выход на $x$) сохраняются.
- `Статус:` доказано (паддинг фиксирует длину).
- `Барьер‑чек:` r — неприменимо (синтаксический трюк), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` зафиксировать эту эквивалентность как ремарку рядом с
  Леммой 15.7.2b в основном тексте (закрыть Q2a).

### 16.80. Исследовательский шаг: 3‑CNF для $\mathrm{Count}_{\ge T}$ размера $O(N\log N)$

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Пусть $N=2^n$ и $T\in\{0,\dots,N\}$. Тогда существует 3‑CNF
  формула $\mathrm{Count}_{\ge T}^{\mathrm{CNF}}(e,z)$ размера $O(N\log N)$
  (по числу клауз/литералов), такая что для любого присваивания $e\in\{0,1\}^N$
  выполнено:
  $$\exists z\ \mathrm{Count}_{\ge T}^{\mathrm{CNF}}(e,z)\quad\Longleftrightarrow\quad \sum_{i=1}^N e_i\ge T.$$
  Доказательство: по 16.77 есть схема размера $S=O(N\log N)$ для
  $\mathrm{Count}_{\ge T}$ (adder‑tree + компаратор), а по 16.71 Tseitin‑кодирование
  любой схемы размера $S$ даёт CNF (и даже 3‑CNF) с $O(S)$ вспомогательными
  переменными и $O(S)$ клаузами.
- `Toy‑тест:` $N=4$, $T=3$: схема вычисляет сумму $S\in\{0,\dots,4\}$ и проверяет
  $S\ge 3$. Tseitin‑кодирование добавляет константное число клауз на гейт,
  поэтому размер остаётся $O(4\log 4)$.
- `Статус:` доказано (композиция 16.77 + 16.71).
- `Барьер‑чек:` r — неприменимо (синтаксическая конструкция), NP — неприменимо
  (нет нижних оценок), alg — неприменимо.
- `Следующий шаг:` зафиксировать как ремарку рядом с Леммой 15.7.1d (закрыть Q1a).

### 16.81. Исследовательский шаг: Tovey‑splitting даёт (O3, $L\le 3$)-SAT с линейным blow‑up

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из 3‑SAT в CNF, где каждая
  переменная встречается не более 3 раз, а длины клауз $\le 3$ (разрешены 2‑клаузы),
  причём размер растёт линейно. Конструкция (Tovey; см. Theorem 3 в Berman–Karpinski–Scott):
  если переменная $x$ встречается $d>3$ раз, вводим $x_1,\dots,x_d$,
  заменяем $d$ вхождений $x$ на $x_1,\dots,x_d$ и добавляем цикл 2‑клауз
  $$x_1\vee\neg x_2,\ x_2\vee\neg x_3,\ \dots,\ x_{d-1}\vee\neg x_d,\ x_d\vee\neg x_1.$$
  Эти клаузы эквивалентны $x_1=\cdots=x_d$, поэтому (не)выполнимость сохраняется.
  Каждый $x_i$ встречается ровно в одной исходной клаузе и в двух 2‑клаузах,
  то есть не более 3 раз; добавлено $d$ клауз и $d$ переменных, так что суммарный
  blow‑up $O(L)$ по числу литералов $L$ исходной формулы.
- `Toy‑тест:` $d=4$. Цикл
  $x_1\vee\neg x_2,\ x_2\vee\neg x_3,\ x_3\vee\neg x_4,\ x_4\vee\neg x_1$
  задаёт импликации $x_2\to x_1\to x_4\to x_3\to x_2$, значит все $x_i$ равны.
  Тогда удовлетворяющее присваивание переносится между исходной формулой и новой,
  полагая $x:=x_1$ и $x_i:=x$.
- `Статус:` доказано (явная редукция + подсчёт).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` найти/зафиксировать гаджет, устраняющий 2‑клаузы и дающий
  3‑CNF с ограничением ≤4 вхождения (Tovey‑вариант), либо оценить blow‑up
  в планарной редукции Лихтенштейна.

### 16.82. Исследовательский шаг: устранение 2‑клауз ⇒ 3‑CNF с ограничением ≤4 вхождения

- `Линза:` Эквивалентность.
- `Конвенция:` в этом проекте 3‑CNF допускает дублирование литералов внутри клаузы (используется только как 2→3 padding).
- `Утверждение:` Существует p‑time редукция $R$ из 3‑SAT в 3‑SAT, такая что в
  $R(\varphi)$ каждая переменная встречается не более 4 раз, а размер растёт
  линейно по числу литералов. Достаточно улучшить конструкцию 16.81:
  все 2‑клаузы вида $(x_i\vee\neg x_{i+1})$ заменить на 3‑клаузы
  $$(x_i\vee x_i\vee\neg x_{i+1}).$$
  Эта замена эквивалентна (добавляет дубликат литерала), поэтому (не)выполнимость
  сохраняется. Если $x_i$ — копия переменной из 16.81, то она встречается
  1 раз в «исходной» 3‑клаузе и ещё 3 раза в цикле (дважды как $x_i$ в своей
  клаузе и один раз как $\neg x_i$ в предыдущей), итого ≤4.
- `Toy‑тест:` цикл для $d=4$:
  $(x_1\vee x_1\vee\neg x_2)\wedge(x_2\vee x_2\vee\neg x_3)\wedge
  (x_3\vee x_3\vee\neg x_4)\wedge(x_4\vee x_4\vee\neg x_1)$
  эквивалентен циклу 2‑клауз из 16.81 и потому задаёт $x_1=\cdots=x_4$.
  Подсчёт: $x_2$ встречается дважды в своей клаузе, один раз как $\neg x_2$
  в первой и (ровно) один раз в исходной 3‑клаузе, где она заменила одно
  вхождение переменной $x$.
- `Статус:` доказано (2→3‑padding + подсчёт вхождений).
- `Барьер‑чек:` r — применимо (чистая редукция, релятивизируется),
  NP — неприменимо, alg — неприменимо.
- `Следующий шаг:` в основном тексте рядом с Леммой 15.7.4d указать, что
  NP‑трудность 3‑SAT с ограничением «каждая переменная ≤4 вхождения» следует
  из 16.81–16.82 (без внешних фактов, кроме NP‑полноты 3‑SAT).

### 16.83. Исследовательский шаг: blow‑up редукции 3‑SAT → Planar 3‑SAT (Lichtenstein)

- `Линза:` Трейд‑офф.
- `Утверждение:` Пусть $\varphi$ — 3‑CNF с $m$ клаузами и $n$ переменными.
  В редукции Лихтенштейна (1982) делается planarization инцидентного графа:
  пересечения устраняются фиксированным crossover‑гаджетом, добавляющим $O(1)$
  новых переменных/клауз на одно пересечение. В стандартной «решёточной» укладке
  число пересечений $\le O(mn)$, поэтому итоговая Planar‑3‑CNF $\varphi'$ имеет
  размер $|\varphi'|=O(mn)$ и, в частности, $|\varphi'|=O(|\varphi|^2)$.
- `Toy‑тест:` $m=n=2$: решётка $6\times 6$ имеет 36 потенциальных точек пересечения,
  значит даже грубая оценка даёт $|\varphi'|=O(1+36)$.
- `Статус:` доказано (оценка blow‑up из описания конструкции).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо
  (это NP‑полнота, не нижняя оценка), alg — неприменимо.
- `Следующий шаг:` сослаться на эту оценку рядом с Леммой 15.7.4d (закрыть Q5).

### 16.84. Исследовательский шаг: Planar‑3‑SAT ≤p Planar‑3‑SAT(≤4‑occ)

- `Линза:` Сжатие/канонизация.
- `Утверждение:` Существует p‑time редукция из Planar‑3‑SAT в Planar‑3‑SAT, где
  каждая переменная встречается не более 4 раз. Пусть $\varphi$ — planar 3‑CNF и
  переменная $x$ встречается $d$ раз. Вводим копии $x_1,\dots,x_d$, заменяем $j$‑е
  вхождение $x$ на $x_j$ и добавляем цикл 3‑клауз
  $$(x_1\vee x_1\vee\neg x_2)\wedge(x_2\vee x_2\vee\neg x_3)\wedge\cdots\wedge(x_d\vee x_d\vee\neg x_1).$$
  Эти клаузы эквивалентны циклу импликаций $x_2\to x_1\to\cdots\to x_d\to x_2$,
  значит форсят $x_1=\cdots=x_d$; удовлетворимость сохраняется. Каждая $x_i$
  встречается дважды в своей клаузе цикла, один раз как $\neg x_i$ в предыдущей
  и ровно один раз в исходной 3‑клаузе ⇒ ≤4. Планарность сохраняется: в planar
  вложении инцидентного графа $\varphi$ заменяем вершину $x$ на planar‑гаджет‑цикл,
  присоединяя внешние рёбра (к исходным клаузам) к вершинам $x_i$ в том же
  циклическом порядке; локальная замена в диске не создаёт пересечений.
- `Toy‑тест:` $d=5$. Из клауз цикла следует $x_2\to x_1\to x_5\to x_4\to x_3\to x_2$,
  значит все $x_i$ равны. Подсчёт: у $x_3$ 2 вхождения в $(x_3\vee x_3\vee\neg x_4)$,
  1 вхождение как $\neg x_3$ в $(x_2\vee x_2\vee\neg x_3)$ и 1 вхождение в «своей»
  исходной клаузе.
- `Статус:` доказано (локальный split + planar‑замена вершины).
- `Барьер‑чек:` r — применимо (редукция релятивизируется), NP — неприменимо,
  alg — неприменимо.
- `Следующий шаг:` добавить 1 строку в Лемму 15.7.4d: Planar‑3‑SAT(≤4‑occ)
  NP‑полон (Лихтенштейн + 16.84).

-/
